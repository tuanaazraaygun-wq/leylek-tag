{"dependencies":[],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  /**\n   * AgoraWebSDK_N-v4.24.2-0-g002485b1-dirty Copyright AgoraInc.\n   */\n\n  !function (e, t) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();\n  }(this, function () {\n    \"use strict\";\n\n    function e(e, t) {\n      return t.forEach(function (t) {\n        t && \"string\" != typeof t && !Array.isArray(t) && Object.keys(t).forEach(function (i) {\n          if (\"default\" !== i && !(i in e)) {\n            var n = Object.getOwnPropertyDescriptor(t, i);\n            Object.defineProperty(e, i, n.get ? n : {\n              enumerable: !0,\n              get: function () {\n                return t[i];\n              }\n            });\n          }\n        });\n      }), Object.freeze(e);\n    }\n    var t = \"undefined\" != typeof globalThis ? globalThis : false ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n    function i(e) {\n      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n    }\n    var n = function (e) {\n        try {\n          return !!e();\n        } catch (e) {\n          return !0;\n        }\n      },\n      r = !n(function () {\n        var e = function () {}.bind();\n        return \"function\" != typeof e || e.hasOwnProperty(\"prototype\");\n      }),\n      o = r,\n      s = Function.prototype,\n      a = s.call,\n      c = o && s.bind.bind(a, a),\n      d = o ? c : function (e) {\n        return function () {\n          return a.apply(e, arguments);\n        };\n      },\n      l = d({}.isPrototypeOf),\n      u = function (e) {\n        return e && e.Math === Math && e;\n      },\n      h = u(\"object\" == typeof globalThis && globalThis) || u(false && window) || u(\"object\" == typeof self && self) || u(\"object\" == typeof t && t) || u(\"object\" == typeof t && t) || function () {\n        return this;\n      }() || Function(\"return this\")(),\n      p = r,\n      _ = Function.prototype,\n      E = _.apply,\n      m = _.call,\n      f = \"object\" == typeof Reflect && Reflect.apply || (p ? m.bind(E) : function () {\n        return m.apply(E, arguments);\n      }),\n      S = d,\n      g = S({}.toString),\n      T = S(\"\".slice),\n      R = function (e) {\n        return T(g(e), 8, -1);\n      },\n      C = R,\n      v = d,\n      y = function (e) {\n        if (\"Function\" === C(e)) return v(e);\n      },\n      I = \"object\" == typeof document && document.all,\n      A = void 0 === I && void 0 !== I ? function (e) {\n        return \"function\" == typeof e || e === I;\n      } : function (e) {\n        return \"function\" == typeof e;\n      },\n      b = {},\n      w = !n(function () {\n        return 7 !== Object.defineProperty({}, 1, {\n          get: function () {\n            return 7;\n          }\n        })[1];\n      }),\n      O = r,\n      N = Function.prototype.call,\n      D = O ? N.bind(N) : function () {\n        return N.apply(N, arguments);\n      },\n      P = {},\n      L = {}.propertyIsEnumerable,\n      k = Object.getOwnPropertyDescriptor,\n      M = k && !L.call({\n        1: 2\n      }, 1);\n    P.f = M ? function (e) {\n      var t = k(this, e);\n      return !!t && t.enumerable;\n    } : L;\n    var U,\n      V,\n      x = function (e, t) {\n        return {\n          enumerable: !(1 & e),\n          configurable: !(2 & e),\n          writable: !(4 & e),\n          value: t\n        };\n      },\n      F = n,\n      B = R,\n      j = Object,\n      G = d(\"\".split),\n      W = F(function () {\n        return !j(\"z\").propertyIsEnumerable(0);\n      }) ? function (e) {\n        return \"String\" === B(e) ? G(e, \"\") : j(e);\n      } : j,\n      H = function (e) {\n        return null == e;\n      },\n      K = H,\n      Y = TypeError,\n      z = function (e) {\n        if (K(e)) throw new Y(\"Can't call method on \" + e);\n        return e;\n      },\n      q = W,\n      X = z,\n      J = function (e) {\n        return q(X(e));\n      },\n      Q = A,\n      Z = function (e) {\n        return \"object\" == typeof e ? null !== e : Q(e);\n      },\n      $ = {},\n      ee = $,\n      te = h,\n      ie = A,\n      ne = function (e) {\n        return ie(e) ? e : void 0;\n      },\n      re = function (e, t) {\n        return arguments.length < 2 ? ne(ee[e]) || ne(te[e]) : ee[e] && ee[e][t] || te[e] && te[e][t];\n      },\n      oe = h.navigator,\n      se = oe && oe.userAgent,\n      ae = se ? String(se) : \"\",\n      ce = h,\n      de = ae,\n      le = ce.process,\n      ue = ce.Deno,\n      he = le && le.versions || ue && ue.version,\n      pe = he && he.v8;\n    pe && (V = (U = pe.split(\".\"))[0] > 0 && U[0] < 4 ? 1 : +(U[0] + U[1])), !V && de && (!(U = de.match(/Edge\\/(\\d+)/)) || U[1] >= 74) && (U = de.match(/Chrome\\/(\\d+)/)) && (V = +U[1]);\n    var _e = V,\n      Ee = _e,\n      me = n,\n      fe = h.String,\n      Se = !!Object.getOwnPropertySymbols && !me(function () {\n        var e = Symbol(\"symbol detection\");\n        return !fe(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Ee && Ee < 41;\n      }),\n      ge = Se && !Symbol.sham && \"symbol\" == typeof Symbol.iterator,\n      Te = re,\n      Re = A,\n      Ce = l,\n      ve = Object,\n      ye = ge ? function (e) {\n        return \"symbol\" == typeof e;\n      } : function (e) {\n        var t = Te(\"Symbol\");\n        return Re(t) && Ce(t.prototype, ve(e));\n      },\n      Ie = String,\n      Ae = function (e) {\n        try {\n          return Ie(e);\n        } catch (e) {\n          return \"Object\";\n        }\n      },\n      be = A,\n      we = Ae,\n      Oe = TypeError,\n      Ne = function (e) {\n        if (be(e)) return e;\n        throw new Oe(we(e) + \" is not a function\");\n      },\n      De = Ne,\n      Pe = H,\n      Le = function (e, t) {\n        var i = e[t];\n        return Pe(i) ? void 0 : De(i);\n      },\n      ke = D,\n      Me = A,\n      Ue = Z,\n      Ve = TypeError,\n      xe = {\n        exports: {}\n      },\n      Fe = h,\n      Be = Object.defineProperty,\n      je = h,\n      Ge = function (e, t) {\n        try {\n          Be(Fe, e, {\n            value: t,\n            configurable: !0,\n            writable: !0\n          });\n        } catch (i) {\n          Fe[e] = t;\n        }\n        return t;\n      },\n      We = \"__core-js_shared__\",\n      He = xe.exports = je[We] || Ge(We, {});\n    (He.versions || (He.versions = [])).push({\n      version: \"3.46.0\",\n      mode: \"pure\",\n      copyright: \"Â© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)\",\n      license: \"https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE\",\n      source: \"https://github.com/zloirock/core-js\"\n    });\n    var Ke = xe.exports,\n      Ye = Ke,\n      ze = function (e, t) {\n        return Ye[e] || (Ye[e] = t || {});\n      },\n      qe = z,\n      Xe = Object,\n      Je = function (e) {\n        return Xe(qe(e));\n      },\n      Qe = Je,\n      Ze = d({}.hasOwnProperty),\n      $e = Object.hasOwn || function (e, t) {\n        return Ze(Qe(e), t);\n      },\n      et = d,\n      tt = 0,\n      it = Math.random(),\n      nt = et(1.1.toString),\n      rt = function (e) {\n        return \"Symbol(\" + (void 0 === e ? \"\" : e) + \")_\" + nt(++tt + it, 36);\n      },\n      ot = ze,\n      st = $e,\n      at = rt,\n      ct = Se,\n      dt = ge,\n      lt = h.Symbol,\n      ut = ot(\"wks\"),\n      ht = dt ? lt.for || lt : lt && lt.withoutSetter || at,\n      pt = function (e) {\n        return st(ut, e) || (ut[e] = ct && st(lt, e) ? lt[e] : ht(\"Symbol.\" + e)), ut[e];\n      },\n      _t = D,\n      Et = Z,\n      mt = ye,\n      ft = Le,\n      St = function (e, t) {\n        var i, n;\n        if (\"string\" === t && Me(i = e.toString) && !Ue(n = ke(i, e))) return n;\n        if (Me(i = e.valueOf) && !Ue(n = ke(i, e))) return n;\n        if (\"string\" !== t && Me(i = e.toString) && !Ue(n = ke(i, e))) return n;\n        throw new Ve(\"Can't convert object to primitive value\");\n      },\n      gt = TypeError,\n      Tt = pt(\"toPrimitive\"),\n      Rt = function (e, t) {\n        if (!Et(e) || mt(e)) return e;\n        var i,\n          n = ft(e, Tt);\n        if (n) {\n          if (void 0 === t && (t = \"default\"), i = _t(n, e, t), !Et(i) || mt(i)) return i;\n          throw new gt(\"Can't convert object to primitive value\");\n        }\n        return void 0 === t && (t = \"number\"), St(e, t);\n      },\n      Ct = ye,\n      vt = function (e) {\n        var t = Rt(e, \"string\");\n        return Ct(t) ? t : t + \"\";\n      },\n      yt = Z,\n      It = h.document,\n      At = yt(It) && yt(It.createElement),\n      bt = function (e) {\n        return At ? It.createElement(e) : {};\n      },\n      wt = bt,\n      Ot = !w && !n(function () {\n        return 7 !== Object.defineProperty(wt(\"div\"), \"a\", {\n          get: function () {\n            return 7;\n          }\n        }).a;\n      }),\n      Nt = w,\n      Dt = D,\n      Pt = P,\n      Lt = x,\n      kt = J,\n      Mt = vt,\n      Ut = $e,\n      Vt = Ot,\n      xt = Object.getOwnPropertyDescriptor;\n    b.f = Nt ? xt : function (e, t) {\n      if (e = kt(e), t = Mt(t), Vt) try {\n        return xt(e, t);\n      } catch (e) {}\n      if (Ut(e, t)) return Lt(!Dt(Pt.f, e, t), e[t]);\n    };\n    var Ft = n,\n      Bt = A,\n      jt = /#|\\.prototype\\./,\n      Gt = function (e, t) {\n        var i = Ht[Wt(e)];\n        return i === Yt || i !== Kt && (Bt(t) ? Ft(t) : !!t);\n      },\n      Wt = Gt.normalize = function (e) {\n        return String(e).replace(jt, \".\").toLowerCase();\n      },\n      Ht = Gt.data = {},\n      Kt = Gt.NATIVE = \"N\",\n      Yt = Gt.POLYFILL = \"P\",\n      zt = Gt,\n      qt = Ne,\n      Xt = r,\n      Jt = y(y.bind),\n      Qt = function (e, t) {\n        return qt(e), void 0 === t ? e : Xt ? Jt(e, t) : function () {\n          return e.apply(t, arguments);\n        };\n      },\n      Zt = {},\n      $t = w && n(function () {\n        return 42 !== Object.defineProperty(function () {}, \"prototype\", {\n          value: 42,\n          writable: !1\n        }).prototype;\n      }),\n      ei = Z,\n      ti = String,\n      ii = TypeError,\n      ni = function (e) {\n        if (ei(e)) return e;\n        throw new ii(ti(e) + \" is not an object\");\n      },\n      ri = w,\n      oi = Ot,\n      si = $t,\n      ai = ni,\n      ci = vt,\n      di = TypeError,\n      li = Object.defineProperty,\n      ui = Object.getOwnPropertyDescriptor,\n      hi = \"enumerable\",\n      pi = \"configurable\",\n      _i = \"writable\";\n    Zt.f = ri ? si ? function (e, t, i) {\n      if (ai(e), t = ci(t), ai(i), \"function\" == typeof e && \"prototype\" === t && \"value\" in i && _i in i && !i[_i]) {\n        var n = ui(e, t);\n        n && n[_i] && (e[t] = i.value, i = {\n          configurable: pi in i ? i[pi] : n[pi],\n          enumerable: hi in i ? i[hi] : n[hi],\n          writable: !1\n        });\n      }\n      return li(e, t, i);\n    } : li : function (e, t, i) {\n      if (ai(e), t = ci(t), ai(i), oi) try {\n        return li(e, t, i);\n      } catch (e) {}\n      if (\"get\" in i || \"set\" in i) throw new di(\"Accessors not supported\");\n      return \"value\" in i && (e[t] = i.value), e;\n    };\n    var Ei = Zt,\n      mi = x,\n      fi = w ? function (e, t, i) {\n        return Ei.f(e, t, mi(1, i));\n      } : function (e, t, i) {\n        return e[t] = i, e;\n      },\n      Si = h,\n      gi = f,\n      Ti = y,\n      Ri = A,\n      Ci = b.f,\n      vi = zt,\n      yi = $,\n      Ii = Qt,\n      Ai = fi,\n      bi = $e,\n      wi = function (e) {\n        var t = function (i, n, r) {\n          if (this instanceof t) {\n            switch (arguments.length) {\n              case 0:\n                return new e();\n              case 1:\n                return new e(i);\n              case 2:\n                return new e(i, n);\n            }\n            return new e(i, n, r);\n          }\n          return gi(e, this, arguments);\n        };\n        return t.prototype = e.prototype, t;\n      },\n      Oi = function (e, t) {\n        var i,\n          n,\n          r,\n          o,\n          s,\n          a,\n          c,\n          d,\n          l,\n          u = e.target,\n          h = e.global,\n          p = e.stat,\n          _ = e.proto,\n          E = h ? Si : p ? Si[u] : Si[u] && Si[u].prototype,\n          m = h ? yi : yi[u] || Ai(yi, u, {})[u],\n          f = m.prototype;\n        for (o in t) n = !(i = vi(h ? o : u + (p ? \".\" : \"#\") + o, e.forced)) && E && bi(E, o), a = m[o], n && (c = e.dontCallGetSet ? (l = Ci(E, o)) && l.value : E[o]), s = n && c ? c : t[o], (i || _ || typeof a != typeof s) && (d = e.bind && n ? Ii(s, Si) : e.wrap && n ? wi(s) : _ && Ri(s) ? Ti(s) : s, (e.sham || s && s.sham || a && a.sham) && Ai(d, \"sham\", !0), Ai(m, o, d), _ && (bi(yi, r = u + \"Prototype\") || Ai(yi, r, {}), Ai(yi[r], o, s), e.real && f && (i || !f[o]) && Ai(f, o, s)));\n      },\n      Ni = Math.ceil,\n      Di = Math.floor,\n      Pi = Math.trunc || function (e) {\n        var t = +e;\n        return (t > 0 ? Di : Ni)(t);\n      },\n      Li = Pi,\n      ki = function (e) {\n        var t = +e;\n        return t != t || 0 === t ? 0 : Li(t);\n      },\n      Mi = ki,\n      Ui = Math.max,\n      Vi = Math.min,\n      xi = function (e, t) {\n        var i = Mi(e);\n        return i < 0 ? Ui(i + t, 0) : Vi(i, t);\n      },\n      Fi = ki,\n      Bi = Math.min,\n      ji = function (e) {\n        var t = Fi(e);\n        return t > 0 ? Bi(t, 9007199254740991) : 0;\n      },\n      Gi = ji,\n      Wi = function (e) {\n        return Gi(e.length);\n      },\n      Hi = J,\n      Ki = xi,\n      Yi = Wi,\n      zi = function (e) {\n        return function (t, i, n) {\n          var r = Hi(t),\n            o = Yi(r);\n          if (0 === o) return !e && -1;\n          var s,\n            a = Ki(n, o);\n          if (e && i != i) {\n            for (; o > a;) if ((s = r[a++]) != s) return !0;\n          } else for (; o > a; a++) if ((e || a in r) && r[a] === i) return e || a || 0;\n          return !e && -1;\n        };\n      },\n      qi = {\n        includes: zi(!0),\n        indexOf: zi(!1)\n      },\n      Xi = qi.includes;\n    Oi({\n      target: \"Array\",\n      proto: !0,\n      forced: n(function () {\n        return !Array(1).includes();\n      })\n    }, {\n      includes: function (e) {\n        return Xi(this, e, arguments.length > 1 ? arguments[1] : void 0);\n      }\n    });\n    var Ji = h,\n      Qi = $,\n      Zi = function (e, t) {\n        var i = Qi[e + \"Prototype\"],\n          n = i && i[t];\n        if (n) return n;\n        var r = Ji[e],\n          o = r && r.prototype;\n        return o && o[t];\n      },\n      $i = Zi(\"Array\", \"includes\"),\n      en = Z,\n      tn = R,\n      nn = pt(\"match\"),\n      rn = function (e) {\n        var t;\n        return en(e) && (void 0 !== (t = e[nn]) ? !!t : \"RegExp\" === tn(e));\n      },\n      on = rn,\n      sn = TypeError,\n      an = {};\n    an[pt(\"toStringTag\")] = \"z\";\n    var cn = \"[object z]\" === String(an),\n      dn = cn,\n      ln = A,\n      un = R,\n      hn = pt(\"toStringTag\"),\n      pn = Object,\n      _n = \"Arguments\" === un(function () {\n        return arguments;\n      }()),\n      En = dn ? un : function (e) {\n        var t, i, n;\n        return void 0 === e ? \"Undefined\" : null === e ? \"Null\" : \"string\" == typeof (i = function (e, t) {\n          try {\n            return e[t];\n          } catch (e) {}\n        }(t = pn(e), hn)) ? i : _n ? un(t) : \"Object\" === (n = un(t)) && ln(t.callee) ? \"Arguments\" : n;\n      },\n      mn = En,\n      fn = String,\n      Sn = function (e) {\n        if (\"Symbol\" === mn(e)) throw new TypeError(\"Cannot convert a Symbol value to a string\");\n        return fn(e);\n      },\n      gn = pt(\"match\"),\n      Tn = Oi,\n      Rn = function (e) {\n        if (on(e)) throw new sn(\"The method doesn't accept regular expressions\");\n        return e;\n      },\n      Cn = z,\n      vn = Sn,\n      yn = function (e) {\n        var t = /./;\n        try {\n          \"/./\"[e](t);\n        } catch (i) {\n          try {\n            return t[gn] = !1, \"/./\"[e](t);\n          } catch (e) {}\n        }\n        return !1;\n      },\n      In = d(\"\".indexOf);\n    Tn({\n      target: \"String\",\n      proto: !0,\n      forced: !yn(\"includes\")\n    }, {\n      includes: function (e) {\n        return !!~In(vn(Cn(this)), vn(Rn(e)), arguments.length > 1 ? arguments[1] : void 0);\n      }\n    });\n    var An = Zi(\"String\", \"includes\"),\n      bn = l,\n      wn = $i,\n      On = An,\n      Nn = Array.prototype,\n      Dn = String.prototype,\n      Pn = function (e) {\n        var t = e.includes;\n        return e === Nn || bn(Nn, e) && t === Nn.includes ? wn : \"string\" == typeof e || e === Dn || bn(Dn, e) && t === Dn.includes ? On : t;\n      },\n      Ln = i(Pn),\n      kn = Ne,\n      Mn = Je,\n      Un = W,\n      Vn = Wi,\n      xn = TypeError,\n      Fn = \"Reduce of empty array with no initial value\",\n      Bn = function (e) {\n        return function (t, i, n, r) {\n          var o = Mn(t),\n            s = Un(o),\n            a = Vn(o);\n          if (kn(i), 0 === a && n < 2) throw new xn(Fn);\n          var c = e ? a - 1 : 0,\n            d = e ? -1 : 1;\n          if (n < 2) for (;;) {\n            if (c in s) {\n              r = s[c], c += d;\n              break;\n            }\n            if (c += d, e ? c < 0 : a <= c) throw new xn(Fn);\n          }\n          for (; e ? c >= 0 : a > c; c += d) c in s && (r = i(r, s[c], c, o));\n          return r;\n        };\n      },\n      jn = {\n        left: Bn(!1),\n        right: Bn(!0)\n      },\n      Gn = n,\n      Wn = function (e, t) {\n        var i = [][e];\n        return !!i && Gn(function () {\n          i.call(null, t || function () {\n            return 1;\n          }, 1);\n        });\n      },\n      Hn = h,\n      Kn = ae,\n      Yn = R,\n      zn = function (e) {\n        return Kn.slice(0, e.length) === e;\n      },\n      qn = zn(\"Bun/\") ? \"BUN\" : zn(\"Cloudflare-Workers\") ? \"CLOUDFLARE\" : zn(\"Deno/\") ? \"DENO\" : zn(\"Node.js/\") ? \"NODE\" : Hn.Bun && \"string\" == typeof Bun.version ? \"BUN\" : Hn.Deno && \"object\" == typeof Deno.version ? \"DENO\" : \"process\" === Yn(Hn.process) ? \"NODE\" : Hn.window && Hn.document ? \"BROWSER\" : \"REST\",\n      Xn = \"NODE\" === qn,\n      Jn = jn.left;\n    Oi({\n      target: \"Array\",\n      proto: !0,\n      forced: !Xn && _e > 79 && _e < 83 || !Wn(\"reduce\")\n    }, {\n      reduce: function (e) {\n        var t = arguments.length;\n        return Jn(this, e, t, t > 1 ? arguments[1] : void 0);\n      }\n    });\n    var Qn = Zi(\"Array\", \"reduce\"),\n      Zn = l,\n      $n = Qn,\n      er = Array.prototype,\n      tr = function (e) {\n        var t = e.reduce;\n        return e === er || Zn(er, e) && t === er.reduce ? $n : t;\n      },\n      ir = tr,\n      nr = i(ir),\n      rr = R,\n      or = Array.isArray || function (e) {\n        return \"Array\" === rr(e);\n      },\n      sr = Oi,\n      ar = or,\n      cr = d([].reverse),\n      dr = [1, 2];\n    sr({\n      target: \"Array\",\n      proto: !0,\n      forced: String(dr) === String(dr.reverse())\n    }, {\n      reverse: function () {\n        return ar(this) && (this.length = this.length), cr(this);\n      }\n    });\n    var lr = Zi(\"Array\", \"reverse\"),\n      ur = l,\n      hr = lr,\n      pr = Array.prototype,\n      _r = function (e) {\n        var t = e.reverse;\n        return e === pr || ur(pr, e) && t === pr.reverse ? hr : t;\n      },\n      Er = _r,\n      mr = i(Er),\n      fr = rt,\n      Sr = ze(\"keys\"),\n      gr = function (e) {\n        return Sr[e] || (Sr[e] = fr(e));\n      },\n      Tr = !n(function () {\n        function e() {}\n        return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;\n      }),\n      Rr = $e,\n      Cr = A,\n      vr = Je,\n      yr = Tr,\n      Ir = gr(\"IE_PROTO\"),\n      Ar = Object,\n      br = Ar.prototype,\n      wr = yr ? Ar.getPrototypeOf : function (e) {\n        var t = vr(e);\n        if (Rr(t, Ir)) return t[Ir];\n        var i = t.constructor;\n        return Cr(i) && t instanceof i ? i.prototype : t instanceof Ar ? br : null;\n      },\n      Or = d,\n      Nr = Ne,\n      Dr = Z,\n      Pr = function (e) {\n        return Dr(e) || null === e;\n      },\n      Lr = String,\n      kr = TypeError,\n      Mr = function (e, t, i) {\n        try {\n          return Or(Nr(Object.getOwnPropertyDescriptor(e, t)[i]));\n        } catch (e) {}\n      },\n      Ur = Z,\n      Vr = z,\n      xr = function (e) {\n        if (Pr(e)) return e;\n        throw new kr(\"Can't set \" + Lr(e) + \" as a prototype\");\n      },\n      Fr = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n        var e,\n          t = !1,\n          i = {};\n        try {\n          (e = Mr(Object.prototype, \"__proto__\", \"set\"))(i, []), t = i instanceof Array;\n        } catch (e) {}\n        return function (i, n) {\n          return Vr(i), xr(n), Ur(i) ? (t ? e(i, n) : i.__proto__ = n, i) : i;\n        };\n      }() : void 0),\n      Br = {},\n      jr = {},\n      Gr = $e,\n      Wr = J,\n      Hr = qi.indexOf,\n      Kr = jr,\n      Yr = d([].push),\n      zr = function (e, t) {\n        var i,\n          n = Wr(e),\n          r = 0,\n          o = [];\n        for (i in n) !Gr(Kr, i) && Gr(n, i) && Yr(o, i);\n        for (; t.length > r;) Gr(n, i = t[r++]) && (~Hr(o, i) || Yr(o, i));\n        return o;\n      },\n      qr = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n      Xr = zr,\n      Jr = qr.concat(\"length\", \"prototype\");\n    Br.f = Object.getOwnPropertyNames || function (e) {\n      return Xr(e, Jr);\n    };\n    var Qr = {};\n    Qr.f = Object.getOwnPropertySymbols;\n    var Zr = re,\n      $r = Br,\n      eo = Qr,\n      to = ni,\n      io = d([].concat),\n      no = Zr(\"Reflect\", \"ownKeys\") || function (e) {\n        var t = $r.f(to(e)),\n          i = eo.f;\n        return i ? io(t, i(e)) : t;\n      },\n      ro = $e,\n      oo = no,\n      so = b,\n      ao = Zt,\n      co = {},\n      lo = zr,\n      uo = qr,\n      ho = Object.keys || function (e) {\n        return lo(e, uo);\n      },\n      po = w,\n      _o = $t,\n      Eo = Zt,\n      mo = ni,\n      fo = J,\n      So = ho;\n    co.f = po && !_o ? Object.defineProperties : function (e, t) {\n      mo(e);\n      for (var i, n = fo(t), r = So(t), o = r.length, s = 0; o > s;) Eo.f(e, i = r[s++], n[i]);\n      return e;\n    };\n    var go,\n      To = re(\"document\", \"documentElement\"),\n      Ro = ni,\n      Co = co,\n      vo = qr,\n      yo = jr,\n      Io = To,\n      Ao = bt,\n      bo = \"prototype\",\n      wo = \"script\",\n      Oo = gr(\"IE_PROTO\"),\n      No = function () {},\n      Do = function (e) {\n        return \"<\" + wo + \">\" + e + \"</\" + wo + \">\";\n      },\n      Po = function (e) {\n        e.write(Do(\"\")), e.close();\n        var t = e.parentWindow.Object;\n        return e = null, t;\n      },\n      Lo = function () {\n        try {\n          go = new ActiveXObject(\"htmlfile\");\n        } catch (e) {}\n        var e, t, i;\n        Lo = \"undefined\" != typeof document ? document.domain && go ? Po(go) : (t = Ao(\"iframe\"), i = \"java\" + wo + \":\", t.style.display = \"none\", Io.appendChild(t), t.src = String(i), (e = t.contentWindow.document).open(), e.write(Do(\"document.F=Object\")), e.close(), e.F) : Po(go);\n        for (var n = vo.length; n--;) delete Lo[bo][vo[n]];\n        return Lo();\n      };\n    yo[Oo] = !0;\n    var ko = Object.create || function (e, t) {\n        var i;\n        return null !== e ? (No[bo] = Ro(e), i = new No(), No[bo] = null, i[Oo] = e) : i = Lo(), void 0 === t ? i : Co.f(i, t);\n      },\n      Mo = Z,\n      Uo = fi,\n      Vo = Error,\n      xo = d(\"\".replace),\n      Fo = String(new Vo(\"zxcasd\").stack),\n      Bo = /\\n\\s*at [^:]*:[^\\n]*/,\n      jo = Bo.test(Fo),\n      Go = x,\n      Wo = !n(function () {\n        var e = new Error(\"a\");\n        return !(\"stack\" in e) || (Object.defineProperty(e, \"stack\", Go(1, 7)), 7 !== e.stack);\n      }),\n      Ho = fi,\n      Ko = function (e, t) {\n        if (jo && \"string\" == typeof e && !Vo.prepareStackTrace) for (; t--;) e = xo(e, Bo, \"\");\n        return e;\n      },\n      Yo = Wo,\n      zo = Error.captureStackTrace,\n      qo = {},\n      Xo = qo,\n      Jo = pt(\"iterator\"),\n      Qo = Array.prototype,\n      Zo = function (e) {\n        return void 0 !== e && (Xo.Array === e || Qo[Jo] === e);\n      },\n      $o = En,\n      es = Le,\n      ts = H,\n      is = qo,\n      ns = pt(\"iterator\"),\n      rs = function (e) {\n        if (!ts(e)) return es(e, ns) || es(e, \"@@iterator\") || is[$o(e)];\n      },\n      os = D,\n      ss = Ne,\n      as = ni,\n      cs = Ae,\n      ds = rs,\n      ls = TypeError,\n      us = function (e, t) {\n        var i = arguments.length < 2 ? ds(e) : t;\n        if (ss(i)) return as(os(i, e));\n        throw new ls(cs(e) + \" is not iterable\");\n      },\n      hs = D,\n      ps = ni,\n      _s = Le,\n      Es = function (e, t, i) {\n        var n, r;\n        ps(e);\n        try {\n          if (!(n = _s(e, \"return\"))) {\n            if (\"throw\" === t) throw i;\n            return i;\n          }\n          n = hs(n, e);\n        } catch (e) {\n          r = !0, n = e;\n        }\n        if (\"throw\" === t) throw i;\n        if (r) throw n;\n        return ps(n), i;\n      },\n      ms = Qt,\n      fs = D,\n      Ss = ni,\n      gs = Ae,\n      Ts = Zo,\n      Rs = Wi,\n      Cs = l,\n      vs = us,\n      ys = rs,\n      Is = Es,\n      As = TypeError,\n      bs = function (e, t) {\n        this.stopped = e, this.result = t;\n      },\n      ws = bs.prototype,\n      Os = function (e, t, i) {\n        var n,\n          r,\n          o,\n          s,\n          a,\n          c,\n          d,\n          l = i && i.that,\n          u = !(!i || !i.AS_ENTRIES),\n          h = !(!i || !i.IS_RECORD),\n          p = !(!i || !i.IS_ITERATOR),\n          _ = !(!i || !i.INTERRUPTED),\n          E = ms(t, l),\n          m = function (e) {\n            return n && Is(n, \"normal\"), new bs(!0, e);\n          },\n          f = function (e) {\n            return u ? (Ss(e), _ ? E(e[0], e[1], m) : E(e[0], e[1])) : _ ? E(e, m) : E(e);\n          };\n        if (h) n = e.iterator;else if (p) n = e;else {\n          if (!(r = ys(e))) throw new As(gs(e) + \" is not iterable\");\n          if (Ts(r)) {\n            for (o = 0, s = Rs(e); s > o; o++) if ((a = f(e[o])) && Cs(ws, a)) return a;\n            return new bs(!1);\n          }\n          n = vs(e, r);\n        }\n        for (c = h ? e.next : n.next; !(d = fs(c, n)).done;) {\n          try {\n            a = f(d.value);\n          } catch (e) {\n            Is(n, \"throw\", e);\n          }\n          if (\"object\" == typeof a && a && Cs(ws, a)) return a;\n        }\n        return new bs(!1);\n      },\n      Ns = Sn,\n      Ds = Oi,\n      Ps = l,\n      Ls = wr,\n      ks = Fr,\n      Ms = function (e, t, i) {\n        for (var n = oo(t), r = ao.f, o = so.f, s = 0; s < n.length; s++) {\n          var a = n[s];\n          ro(e, a) || i && ro(i, a) || r(e, a, o(t, a));\n        }\n      },\n      Us = ko,\n      Vs = fi,\n      xs = x,\n      Fs = function (e, t) {\n        Mo(t) && \"cause\" in t && Uo(e, \"cause\", t.cause);\n      },\n      Bs = function (e, t, i, n) {\n        Yo && (zo ? zo(e, t) : Ho(e, \"stack\", Ko(i, n)));\n      },\n      js = Os,\n      Gs = function (e, t) {\n        return void 0 === e ? arguments.length < 2 ? \"\" : t : Ns(e);\n      },\n      Ws = pt(\"toStringTag\"),\n      Hs = Error,\n      Ks = [].push,\n      Ys = function (e, t) {\n        var i,\n          n = Ps(zs, this);\n        ks ? i = ks(new Hs(), n ? Ls(this) : zs) : (i = n ? this : Us(zs), Vs(i, Ws, \"Error\")), void 0 !== t && Vs(i, \"message\", Gs(t)), Bs(i, Ys, i.stack, 1), arguments.length > 2 && Fs(i, arguments[2]);\n        var r = [];\n        return js(e, Ks, {\n          that: r\n        }), Vs(i, \"errors\", r), i;\n      };\n    ks ? ks(Ys, Hs) : Ms(Ys, Hs, {\n      name: !0\n    });\n    var zs = Ys.prototype = Us(Hs.prototype, {\n      constructor: xs(1, Ys),\n      message: xs(1, \"\"),\n      name: xs(1, \"AggregateError\")\n    });\n    Ds({\n      global: !0,\n      constructor: !0,\n      arity: 2\n    }, {\n      AggregateError: Ys\n    });\n    var qs,\n      Xs,\n      Js,\n      Qs = A,\n      Zs = h.WeakMap,\n      $s = Qs(Zs) && /native code/.test(String(Zs)),\n      ea = h,\n      ta = Z,\n      ia = fi,\n      na = $e,\n      ra = Ke,\n      oa = gr,\n      sa = jr,\n      aa = \"Object already initialized\",\n      ca = ea.TypeError,\n      da = ea.WeakMap;\n    if ($s || ra.state) {\n      var la = ra.state || (ra.state = new da());\n      la.get = la.get, la.has = la.has, la.set = la.set, qs = function (e, t) {\n        if (la.has(e)) throw new ca(aa);\n        return t.facade = e, la.set(e, t), t;\n      }, Xs = function (e) {\n        return la.get(e) || {};\n      }, Js = function (e) {\n        return la.has(e);\n      };\n    } else {\n      var ua = oa(\"state\");\n      sa[ua] = !0, qs = function (e, t) {\n        if (na(e, ua)) throw new ca(aa);\n        return t.facade = e, ia(e, ua, t), t;\n      }, Xs = function (e) {\n        return na(e, ua) ? e[ua] : {};\n      }, Js = function (e) {\n        return na(e, ua);\n      };\n    }\n    var ha,\n      pa,\n      _a,\n      Ea = {\n        set: qs,\n        get: Xs,\n        has: Js,\n        enforce: function (e) {\n          return Js(e) ? Xs(e) : qs(e, {});\n        },\n        getterFor: function (e) {\n          return function (t) {\n            var i;\n            if (!ta(t) || (i = Xs(t)).type !== e) throw new ca(\"Incompatible receiver, \" + e + \" required\");\n            return i;\n          };\n        }\n      },\n      ma = w,\n      fa = $e,\n      Sa = Function.prototype,\n      ga = ma && Object.getOwnPropertyDescriptor,\n      Ta = fa(Sa, \"name\"),\n      Ra = {\n        EXISTS: Ta,\n        PROPER: Ta && \"something\" === function () {}.name,\n        CONFIGURABLE: Ta && (!ma || ma && ga(Sa, \"name\").configurable)\n      },\n      Ca = fi,\n      va = function (e, t, i, n) {\n        return n && n.enumerable ? e[t] = i : Ca(e, t, i), e;\n      },\n      ya = n,\n      Ia = A,\n      Aa = Z,\n      ba = ko,\n      wa = wr,\n      Oa = va,\n      Na = pt(\"iterator\"),\n      Da = !1;\n    [].keys && (\"next\" in (_a = [].keys()) ? (pa = wa(wa(_a))) !== Object.prototype && (ha = pa) : Da = !0);\n    var Pa = !Aa(ha) || ya(function () {\n      var e = {};\n      return ha[Na].call(e) !== e;\n    });\n    Ia((ha = Pa ? {} : ba(ha))[Na]) || Oa(ha, Na, function () {\n      return this;\n    });\n    var La = {\n        IteratorPrototype: ha,\n        BUGGY_SAFARI_ITERATORS: Da\n      },\n      ka = En,\n      Ma = cn ? {}.toString : function () {\n        return \"[object \" + ka(this) + \"]\";\n      },\n      Ua = cn,\n      Va = Zt.f,\n      xa = fi,\n      Fa = $e,\n      Ba = Ma,\n      ja = pt(\"toStringTag\"),\n      Ga = function (e, t, i, n) {\n        var r = i ? e : e && e.prototype;\n        r && (Fa(r, ja) || Va(r, ja, {\n          configurable: !0,\n          value: t\n        }), n && !Ua && xa(r, \"toString\", Ba));\n      },\n      Wa = La.IteratorPrototype,\n      Ha = ko,\n      Ka = x,\n      Ya = Ga,\n      za = qo,\n      qa = function () {\n        return this;\n      },\n      Xa = function (e, t, i, n) {\n        var r = t + \" Iterator\";\n        return e.prototype = Ha(Wa, {\n          next: Ka(+!n, i)\n        }), Ya(e, r, !1, !0), za[r] = qa, e;\n      },\n      Ja = Oi,\n      Qa = D,\n      Za = Ra,\n      $a = Xa,\n      ec = wr,\n      tc = Ga,\n      ic = va,\n      nc = qo,\n      rc = La,\n      oc = Za.PROPER,\n      sc = rc.BUGGY_SAFARI_ITERATORS,\n      ac = pt(\"iterator\"),\n      cc = \"keys\",\n      dc = \"values\",\n      lc = \"entries\",\n      uc = function () {\n        return this;\n      },\n      hc = function (e, t, i, n, r, o, s) {\n        $a(i, t, n);\n        var a,\n          c,\n          d,\n          l = function (e) {\n            if (e === r && E) return E;\n            if (!sc && e && e in p) return p[e];\n            switch (e) {\n              case cc:\n              case dc:\n              case lc:\n                return function () {\n                  return new i(this, e);\n                };\n            }\n            return function () {\n              return new i(this);\n            };\n          },\n          u = t + \" Iterator\",\n          h = !1,\n          p = e.prototype,\n          _ = p[ac] || p[\"@@iterator\"] || r && p[r],\n          E = !sc && _ || l(r),\n          m = \"Array\" === t && p.entries || _;\n        if (m && (a = ec(m.call(new e()))) !== Object.prototype && a.next && (tc(a, u, !0, !0), nc[u] = uc), oc && r === dc && _ && _.name !== dc && (h = !0, E = function () {\n          return Qa(_, this);\n        }), r) if (c = {\n          values: l(dc),\n          keys: o ? E : l(cc),\n          entries: l(lc)\n        }, s) for (d in c) (sc || h || !(d in p)) && ic(p, d, c[d]);else Ja({\n          target: t,\n          proto: !0,\n          forced: sc || h\n        }, c);\n        return s && p[ac] !== E && ic(p, ac, E, {\n          name: r\n        }), nc[t] = E, c;\n      },\n      pc = function (e, t) {\n        return {\n          value: e,\n          done: t\n        };\n      },\n      _c = J,\n      Ec = qo,\n      mc = Ea;\n    Zt.f;\n    var fc = hc,\n      Sc = pc,\n      gc = \"Array Iterator\",\n      Tc = mc.set,\n      Rc = mc.getterFor(gc);\n    fc(Array, \"Array\", function (e, t) {\n      Tc(this, {\n        type: gc,\n        target: _c(e),\n        index: 0,\n        kind: t\n      });\n    }, function () {\n      var e = Rc(this),\n        t = e.target,\n        i = e.index++;\n      if (!t || i >= t.length) return e.target = null, Sc(void 0, !0);\n      switch (e.kind) {\n        case \"keys\":\n          return Sc(i, !1);\n        case \"values\":\n          return Sc(t[i], !1);\n      }\n      return Sc([i, t[i]], !1);\n    }, \"values\"), Ec.Arguments = Ec.Array;\n    var Cc = Zt,\n      vc = function (e, t, i) {\n        return Cc.f(e, t, i);\n      },\n      yc = re,\n      Ic = vc,\n      Ac = w,\n      bc = pt(\"species\"),\n      wc = l,\n      Oc = TypeError,\n      Nc = function (e, t) {\n        if (wc(t, e)) return e;\n        throw new Oc(\"Incorrect invocation\");\n      },\n      Dc = A,\n      Pc = Ke,\n      Lc = d(Function.toString);\n    Dc(Pc.inspectSource) || (Pc.inspectSource = function (e) {\n      return Lc(e);\n    });\n    var kc = Pc.inspectSource,\n      Mc = d,\n      Uc = n,\n      Vc = A,\n      xc = En,\n      Fc = kc,\n      Bc = function () {},\n      jc = re(\"Reflect\", \"construct\"),\n      Gc = /^\\s*(?:class|function)\\b/,\n      Wc = Mc(Gc.exec),\n      Hc = !Gc.test(Bc),\n      Kc = function (e) {\n        if (!Vc(e)) return !1;\n        try {\n          return jc(Bc, [], e), !0;\n        } catch (e) {\n          return !1;\n        }\n      },\n      Yc = function (e) {\n        if (!Vc(e)) return !1;\n        switch (xc(e)) {\n          case \"AsyncFunction\":\n          case \"GeneratorFunction\":\n          case \"AsyncGeneratorFunction\":\n            return !1;\n        }\n        try {\n          return Hc || !!Wc(Gc, Fc(e));\n        } catch (e) {\n          return !0;\n        }\n      };\n    Yc.sham = !0;\n    var zc,\n      qc,\n      Xc,\n      Jc,\n      Qc = !jc || Uc(function () {\n        var e;\n        return Kc(Kc.call) || !Kc(Object) || !Kc(function () {\n          e = !0;\n        }) || e;\n      }) ? Yc : Kc,\n      Zc = Qc,\n      $c = Ae,\n      ed = TypeError,\n      td = ni,\n      id = function (e) {\n        if (Zc(e)) return e;\n        throw new ed($c(e) + \" is not a constructor\");\n      },\n      nd = H,\n      rd = pt(\"species\"),\n      od = function (e, t) {\n        var i,\n          n = td(e).constructor;\n        return void 0 === n || nd(i = td(n)[rd]) ? t : id(i);\n      },\n      sd = d([].slice),\n      ad = TypeError,\n      cd = function (e, t) {\n        if (e < t) throw new ad(\"Not enough arguments\");\n        return e;\n      },\n      dd = /(?:ipad|iphone|ipod).*applewebkit/i.test(ae),\n      ld = h,\n      ud = f,\n      hd = Qt,\n      pd = A,\n      _d = $e,\n      Ed = n,\n      md = To,\n      fd = sd,\n      Sd = bt,\n      gd = cd,\n      Td = dd,\n      Rd = Xn,\n      Cd = ld.setImmediate,\n      vd = ld.clearImmediate,\n      yd = ld.process,\n      Id = ld.Dispatch,\n      Ad = ld.Function,\n      bd = ld.MessageChannel,\n      wd = ld.String,\n      Od = 0,\n      Nd = {},\n      Dd = \"onreadystatechange\";\n    Ed(function () {\n      zc = ld.location;\n    });\n    var Pd = function (e) {\n        if (_d(Nd, e)) {\n          var t = Nd[e];\n          delete Nd[e], t();\n        }\n      },\n      Ld = function (e) {\n        return function () {\n          Pd(e);\n        };\n      },\n      kd = function (e) {\n        Pd(e.data);\n      },\n      Md = function (e) {\n        ld.postMessage(wd(e), zc.protocol + \"//\" + zc.host);\n      };\n    Cd && vd || (Cd = function (e) {\n      gd(arguments.length, 1);\n      var t = pd(e) ? e : Ad(e),\n        i = fd(arguments, 1);\n      return Nd[++Od] = function () {\n        ud(t, void 0, i);\n      }, qc(Od), Od;\n    }, vd = function (e) {\n      delete Nd[e];\n    }, Rd ? qc = function (e) {\n      yd.nextTick(Ld(e));\n    } : Id && Id.now ? qc = function (e) {\n      Id.now(Ld(e));\n    } : bd && !Td ? (Jc = (Xc = new bd()).port2, Xc.port1.onmessage = kd, qc = hd(Jc.postMessage, Jc)) : ld.addEventListener && pd(ld.postMessage) && !ld.importScripts && zc && \"file:\" !== zc.protocol && !Ed(Md) ? (qc = Md, ld.addEventListener(\"message\", kd, !1)) : qc = Dd in Sd(\"script\") ? function (e) {\n      md.appendChild(Sd(\"script\"))[Dd] = function () {\n        md.removeChild(this), Pd(e);\n      };\n    } : function (e) {\n      setTimeout(Ld(e), 0);\n    });\n    var Ud = {\n        set: Cd,\n        clear: vd\n      },\n      Vd = h,\n      xd = w,\n      Fd = Object.getOwnPropertyDescriptor,\n      Bd = function (e) {\n        if (!xd) return Vd[e];\n        var t = Fd(Vd, e);\n        return t && t.value;\n      },\n      jd = function () {\n        this.head = null, this.tail = null;\n      };\n    jd.prototype = {\n      add: function (e) {\n        var t = {\n            item: e,\n            next: null\n          },\n          i = this.tail;\n        i ? i.next = t : this.head = t, this.tail = t;\n      },\n      get: function () {\n        var e = this.head;\n        if (e) return null === (this.head = e.next) && (this.tail = null), e.item;\n      }\n    };\n    var Gd,\n      Wd,\n      Hd,\n      Kd,\n      Yd,\n      zd = jd,\n      qd = /ipad|iphone|ipod/i.test(ae) && \"undefined\" != typeof Pebble,\n      Xd = /web0s(?!.*chrome)/i.test(ae),\n      Jd = h,\n      Qd = Bd,\n      Zd = Qt,\n      $d = Ud.set,\n      el = zd,\n      tl = dd,\n      il = qd,\n      nl = Xd,\n      rl = Xn,\n      ol = Jd.MutationObserver || Jd.WebKitMutationObserver,\n      sl = Jd.document,\n      al = Jd.process,\n      cl = Jd.Promise,\n      dl = Qd(\"queueMicrotask\");\n    if (!dl) {\n      var ll = new el(),\n        ul = function () {\n          var e, t;\n          for (rl && (e = al.domain) && e.exit(); t = ll.get();) try {\n            t();\n          } catch (e) {\n            throw ll.head && Gd(), e;\n          }\n          e && e.enter();\n        };\n      tl || rl || nl || !ol || !sl ? !il && cl && cl.resolve ? ((Kd = cl.resolve(void 0)).constructor = cl, Yd = Zd(Kd.then, Kd), Gd = function () {\n        Yd(ul);\n      }) : rl ? Gd = function () {\n        al.nextTick(ul);\n      } : ($d = Zd($d, Jd), Gd = function () {\n        $d(ul);\n      }) : (Wd = !0, Hd = sl.createTextNode(\"\"), new ol(ul).observe(Hd, {\n        characterData: !0\n      }), Gd = function () {\n        Hd.data = Wd = !Wd;\n      }), dl = function (e) {\n        ll.head || Gd(), ll.add(e);\n      };\n    }\n    var hl = dl,\n      pl = function (e) {\n        try {\n          return {\n            error: !1,\n            value: e()\n          };\n        } catch (e) {\n          return {\n            error: !0,\n            value: e\n          };\n        }\n      },\n      _l = h.Promise,\n      El = h,\n      ml = _l,\n      fl = A,\n      Sl = zt,\n      gl = kc,\n      Tl = pt,\n      Rl = qn,\n      Cl = _e,\n      vl = ml && ml.prototype,\n      yl = Tl(\"species\"),\n      Il = !1,\n      Al = fl(El.PromiseRejectionEvent),\n      bl = Sl(\"Promise\", function () {\n        var e = gl(ml),\n          t = e !== String(ml);\n        if (!t && 66 === Cl) return !0;\n        if (!vl.catch || !vl.finally) return !0;\n        if (!Cl || Cl < 51 || !/native code/.test(e)) {\n          var i = new ml(function (e) {\n              e(1);\n            }),\n            n = function (e) {\n              e(function () {}, function () {});\n            };\n          if ((i.constructor = {})[yl] = n, !(Il = i.then(function () {}) instanceof n)) return !0;\n        }\n        return !(t || \"BROWSER\" !== Rl && \"DENO\" !== Rl || Al);\n      }),\n      wl = {\n        CONSTRUCTOR: bl,\n        REJECTION_EVENT: Al,\n        SUBCLASSING: Il\n      },\n      Ol = {},\n      Nl = Ne,\n      Dl = TypeError,\n      Pl = function (e) {\n        var t, i;\n        this.promise = new e(function (e, n) {\n          if (void 0 !== t || void 0 !== i) throw new Dl(\"Bad Promise constructor\");\n          t = e, i = n;\n        }), this.resolve = Nl(t), this.reject = Nl(i);\n      };\n    Ol.f = function (e) {\n      return new Pl(e);\n    };\n    var Ll,\n      kl,\n      Ml,\n      Ul = Oi,\n      Vl = Xn,\n      xl = h,\n      Fl = $,\n      Bl = D,\n      jl = va,\n      Gl = Ga,\n      Wl = function (e) {\n        var t = yc(e);\n        Ac && t && !t[bc] && Ic(t, bc, {\n          configurable: !0,\n          get: function () {\n            return this;\n          }\n        });\n      },\n      Hl = Ne,\n      Kl = A,\n      Yl = Z,\n      zl = Nc,\n      ql = od,\n      Xl = Ud.set,\n      Jl = hl,\n      Ql = function (e, t) {\n        try {\n          1 === arguments.length ? console.error(e) : console.error(e, t);\n        } catch (e) {}\n      },\n      Zl = pl,\n      $l = zd,\n      eu = Ea,\n      tu = _l,\n      iu = wl,\n      nu = Ol,\n      ru = \"Promise\",\n      ou = iu.CONSTRUCTOR,\n      su = iu.REJECTION_EVENT,\n      au = eu.getterFor(ru),\n      cu = eu.set,\n      du = tu && tu.prototype,\n      lu = tu,\n      uu = du,\n      hu = xl.TypeError,\n      pu = xl.document,\n      _u = xl.process,\n      Eu = nu.f,\n      mu = Eu,\n      fu = !!(pu && pu.createEvent && xl.dispatchEvent),\n      Su = \"unhandledrejection\",\n      gu = function (e) {\n        var t;\n        return !(!Yl(e) || !Kl(t = e.then)) && t;\n      },\n      Tu = function (e, t) {\n        var i,\n          n,\n          r,\n          o = t.value,\n          s = 1 === t.state,\n          a = s ? e.ok : e.fail,\n          c = e.resolve,\n          d = e.reject,\n          l = e.domain;\n        try {\n          a ? (s || (2 === t.rejection && Iu(t), t.rejection = 1), !0 === a ? i = o : (l && l.enter(), i = a(o), l && (l.exit(), r = !0)), i === e.promise ? d(new hu(\"Promise-chain cycle\")) : (n = gu(i)) ? Bl(n, i, c, d) : c(i)) : d(o);\n        } catch (e) {\n          l && !r && l.exit(), d(e);\n        }\n      },\n      Ru = function (e, t) {\n        e.notified || (e.notified = !0, Jl(function () {\n          for (var i, n = e.reactions; i = n.get();) Tu(i, e);\n          e.notified = !1, t && !e.rejection && vu(e);\n        }));\n      },\n      Cu = function (e, t, i) {\n        var n, r;\n        fu ? ((n = pu.createEvent(\"Event\")).promise = t, n.reason = i, n.initEvent(e, !1, !0), xl.dispatchEvent(n)) : n = {\n          promise: t,\n          reason: i\n        }, !su && (r = xl[\"on\" + e]) ? r(n) : e === Su && Ql(\"Unhandled promise rejection\", i);\n      },\n      vu = function (e) {\n        Bl(Xl, xl, function () {\n          var t,\n            i = e.facade,\n            n = e.value;\n          if (yu(e) && (t = Zl(function () {\n            Vl ? _u.emit(\"unhandledRejection\", n, i) : Cu(Su, i, n);\n          }), e.rejection = Vl || yu(e) ? 2 : 1, t.error)) throw t.value;\n        });\n      },\n      yu = function (e) {\n        return 1 !== e.rejection && !e.parent;\n      },\n      Iu = function (e) {\n        Bl(Xl, xl, function () {\n          var t = e.facade;\n          Vl ? _u.emit(\"rejectionHandled\", t) : Cu(\"rejectionhandled\", t, e.value);\n        });\n      },\n      Au = function (e, t, i) {\n        return function (n) {\n          e(t, n, i);\n        };\n      },\n      bu = function (e, t, i) {\n        e.done || (e.done = !0, i && (e = i), e.value = t, e.state = 2, Ru(e, !0));\n      },\n      wu = function (e, t, i) {\n        if (!e.done) {\n          e.done = !0, i && (e = i);\n          try {\n            if (e.facade === t) throw new hu(\"Promise can't be resolved itself\");\n            var n = gu(t);\n            n ? Jl(function () {\n              var i = {\n                done: !1\n              };\n              try {\n                Bl(n, t, Au(wu, i, e), Au(bu, i, e));\n              } catch (t) {\n                bu(i, t, e);\n              }\n            }) : (e.value = t, e.state = 1, Ru(e, !1));\n          } catch (t) {\n            bu({\n              done: !1\n            }, t, e);\n          }\n        }\n      };\n    ou && (uu = (lu = function (e) {\n      zl(this, uu), Hl(e), Bl(Ll, this);\n      var t = au(this);\n      try {\n        e(Au(wu, t), Au(bu, t));\n      } catch (e) {\n        bu(t, e);\n      }\n    }).prototype, (Ll = function (e) {\n      cu(this, {\n        type: ru,\n        done: !1,\n        notified: !1,\n        parent: !1,\n        reactions: new $l(),\n        rejection: !1,\n        state: 0,\n        value: null\n      });\n    }).prototype = jl(uu, \"then\", function (e, t) {\n      var i = au(this),\n        n = Eu(ql(this, lu));\n      return i.parent = !0, n.ok = !Kl(e) || e, n.fail = Kl(t) && t, n.domain = Vl ? _u.domain : void 0, 0 === i.state ? i.reactions.add(n) : Jl(function () {\n        Tu(n, i);\n      }), n.promise;\n    }), kl = function () {\n      var e = new Ll(),\n        t = au(e);\n      this.promise = e, this.resolve = Au(wu, t), this.reject = Au(bu, t);\n    }, nu.f = Eu = function (e) {\n      return e === lu || e === Ml ? new kl(e) : mu(e);\n    }), Ul({\n      global: !0,\n      constructor: !0,\n      wrap: !0,\n      forced: ou\n    }, {\n      Promise: lu\n    }), Ml = Fl.Promise, Gl(lu, ru, !1, !0), Wl(ru);\n    var Ou = pt(\"iterator\"),\n      Nu = !1;\n    try {\n      var Du = 0,\n        Pu = {\n          next: function () {\n            return {\n              done: !!Du++\n            };\n          },\n          return: function () {\n            Nu = !0;\n          }\n        };\n      Pu[Ou] = function () {\n        return this;\n      }, Array.from(Pu, function () {\n        throw 2;\n      });\n    } catch (e) {}\n    var Lu = _l,\n      ku = function (e, t) {\n        try {\n          if (!t && !Nu) return !1;\n        } catch (e) {\n          return !1;\n        }\n        var i = !1;\n        try {\n          var n = {};\n          n[Ou] = function () {\n            return {\n              next: function () {\n                return {\n                  done: i = !0\n                };\n              }\n            };\n          }, e(n);\n        } catch (e) {}\n        return i;\n      },\n      Mu = wl.CONSTRUCTOR || !ku(function (e) {\n        Lu.all(e).then(void 0, function () {});\n      }),\n      Uu = D,\n      Vu = Ne,\n      xu = Ol,\n      Fu = pl,\n      Bu = Os;\n    Oi({\n      target: \"Promise\",\n      stat: !0,\n      forced: Mu\n    }, {\n      all: function (e) {\n        var t = this,\n          i = xu.f(t),\n          n = i.resolve,\n          r = i.reject,\n          o = Fu(function () {\n            var i = Vu(t.resolve),\n              o = [],\n              s = 0,\n              a = 1;\n            Bu(e, function (e) {\n              var c = s++,\n                d = !1;\n              a++, Uu(i, t, e).then(function (e) {\n                d || (d = !0, o[c] = e, --a || n(o));\n              }, r);\n            }), --a || n(o);\n          });\n        return o.error && r(o.value), i.promise;\n      }\n    });\n    var ju = Oi,\n      Gu = wl.CONSTRUCTOR;\n    _l && _l.prototype, ju({\n      target: \"Promise\",\n      proto: !0,\n      forced: Gu,\n      real: !0\n    }, {\n      catch: function (e) {\n        return this.then(void 0, e);\n      }\n    });\n    var Wu = D,\n      Hu = Ne,\n      Ku = Ol,\n      Yu = pl,\n      zu = Os;\n    Oi({\n      target: \"Promise\",\n      stat: !0,\n      forced: Mu\n    }, {\n      race: function (e) {\n        var t = this,\n          i = Ku.f(t),\n          n = i.reject,\n          r = Yu(function () {\n            var r = Hu(t.resolve);\n            zu(e, function (e) {\n              Wu(r, t, e).then(i.resolve, n);\n            });\n          });\n        return r.error && n(r.value), i.promise;\n      }\n    });\n    var qu = Ol;\n    Oi({\n      target: \"Promise\",\n      stat: !0,\n      forced: wl.CONSTRUCTOR\n    }, {\n      reject: function (e) {\n        var t = qu.f(this);\n        return (0, t.reject)(e), t.promise;\n      }\n    });\n    var Xu = ni,\n      Ju = Z,\n      Qu = Ol,\n      Zu = function (e, t) {\n        if (Xu(e), Ju(t) && t.constructor === e) return t;\n        var i = Qu.f(e);\n        return (0, i.resolve)(t), i.promise;\n      },\n      $u = Oi,\n      eh = _l,\n      th = wl.CONSTRUCTOR,\n      ih = Zu,\n      nh = re(\"Promise\"),\n      rh = !th;\n    $u({\n      target: \"Promise\",\n      stat: !0,\n      forced: true\n    }, {\n      resolve: function (e) {\n        return ih(rh && this === nh ? eh : this, e);\n      }\n    });\n    var oh = D,\n      sh = Ne,\n      ah = Ol,\n      ch = pl,\n      dh = Os;\n    Oi({\n      target: \"Promise\",\n      stat: !0,\n      forced: Mu\n    }, {\n      allSettled: function (e) {\n        var t = this,\n          i = ah.f(t),\n          n = i.resolve,\n          r = i.reject,\n          o = ch(function () {\n            var i = sh(t.resolve),\n              r = [],\n              o = 0,\n              s = 1;\n            dh(e, function (e) {\n              var a = o++,\n                c = !1;\n              s++, oh(i, t, e).then(function (e) {\n                c || (c = !0, r[a] = {\n                  status: \"fulfilled\",\n                  value: e\n                }, --s || n(r));\n              }, function (e) {\n                c || (c = !0, r[a] = {\n                  status: \"rejected\",\n                  reason: e\n                }, --s || n(r));\n              });\n            }), --s || n(r);\n          });\n        return o.error && r(o.value), i.promise;\n      }\n    });\n    var lh = D,\n      uh = Ne,\n      hh = re,\n      ph = Ol,\n      _h = pl,\n      Eh = Os,\n      mh = \"No one promise resolved\";\n    Oi({\n      target: \"Promise\",\n      stat: !0,\n      forced: Mu\n    }, {\n      any: function (e) {\n        var t = this,\n          i = hh(\"AggregateError\"),\n          n = ph.f(t),\n          r = n.resolve,\n          o = n.reject,\n          s = _h(function () {\n            var n = uh(t.resolve),\n              s = [],\n              a = 0,\n              c = 1,\n              d = !1;\n            Eh(e, function (e) {\n              var l = a++,\n                u = !1;\n              c++, lh(n, t, e).then(function (e) {\n                u || d || (d = !0, r(e));\n              }, function (e) {\n                u || d || (u = !0, s[l] = e, --c || o(new i(s, mh)));\n              });\n            }), --c || o(new i(s, mh));\n          });\n        return s.error && o(s.value), n.promise;\n      }\n    });\n    var fh = Oi,\n      Sh = f,\n      gh = sd,\n      Th = Ol,\n      Rh = Ne,\n      Ch = pl,\n      vh = h.Promise,\n      yh = !1;\n    fh({\n      target: \"Promise\",\n      stat: !0,\n      forced: !vh || !vh.try || Ch(function () {\n        vh.try(function (e) {\n          yh = 8 === e;\n        }, 8);\n      }).error || !yh\n    }, {\n      try: function (e) {\n        var t = arguments.length > 1 ? gh(arguments, 1) : [],\n          i = Th.f(this),\n          n = Ch(function () {\n            return Sh(Rh(e), void 0, t);\n          });\n        return (n.error ? i.reject : i.resolve)(n.value), i.promise;\n      }\n    });\n    var Ih = Ol;\n    Oi({\n      target: \"Promise\",\n      stat: !0\n    }, {\n      withResolvers: function () {\n        var e = Ih.f(this);\n        return {\n          promise: e.promise,\n          resolve: e.resolve,\n          reject: e.reject\n        };\n      }\n    });\n    var Ah = Oi,\n      bh = _l,\n      wh = n,\n      Oh = re,\n      Nh = A,\n      Dh = od,\n      Ph = Zu,\n      Lh = bh && bh.prototype;\n    Ah({\n      target: \"Promise\",\n      proto: !0,\n      real: !0,\n      forced: !!bh && wh(function () {\n        Lh.finally.call({\n          then: function () {}\n        }, function () {});\n      })\n    }, {\n      finally: function (e) {\n        var t = Dh(this, Oh(\"Promise\")),\n          i = Nh(e);\n        return this.then(i ? function (i) {\n          return Ph(t, e()).then(function () {\n            return i;\n          });\n        } : e, i ? function (i) {\n          return Ph(t, e()).then(function () {\n            throw i;\n          });\n        } : e);\n      }\n    });\n    var kh = d,\n      Mh = ki,\n      Uh = Sn,\n      Vh = z,\n      xh = kh(\"\".charAt),\n      Fh = kh(\"\".charCodeAt),\n      Bh = kh(\"\".slice),\n      jh = function (e) {\n        return function (t, i) {\n          var n,\n            r,\n            o = Uh(Vh(t)),\n            s = Mh(i),\n            a = o.length;\n          return s < 0 || s >= a ? e ? \"\" : void 0 : (n = Fh(o, s)) < 55296 || n > 56319 || s + 1 === a || (r = Fh(o, s + 1)) < 56320 || r > 57343 ? e ? xh(o, s) : n : e ? Bh(o, s, s + 2) : r - 56320 + (n - 55296 << 10) + 65536;\n        };\n      },\n      Gh = {\n        codeAt: jh(!1),\n        charAt: jh(!0)\n      },\n      Wh = Gh.charAt,\n      Hh = Sn,\n      Kh = Ea,\n      Yh = hc,\n      zh = pc,\n      qh = \"String Iterator\",\n      Xh = Kh.set,\n      Jh = Kh.getterFor(qh);\n    Yh(String, \"String\", function (e) {\n      Xh(this, {\n        type: qh,\n        string: Hh(e),\n        index: 0\n      });\n    }, function () {\n      var e,\n        t = Jh(this),\n        i = t.string,\n        n = t.index;\n      return n >= i.length ? zh(void 0, !0) : (e = Wh(i, n), t.index += e.length, zh(e, !1));\n    });\n    var Qh = $.Promise,\n      Zh = {\n        CSSRuleList: 0,\n        CSSStyleDeclaration: 0,\n        CSSValueList: 0,\n        ClientRectList: 0,\n        DOMRectList: 0,\n        DOMStringList: 0,\n        DOMTokenList: 1,\n        DataTransferItemList: 0,\n        FileList: 0,\n        HTMLAllCollection: 0,\n        HTMLCollection: 0,\n        HTMLFormElement: 0,\n        HTMLSelectElement: 0,\n        MediaList: 0,\n        MimeTypeArray: 0,\n        NamedNodeMap: 0,\n        NodeList: 1,\n        PaintRequestList: 0,\n        Plugin: 0,\n        PluginArray: 0,\n        SVGLengthList: 0,\n        SVGNumberList: 0,\n        SVGPathSegList: 0,\n        SVGPointList: 0,\n        SVGStringList: 0,\n        SVGTransformList: 0,\n        SourceBufferList: 0,\n        StyleSheetList: 0,\n        TextTrackCueList: 0,\n        TextTrackList: 0,\n        TouchList: 0\n      },\n      $h = h,\n      ep = Ga,\n      tp = qo;\n    for (var ip in Zh) ep($h[ip], ip), tp[ip] = tp.Array;\n    var np = Qh,\n      rp = i(np),\n      op = Zi(\"Array\", \"values\"),\n      sp = En,\n      ap = $e,\n      cp = l,\n      dp = op,\n      lp = Array.prototype,\n      up = {\n        DOMTokenList: !0,\n        NodeList: !0\n      },\n      hp = function (e) {\n        var t = e.values;\n        return e === lp || cp(lp, e) && t === lp.values || ap(up, sp(e)) ? dp : t;\n      },\n      pp = i(hp),\n      _p = Ae,\n      Ep = TypeError,\n      mp = sd,\n      fp = Math.floor,\n      Sp = function (e, t) {\n        var i = e.length;\n        if (i < 8) for (var n, r, o = 1; o < i;) {\n          for (r = o, n = e[o]; r && t(e[r - 1], n) > 0;) e[r] = e[--r];\n          r !== o++ && (e[r] = n);\n        } else for (var s = fp(i / 2), a = Sp(mp(e, 0, s), t), c = Sp(mp(e, s), t), d = a.length, l = c.length, u = 0, h = 0; u < d || h < l;) e[u + h] = u < d && h < l ? t(a[u], c[h]) <= 0 ? a[u++] : c[h++] : u < d ? a[u++] : c[h++];\n        return e;\n      },\n      gp = Sp,\n      Tp = ae.match(/firefox\\/(\\d+)/i),\n      Rp = !!Tp && +Tp[1],\n      Cp = /MSIE|Trident/.test(ae),\n      vp = ae.match(/AppleWebKit\\/(\\d+)\\./),\n      yp = !!vp && +vp[1],\n      Ip = Oi,\n      Ap = d,\n      bp = Ne,\n      wp = Je,\n      Op = Wi,\n      Np = function (e, t) {\n        if (!delete e[t]) throw new Ep(\"Cannot delete property \" + _p(t) + \" of \" + _p(e));\n      },\n      Dp = Sn,\n      Pp = n,\n      Lp = gp,\n      kp = Wn,\n      Mp = Rp,\n      Up = Cp,\n      Vp = _e,\n      xp = yp,\n      Fp = [],\n      Bp = Ap(Fp.sort),\n      jp = Ap(Fp.push),\n      Gp = Pp(function () {\n        Fp.sort(void 0);\n      }),\n      Wp = Pp(function () {\n        Fp.sort(null);\n      }),\n      Hp = kp(\"sort\"),\n      Kp = !Pp(function () {\n        if (Vp) return Vp < 70;\n        if (!(Mp && Mp > 3)) {\n          if (Up) return !0;\n          if (xp) return xp < 603;\n          var e,\n            t,\n            i,\n            n,\n            r = \"\";\n          for (e = 65; e < 76; e++) {\n            switch (t = String.fromCharCode(e), e) {\n              case 66:\n              case 69:\n              case 70:\n              case 72:\n                i = 3;\n                break;\n              case 68:\n              case 71:\n                i = 4;\n                break;\n              default:\n                i = 2;\n            }\n            for (n = 0; n < 47; n++) Fp.push({\n              k: t + n,\n              v: i\n            });\n          }\n          for (Fp.sort(function (e, t) {\n            return t.v - e.v;\n          }), n = 0; n < Fp.length; n++) t = Fp[n].k.charAt(0), r.charAt(r.length - 1) !== t && (r += t);\n          return \"DGBEFHACIJK\" !== r;\n        }\n      });\n    Ip({\n      target: \"Array\",\n      proto: !0,\n      forced: Gp || !Wp || !Hp || !Kp\n    }, {\n      sort: function (e) {\n        void 0 !== e && bp(e);\n        var t = wp(this);\n        if (Kp) return void 0 === e ? Bp(t) : Bp(t, e);\n        var i,\n          n,\n          r = [],\n          o = Op(t);\n        for (n = 0; n < o; n++) n in t && jp(r, t[n]);\n        for (Lp(r, function (e) {\n          return function (t, i) {\n            return void 0 === i ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, i) || 0 : Dp(t) > Dp(i) ? 1 : -1;\n          };\n        }(e)), i = Op(r), n = 0; n < i;) t[n] = r[n++];\n        for (; n < o;) Np(t, n++);\n        return t;\n      }\n    });\n    var Yp = Zi(\"Array\", \"sort\"),\n      zp = l,\n      qp = Yp,\n      Xp = Array.prototype,\n      Jp = function (e) {\n        var t = e.sort;\n        return e === Xp || zp(Xp, e) && t === Xp.sort ? qp : t;\n      },\n      Qp = i(Jp),\n      Zp = Oi,\n      $p = d,\n      e_ = xi,\n      t_ = RangeError,\n      i_ = String.fromCharCode,\n      n_ = String.fromCodePoint,\n      r_ = $p([].join);\n    Zp({\n      target: \"String\",\n      stat: !0,\n      arity: 1,\n      forced: !!n_ && 1 !== n_.length\n    }, {\n      fromCodePoint: function (e) {\n        for (var t, i = [], n = arguments.length, r = 0; n > r;) {\n          if (t = +arguments[r++], e_(t, 1114111) !== t) throw new t_(t + \" is not a valid code point\");\n          i[r] = t < 65536 ? i_(t) : i_(55296 + ((t -= 65536) >> 10), t % 1024 + 56320);\n        }\n        return r_(i, \"\");\n      }\n    });\n    var o_ = n,\n      s_ = pt(\"iterator\"),\n      a_ = !o_(function () {\n        var e = new URL(\"b?a=1&b=2&c=3\", \"https://a\"),\n          t = e.searchParams,\n          i = new URLSearchParams(\"a=1&a=2&b=3\"),\n          n = \"\";\n        return e.pathname = \"c%20d\", t.forEach(function (e, i) {\n          t.delete(\"b\"), n += i + e;\n        }), i.delete(\"a\", 2), i.delete(\"b\", void 0), !e.toJSON || !i.has(\"a\", 1) || i.has(\"a\", 2) || !i.has(\"a\", void 0) || i.has(\"b\") || !t.size && true || !t.sort || \"https://a/c%20d?a=1&c=3\" !== e.href || \"3\" !== t.get(\"c\") || \"a=1\" !== String(new URLSearchParams(\"?a=1\")) || !t[s_] || \"a\" !== new URL(\"https://a@b\").username || \"b\" !== new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") || \"xn--e1aybc\" !== new URL(\"https://ÑÐµÑÑ\").host || \"#%D0%B1\" !== new URL(\"https://a#Ð±\").hash || \"a1c3\" !== n || \"x\" !== new URL(\"https://x\", void 0).host;\n      }),\n      c_ = va,\n      d_ = Oi,\n      l_ = h,\n      u_ = Bd,\n      h_ = re,\n      p_ = D,\n      __ = d,\n      E_ = w,\n      m_ = a_,\n      f_ = va,\n      S_ = vc,\n      g_ = function (e, t, i) {\n        for (var n in t) i && i.unsafe && e[n] ? e[n] = t[n] : c_(e, n, t[n], i);\n        return e;\n      },\n      T_ = Ga,\n      R_ = Xa,\n      C_ = Ea,\n      v_ = Nc,\n      y_ = A,\n      I_ = $e,\n      A_ = Qt,\n      b_ = En,\n      w_ = ni,\n      O_ = Z,\n      N_ = Sn,\n      D_ = ko,\n      P_ = x,\n      L_ = us,\n      k_ = rs,\n      M_ = pc,\n      U_ = cd,\n      V_ = gp,\n      x_ = pt(\"iterator\"),\n      F_ = \"URLSearchParams\",\n      B_ = F_ + \"Iterator\",\n      j_ = C_.set,\n      G_ = C_.getterFor(F_),\n      W_ = C_.getterFor(B_),\n      H_ = u_(\"fetch\"),\n      K_ = u_(\"Request\"),\n      Y_ = u_(\"Headers\"),\n      z_ = K_ && K_.prototype,\n      q_ = Y_ && Y_.prototype,\n      X_ = l_.TypeError,\n      J_ = l_.encodeURIComponent,\n      Q_ = String.fromCharCode,\n      Z_ = h_(\"String\", \"fromCodePoint\"),\n      $_ = parseInt,\n      eE = __(\"\".charAt),\n      tE = __([].join),\n      iE = __([].push),\n      nE = __(\"\".replace),\n      rE = __([].shift),\n      oE = __([].splice),\n      sE = __(\"\".split),\n      aE = __(\"\".slice),\n      cE = __(/./.exec),\n      dE = /\\+/g,\n      lE = /^[0-9a-f]+$/i,\n      uE = function (e, t) {\n        var i = aE(e, t, t + 2);\n        return cE(lE, i) ? $_(i, 16) : NaN;\n      },\n      hE = function (e) {\n        for (var t = 0, i = 128; i > 0 && 0 != (e & i); i >>= 1) t++;\n        return t;\n      },\n      pE = function (e) {\n        var t = null;\n        switch (e.length) {\n          case 1:\n            t = e[0];\n            break;\n          case 2:\n            t = (31 & e[0]) << 6 | 63 & e[1];\n            break;\n          case 3:\n            t = (15 & e[0]) << 12 | (63 & e[1]) << 6 | 63 & e[2];\n            break;\n          case 4:\n            t = (7 & e[0]) << 18 | (63 & e[1]) << 12 | (63 & e[2]) << 6 | 63 & e[3];\n        }\n        return t > 1114111 ? null : t;\n      },\n      _E = function (e) {\n        for (var t = (e = nE(e, dE, \" \")).length, i = \"\", n = 0; n < t;) {\n          var r = eE(e, n);\n          if (\"%\" === r) {\n            if (\"%\" === eE(e, n + 1) || n + 3 > t) {\n              i += \"%\", n++;\n              continue;\n            }\n            var o = uE(e, n + 1);\n            if (o != o) {\n              i += r, n++;\n              continue;\n            }\n            n += 2;\n            var s = hE(o);\n            if (0 === s) r = Q_(o);else {\n              if (1 === s || s > 4) {\n                i += \"ï¿½\", n++;\n                continue;\n              }\n              for (var a = [o], c = 1; c < s && !(++n + 3 > t || \"%\" !== eE(e, n));) {\n                var d = uE(e, n + 1);\n                if (d != d) {\n                  n += 3;\n                  break;\n                }\n                if (d > 191 || d < 128) break;\n                iE(a, d), n += 2, c++;\n              }\n              if (a.length !== s) {\n                i += \"ï¿½\";\n                continue;\n              }\n              var l = pE(a);\n              null === l ? i += \"ï¿½\" : r = Z_(l);\n            }\n          }\n          i += r, n++;\n        }\n        return i;\n      },\n      EE = /[!'()~]|%20/g,\n      mE = {\n        \"!\": \"%21\",\n        \"'\": \"%27\",\n        \"(\": \"%28\",\n        \")\": \"%29\",\n        \"~\": \"%7E\",\n        \"%20\": \"+\"\n      },\n      fE = function (e) {\n        return mE[e];\n      },\n      SE = function (e) {\n        return nE(J_(e), EE, fE);\n      },\n      gE = R_(function (e, t) {\n        j_(this, {\n          type: B_,\n          target: G_(e).entries,\n          index: 0,\n          kind: t\n        });\n      }, F_, function () {\n        var e = W_(this),\n          t = e.target,\n          i = e.index++;\n        if (!t || i >= t.length) return e.target = null, M_(void 0, !0);\n        var n = t[i];\n        switch (e.kind) {\n          case \"keys\":\n            return M_(n.key, !1);\n          case \"values\":\n            return M_(n.value, !1);\n        }\n        return M_([n.key, n.value], !1);\n      }, !0),\n      TE = function (e) {\n        this.entries = [], this.url = null, void 0 !== e && (O_(e) ? this.parseObject(e) : this.parseQuery(\"string\" == typeof e ? \"?\" === eE(e, 0) ? aE(e, 1) : e : N_(e)));\n      };\n    TE.prototype = {\n      type: F_,\n      bindURL: function (e) {\n        this.url = e, this.update();\n      },\n      parseObject: function (e) {\n        var t,\n          i,\n          n,\n          r,\n          o,\n          s,\n          a,\n          c = this.entries,\n          d = k_(e);\n        if (d) for (i = (t = L_(e, d)).next; !(n = p_(i, t)).done;) {\n          if (o = (r = L_(w_(n.value))).next, (s = p_(o, r)).done || (a = p_(o, r)).done || !p_(o, r).done) throw new X_(\"Expected sequence with length 2\");\n          iE(c, {\n            key: N_(s.value),\n            value: N_(a.value)\n          });\n        } else for (var l in e) I_(e, l) && iE(c, {\n          key: l,\n          value: N_(e[l])\n        });\n      },\n      parseQuery: function (e) {\n        if (e) for (var t, i, n = this.entries, r = sE(e, \"&\"), o = 0; o < r.length;) (t = r[o++]).length && (i = sE(t, \"=\"), iE(n, {\n          key: _E(rE(i)),\n          value: _E(tE(i, \"=\"))\n        }));\n      },\n      serialize: function () {\n        for (var e, t = this.entries, i = [], n = 0; n < t.length;) e = t[n++], iE(i, SE(e.key) + \"=\" + SE(e.value));\n        return tE(i, \"&\");\n      },\n      update: function () {\n        this.entries.length = 0, this.parseQuery(this.url.query);\n      },\n      updateURL: function () {\n        this.url && this.url.update();\n      }\n    };\n    var RE = function () {\n        v_(this, CE);\n        var e = j_(this, new TE(arguments.length > 0 ? arguments[0] : void 0));\n        E_ || (this.size = e.entries.length);\n      },\n      CE = RE.prototype;\n    if (g_(CE, {\n      append: function (e, t) {\n        var i = G_(this);\n        U_(arguments.length, 2), iE(i.entries, {\n          key: N_(e),\n          value: N_(t)\n        }), E_ || this.length++, i.updateURL();\n      },\n      delete: function (e) {\n        for (var t = G_(this), i = U_(arguments.length, 1), n = t.entries, r = N_(e), o = i < 2 ? void 0 : arguments[1], s = void 0 === o ? o : N_(o), a = 0; a < n.length;) {\n          var c = n[a];\n          if (c.key !== r || void 0 !== s && c.value !== s) a++;else if (oE(n, a, 1), void 0 !== s) break;\n        }\n        E_ || (this.size = n.length), t.updateURL();\n      },\n      get: function (e) {\n        var t = G_(this).entries;\n        U_(arguments.length, 1);\n        for (var i = N_(e), n = 0; n < t.length; n++) if (t[n].key === i) return t[n].value;\n        return null;\n      },\n      getAll: function (e) {\n        var t = G_(this).entries;\n        U_(arguments.length, 1);\n        for (var i = N_(e), n = [], r = 0; r < t.length; r++) t[r].key === i && iE(n, t[r].value);\n        return n;\n      },\n      has: function (e) {\n        for (var t = G_(this).entries, i = U_(arguments.length, 1), n = N_(e), r = i < 2 ? void 0 : arguments[1], o = void 0 === r ? r : N_(r), s = 0; s < t.length;) {\n          var a = t[s++];\n          if (a.key === n && (void 0 === o || a.value === o)) return !0;\n        }\n        return !1;\n      },\n      set: function (e, t) {\n        var i = G_(this);\n        U_(arguments.length, 1);\n        for (var n, r = i.entries, o = !1, s = N_(e), a = N_(t), c = 0; c < r.length; c++) (n = r[c]).key === s && (o ? oE(r, c--, 1) : (o = !0, n.value = a));\n        o || iE(r, {\n          key: s,\n          value: a\n        }), E_ || (this.size = r.length), i.updateURL();\n      },\n      sort: function () {\n        var e = G_(this);\n        V_(e.entries, function (e, t) {\n          return e.key > t.key ? 1 : -1;\n        }), e.updateURL();\n      },\n      forEach: function (e) {\n        for (var t, i = G_(this).entries, n = A_(e, arguments.length > 1 ? arguments[1] : void 0), r = 0; r < i.length;) n((t = i[r++]).value, t.key, this);\n      },\n      keys: function () {\n        return new gE(this, \"keys\");\n      },\n      values: function () {\n        return new gE(this, \"values\");\n      },\n      entries: function () {\n        return new gE(this, \"entries\");\n      }\n    }, {\n      enumerable: !0\n    }), f_(CE, x_, CE.entries, {\n      name: \"entries\"\n    }), f_(CE, \"toString\", function () {\n      return G_(this).serialize();\n    }, {\n      enumerable: !0\n    }), E_ && S_(CE, \"size\", {\n      get: function () {\n        return G_(this).entries.length;\n      },\n      configurable: !0,\n      enumerable: !0\n    }), T_(RE, F_), d_({\n      global: !0,\n      constructor: !0,\n      forced: !m_\n    }, {\n      URLSearchParams: RE\n    }), !m_ && y_(Y_)) {\n      var vE = __(q_.has),\n        yE = __(q_.set),\n        IE = function (e) {\n          if (O_(e)) {\n            var t,\n              i = e.body;\n            if (b_(i) === F_) return t = e.headers ? new Y_(e.headers) : new Y_(), vE(t, \"content-type\") || yE(t, \"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"), D_(e, {\n              body: P_(0, N_(i)),\n              headers: P_(0, t)\n            });\n          }\n          return e;\n        };\n      if (y_(H_) && d_({\n        global: !0,\n        enumerable: !0,\n        dontCallGetSet: !0,\n        forced: !0\n      }, {\n        fetch: function (e) {\n          return H_(e, arguments.length > 1 ? IE(arguments[1]) : {});\n        }\n      }), y_(K_)) {\n        var AE = function (e) {\n          return v_(this, z_), new K_(e, arguments.length > 1 ? IE(arguments[1]) : {});\n        };\n        z_.constructor = AE, AE.prototype = z_, d_({\n          global: !0,\n          constructor: !0,\n          dontCallGetSet: !0,\n          forced: !0\n        }, {\n          Request: AE\n        });\n      }\n    }\n    var bE,\n      wE = {\n        URLSearchParams: RE,\n        getState: G_\n      },\n      OE = $.URLSearchParams,\n      NE = w,\n      DE = d,\n      PE = D,\n      LE = n,\n      kE = ho,\n      ME = Qr,\n      UE = P,\n      VE = Je,\n      xE = W,\n      FE = Object.assign,\n      BE = Object.defineProperty,\n      jE = DE([].concat),\n      GE = !FE || LE(function () {\n        if (NE && 1 !== FE({\n          b: 1\n        }, FE(BE({}, \"a\", {\n          enumerable: !0,\n          get: function () {\n            BE(this, \"b\", {\n              value: 3,\n              enumerable: !1\n            });\n          }\n        }), {\n          b: 2\n        })).b) return !0;\n        var e = {},\n          t = {},\n          i = Symbol(\"assign detection\"),\n          n = \"abcdefghijklmnopqrst\";\n        return e[i] = 7, n.split(\"\").forEach(function (e) {\n          t[e] = e;\n        }), 7 !== FE({}, e)[i] || kE(FE({}, t)).join(\"\") !== n;\n      }) ? function (e, t) {\n        for (var i = VE(e), n = arguments.length, r = 1, o = ME.f, s = UE.f; n > r;) for (var a, c = xE(arguments[r++]), d = o ? jE(kE(c), o(c)) : kE(c), l = d.length, u = 0; l > u;) a = d[u++], NE && !PE(s, c, a) || (i[a] = c[a]);\n        return i;\n      } : FE,\n      WE = ni,\n      HE = Es,\n      KE = w,\n      YE = Zt,\n      zE = x,\n      qE = function (e, t, i) {\n        KE ? YE.f(e, t, zE(0, i)) : e[t] = i;\n      },\n      XE = Qt,\n      JE = D,\n      QE = Je,\n      ZE = function (e, t, i, n) {\n        try {\n          return n ? t(WE(i)[0], i[1]) : t(i);\n        } catch (t) {\n          HE(e, \"throw\", t);\n        }\n      },\n      $E = Zo,\n      em = Qc,\n      tm = Wi,\n      im = qE,\n      nm = us,\n      rm = rs,\n      om = Array,\n      sm = d,\n      am = 2147483647,\n      cm = /[^\\0-\\u007E]/,\n      dm = /[.\\u3002\\uFF0E\\uFF61]/g,\n      lm = \"Overflow: input needs wider integers to process\",\n      um = RangeError,\n      hm = sm(dm.exec),\n      pm = Math.floor,\n      _m = String.fromCharCode,\n      Em = sm(\"\".charCodeAt),\n      mm = sm([].join),\n      fm = sm([].push),\n      Sm = sm(\"\".replace),\n      gm = sm(\"\".split),\n      Tm = sm(\"\".toLowerCase),\n      Rm = function (e) {\n        return e + 22 + 75 * (e < 26);\n      },\n      Cm = function (e, t, i) {\n        var n = 0;\n        for (e = i ? pm(e / 700) : e >> 1, e += pm(e / t); e > 455;) e = pm(e / 35), n += 36;\n        return pm(n + 36 * e / (e + 38));\n      },\n      vm = function (e) {\n        var t = [];\n        e = function (e) {\n          for (var t = [], i = 0, n = e.length; i < n;) {\n            var r = Em(e, i++);\n            if (r >= 55296 && r <= 56319 && i < n) {\n              var o = Em(e, i++);\n              56320 == (64512 & o) ? fm(t, ((1023 & r) << 10) + (1023 & o) + 65536) : (fm(t, r), i--);\n            } else fm(t, r);\n          }\n          return t;\n        }(e);\n        var i,\n          n,\n          r = e.length,\n          o = 128,\n          s = 0,\n          a = 72;\n        for (i = 0; i < e.length; i++) (n = e[i]) < 128 && fm(t, _m(n));\n        var c = t.length,\n          d = c;\n        for (c && fm(t, \"-\"); d < r;) {\n          var l = am;\n          for (i = 0; i < e.length; i++) (n = e[i]) >= o && n < l && (l = n);\n          var u = d + 1;\n          if (l - o > pm((am - s) / u)) throw new um(lm);\n          for (s += (l - o) * u, o = l, i = 0; i < e.length; i++) {\n            if ((n = e[i]) < o && ++s > am) throw new um(lm);\n            if (n === o) {\n              for (var h = s, p = 36;;) {\n                var _ = p <= a ? 1 : p >= a + 26 ? 26 : p - a;\n                if (h < _) break;\n                var E = h - _,\n                  m = 36 - _;\n                fm(t, _m(Rm(_ + E % m))), h = pm(E / m), p += 36;\n              }\n              fm(t, _m(Rm(h))), a = Cm(s, u, d === c), s = 0, d++;\n            }\n          }\n          s++, o++;\n        }\n        return mm(t, \"\");\n      },\n      ym = Oi,\n      Im = w,\n      Am = a_,\n      bm = h,\n      wm = Qt,\n      Om = d,\n      Nm = va,\n      Dm = vc,\n      Pm = Nc,\n      Lm = $e,\n      km = GE,\n      Mm = function (e) {\n        var t = QE(e),\n          i = em(this),\n          n = arguments.length,\n          r = n > 1 ? arguments[1] : void 0,\n          o = void 0 !== r;\n        o && (r = XE(r, n > 2 ? arguments[2] : void 0));\n        var s,\n          a,\n          c,\n          d,\n          l,\n          u,\n          h = rm(t),\n          p = 0;\n        if (!h || this === om && $E(h)) for (s = tm(t), a = i ? new this(s) : om(s); s > p; p++) u = o ? r(t[p], p) : t[p], im(a, p, u);else for (a = i ? new this() : [], l = (d = nm(t, h)).next; !(c = JE(l, d)).done; p++) u = o ? ZE(d, r, [c.value, p], !0) : c.value, im(a, p, u);\n        return a.length = p, a;\n      },\n      Um = sd,\n      Vm = Gh.codeAt,\n      xm = function (e) {\n        var t,\n          i,\n          n = [],\n          r = gm(Sm(Tm(e), dm, \".\"), \".\");\n        for (t = 0; t < r.length; t++) i = r[t], fm(n, hm(cm, i) ? \"xn--\" + vm(i) : i);\n        return mm(n, \".\");\n      },\n      Fm = Sn,\n      Bm = Ga,\n      jm = cd,\n      Gm = wE,\n      Wm = Ea,\n      Hm = Wm.set,\n      Km = Wm.getterFor(\"URL\"),\n      Ym = Gm.URLSearchParams,\n      zm = Gm.getState,\n      qm = bm.URL,\n      Xm = bm.TypeError,\n      Jm = bm.parseInt,\n      Qm = Math.floor,\n      Zm = Math.pow,\n      $m = Om(\"\".charAt),\n      ef = Om(/./.exec),\n      tf = Om([].join),\n      nf = Om(1.1.toString),\n      rf = Om([].pop),\n      of = Om([].push),\n      sf = Om(\"\".replace),\n      af = Om([].shift),\n      cf = Om(\"\".split),\n      df = Om(\"\".slice),\n      lf = Om(\"\".toLowerCase),\n      uf = Om([].unshift),\n      hf = \"Invalid scheme\",\n      pf = \"Invalid host\",\n      _f = \"Invalid port\",\n      Ef = /[a-z]/i,\n      mf = /[\\d+-.a-z]/i,\n      ff = /\\d/,\n      Sf = /^0x/i,\n      gf = /^[0-7]+$/,\n      Tf = /^\\d+$/,\n      Rf = /^[\\da-f]+$/i,\n      Cf = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/,\n      vf = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/,\n      yf = /^[\\u0000-\\u0020]+/,\n      If = /(^|[^\\u0000-\\u0020])[\\u0000-\\u0020]+$/,\n      Af = /[\\t\\n\\r]/g,\n      bf = function (e) {\n        var t, i, n, r;\n        if (\"number\" == typeof e) {\n          for (t = [], i = 0; i < 4; i++) uf(t, e % 256), e = Qm(e / 256);\n          return tf(t, \".\");\n        }\n        if (\"object\" == typeof e) {\n          for (t = \"\", n = function (e) {\n            for (var t = null, i = 1, n = null, r = 0, o = 0; o < 8; o++) 0 !== e[o] ? (r > i && (t = n, i = r), n = null, r = 0) : (null === n && (n = o), ++r);\n            return r > i ? n : t;\n          }(e), i = 0; i < 8; i++) r && 0 === e[i] || (r && (r = !1), n === i ? (t += i ? \":\" : \"::\", r = !0) : (t += nf(e[i], 16), i < 7 && (t += \":\")));\n          return \"[\" + t + \"]\";\n        }\n        return e;\n      },\n      wf = {},\n      Of = km({}, wf, {\n        \" \": 1,\n        '\"': 1,\n        \"<\": 1,\n        \">\": 1,\n        \"`\": 1\n      }),\n      Nf = km({}, Of, {\n        \"#\": 1,\n        \"?\": 1,\n        \"{\": 1,\n        \"}\": 1\n      }),\n      Df = km({}, Nf, {\n        \"/\": 1,\n        \":\": 1,\n        \";\": 1,\n        \"=\": 1,\n        \"@\": 1,\n        \"[\": 1,\n        \"\\\\\": 1,\n        \"]\": 1,\n        \"^\": 1,\n        \"|\": 1\n      }),\n      Pf = function (e, t) {\n        var i = Vm(e, 0);\n        return i > 32 && i < 127 && !Lm(t, e) ? e : encodeURIComponent(e);\n      },\n      Lf = {\n        ftp: 21,\n        file: null,\n        http: 80,\n        https: 443,\n        ws: 80,\n        wss: 443\n      },\n      kf = function (e, t) {\n        var i;\n        return 2 === e.length && ef(Ef, $m(e, 0)) && (\":\" === (i = $m(e, 1)) || !t && \"|\" === i);\n      },\n      Mf = function (e) {\n        var t;\n        return e.length > 1 && kf(df(e, 0, 2)) && (2 === e.length || \"/\" === (t = $m(e, 2)) || \"\\\\\" === t || \"?\" === t || \"#\" === t);\n      },\n      Uf = function (e) {\n        return \".\" === e || \"%2e\" === lf(e);\n      },\n      Vf = {},\n      xf = {},\n      Ff = {},\n      Bf = {},\n      jf = {},\n      Gf = {},\n      Wf = {},\n      Hf = {},\n      Kf = {},\n      Yf = {},\n      zf = {},\n      qf = {},\n      Xf = {},\n      Jf = {},\n      Qf = {},\n      Zf = {},\n      $f = {},\n      eS = {},\n      tS = {},\n      iS = {},\n      nS = {},\n      rS = function (e, t, i) {\n        var n,\n          r,\n          o,\n          s = Fm(e);\n        if (t) {\n          if (r = this.parse(s)) throw new Xm(r);\n          this.searchParams = null;\n        } else {\n          if (void 0 !== i && (n = new rS(i, !0)), r = this.parse(s, null, n)) throw new Xm(r);\n          (o = zm(new Ym())).bindURL(this), this.searchParams = o;\n        }\n      };\n    rS.prototype = {\n      type: \"URL\",\n      parse: function (e, t, i) {\n        var n,\n          r,\n          o,\n          s,\n          a,\n          c = this,\n          d = t || Vf,\n          l = 0,\n          u = \"\",\n          h = !1,\n          p = !1,\n          _ = !1;\n        for (e = Fm(e), t || (c.scheme = \"\", c.username = \"\", c.password = \"\", c.host = null, c.port = null, c.path = [], c.query = null, c.fragment = null, c.cannotBeABaseURL = !1, e = sf(e, yf, \"\"), e = sf(e, If, \"$1\")), e = sf(e, Af, \"\"), n = Mm(e); l <= n.length;) {\n          switch (r = n[l], d) {\n            case Vf:\n              if (!r || !ef(Ef, r)) {\n                if (t) return hf;\n                d = Ff;\n                continue;\n              }\n              u += lf(r), d = xf;\n              break;\n            case xf:\n              if (r && (ef(mf, r) || \"+\" === r || \"-\" === r || \".\" === r)) u += lf(r);else {\n                if (\":\" !== r) {\n                  if (t) return hf;\n                  u = \"\", d = Ff, l = 0;\n                  continue;\n                }\n                if (t && (c.isSpecial() !== Lm(Lf, u) || \"file\" === u && (c.includesCredentials() || null !== c.port) || \"file\" === c.scheme && !c.host)) return;\n                if (c.scheme = u, t) return void (c.isSpecial() && Lf[c.scheme] === c.port && (c.port = null));\n                u = \"\", \"file\" === c.scheme ? d = Jf : c.isSpecial() && i && i.scheme === c.scheme ? d = Bf : c.isSpecial() ? d = Hf : \"/\" === n[l + 1] ? (d = jf, l++) : (c.cannotBeABaseURL = !0, of(c.path, \"\"), d = tS);\n              }\n              break;\n            case Ff:\n              if (!i || i.cannotBeABaseURL && \"#\" !== r) return hf;\n              if (i.cannotBeABaseURL && \"#\" === r) {\n                c.scheme = i.scheme, c.path = Um(i.path), c.query = i.query, c.fragment = \"\", c.cannotBeABaseURL = !0, d = nS;\n                break;\n              }\n              d = \"file\" === i.scheme ? Jf : Gf;\n              continue;\n            case Bf:\n              if (\"/\" !== r || \"/\" !== n[l + 1]) {\n                d = Gf;\n                continue;\n              }\n              d = Kf, l++;\n              break;\n            case jf:\n              if (\"/\" === r) {\n                d = Yf;\n                break;\n              }\n              d = eS;\n              continue;\n            case Gf:\n              if (c.scheme = i.scheme, r === bE) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = Um(i.path), c.query = i.query;else if (\"/\" === r || \"\\\\\" === r && c.isSpecial()) d = Wf;else if (\"?\" === r) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = Um(i.path), c.query = \"\", d = iS;else {\n                if (\"#\" !== r) {\n                  c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = Um(i.path), c.path.length--, d = eS;\n                  continue;\n                }\n                c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = Um(i.path), c.query = i.query, c.fragment = \"\", d = nS;\n              }\n              break;\n            case Wf:\n              if (!c.isSpecial() || \"/\" !== r && \"\\\\\" !== r) {\n                if (\"/\" !== r) {\n                  c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, d = eS;\n                  continue;\n                }\n                d = Yf;\n              } else d = Kf;\n              break;\n            case Hf:\n              if (d = Kf, \"/\" !== r || \"/\" !== $m(u, l + 1)) continue;\n              l++;\n              break;\n            case Kf:\n              if (\"/\" !== r && \"\\\\\" !== r) {\n                d = Yf;\n                continue;\n              }\n              break;\n            case Yf:\n              if (\"@\" === r) {\n                h && (u = \"%40\" + u), h = !0, o = Mm(u);\n                for (var E = 0; E < o.length; E++) {\n                  var m = o[E];\n                  if (\":\" !== m || _) {\n                    var f = Pf(m, Df);\n                    _ ? c.password += f : c.username += f;\n                  } else _ = !0;\n                }\n                u = \"\";\n              } else if (r === bE || \"/\" === r || \"?\" === r || \"#\" === r || \"\\\\\" === r && c.isSpecial()) {\n                if (h && \"\" === u) return \"Invalid authority\";\n                l -= Mm(u).length + 1, u = \"\", d = zf;\n              } else u += r;\n              break;\n            case zf:\n            case qf:\n              if (t && \"file\" === c.scheme) {\n                d = Zf;\n                continue;\n              }\n              if (\":\" !== r || p) {\n                if (r === bE || \"/\" === r || \"?\" === r || \"#\" === r || \"\\\\\" === r && c.isSpecial()) {\n                  if (c.isSpecial() && \"\" === u) return pf;\n                  if (t && \"\" === u && (c.includesCredentials() || null !== c.port)) return;\n                  if (s = c.parseHost(u)) return s;\n                  if (u = \"\", d = $f, t) return;\n                  continue;\n                }\n                \"[\" === r ? p = !0 : \"]\" === r && (p = !1), u += r;\n              } else {\n                if (\"\" === u) return pf;\n                if (s = c.parseHost(u)) return s;\n                if (u = \"\", d = Xf, t === qf) return;\n              }\n              break;\n            case Xf:\n              if (!ef(ff, r)) {\n                if (r === bE || \"/\" === r || \"?\" === r || \"#\" === r || \"\\\\\" === r && c.isSpecial() || t) {\n                  if (\"\" !== u) {\n                    var S = Jm(u, 10);\n                    if (S > 65535) return _f;\n                    c.port = c.isSpecial() && S === Lf[c.scheme] ? null : S, u = \"\";\n                  }\n                  if (t) return;\n                  d = $f;\n                  continue;\n                }\n                return _f;\n              }\n              u += r;\n              break;\n            case Jf:\n              if (c.scheme = \"file\", \"/\" === r || \"\\\\\" === r) d = Qf;else {\n                if (!i || \"file\" !== i.scheme) {\n                  d = eS;\n                  continue;\n                }\n                switch (r) {\n                  case bE:\n                    c.host = i.host, c.path = Um(i.path), c.query = i.query;\n                    break;\n                  case \"?\":\n                    c.host = i.host, c.path = Um(i.path), c.query = \"\", d = iS;\n                    break;\n                  case \"#\":\n                    c.host = i.host, c.path = Um(i.path), c.query = i.query, c.fragment = \"\", d = nS;\n                    break;\n                  default:\n                    Mf(tf(Um(n, l), \"\")) || (c.host = i.host, c.path = Um(i.path), c.shortenPath()), d = eS;\n                    continue;\n                }\n              }\n              break;\n            case Qf:\n              if (\"/\" === r || \"\\\\\" === r) {\n                d = Zf;\n                break;\n              }\n              i && \"file\" === i.scheme && !Mf(tf(Um(n, l), \"\")) && (kf(i.path[0], !0) ? of(c.path, i.path[0]) : c.host = i.host), d = eS;\n              continue;\n            case Zf:\n              if (r === bE || \"/\" === r || \"\\\\\" === r || \"?\" === r || \"#\" === r) {\n                if (!t && kf(u)) d = eS;else if (\"\" === u) {\n                  if (c.host = \"\", t) return;\n                  d = $f;\n                } else {\n                  if (s = c.parseHost(u)) return s;\n                  if (\"localhost\" === c.host && (c.host = \"\"), t) return;\n                  u = \"\", d = $f;\n                }\n                continue;\n              }\n              u += r;\n              break;\n            case $f:\n              if (c.isSpecial()) {\n                if (d = eS, \"/\" !== r && \"\\\\\" !== r) continue;\n              } else if (t || \"?\" !== r) {\n                if (t || \"#\" !== r) {\n                  if (r !== bE && (d = eS, \"/\" !== r)) continue;\n                } else c.fragment = \"\", d = nS;\n              } else c.query = \"\", d = iS;\n              break;\n            case eS:\n              if (r === bE || \"/\" === r || \"\\\\\" === r && c.isSpecial() || !t && (\"?\" === r || \"#\" === r)) {\n                if (\"..\" === (a = lf(a = u)) || \"%2e.\" === a || \".%2e\" === a || \"%2e%2e\" === a ? (c.shortenPath(), \"/\" === r || \"\\\\\" === r && c.isSpecial() || of(c.path, \"\")) : Uf(u) ? \"/\" === r || \"\\\\\" === r && c.isSpecial() || of(c.path, \"\") : (\"file\" === c.scheme && !c.path.length && kf(u) && (c.host && (c.host = \"\"), u = $m(u, 0) + \":\"), of(c.path, u)), u = \"\", \"file\" === c.scheme && (r === bE || \"?\" === r || \"#\" === r)) for (; c.path.length > 1 && \"\" === c.path[0];) af(c.path);\n                \"?\" === r ? (c.query = \"\", d = iS) : \"#\" === r && (c.fragment = \"\", d = nS);\n              } else u += Pf(r, Nf);\n              break;\n            case tS:\n              \"?\" === r ? (c.query = \"\", d = iS) : \"#\" === r ? (c.fragment = \"\", d = nS) : r !== bE && (c.path[0] += Pf(r, wf));\n              break;\n            case iS:\n              t || \"#\" !== r ? r !== bE && (\"'\" === r && c.isSpecial() ? c.query += \"%27\" : c.query += \"#\" === r ? \"%23\" : Pf(r, wf)) : (c.fragment = \"\", d = nS);\n              break;\n            case nS:\n              r !== bE && (c.fragment += Pf(r, Of));\n          }\n          l++;\n        }\n      },\n      parseHost: function (e) {\n        var t, i, n;\n        if (\"[\" === $m(e, 0)) {\n          if (\"]\" !== $m(e, e.length - 1)) return pf;\n          if (t = function (e) {\n            var t,\n              i,\n              n,\n              r,\n              o,\n              s,\n              a,\n              c = [0, 0, 0, 0, 0, 0, 0, 0],\n              d = 0,\n              l = null,\n              u = 0,\n              h = function () {\n                return $m(e, u);\n              };\n            if (\":\" === h()) {\n              if (\":\" !== $m(e, 1)) return;\n              u += 2, l = ++d;\n            }\n            for (; h();) {\n              if (8 === d) return;\n              if (\":\" !== h()) {\n                for (t = i = 0; i < 4 && ef(Rf, h());) t = 16 * t + Jm(h(), 16), u++, i++;\n                if (\".\" === h()) {\n                  if (0 === i) return;\n                  if (u -= i, d > 6) return;\n                  for (n = 0; h();) {\n                    if (r = null, n > 0) {\n                      if (!(\".\" === h() && n < 4)) return;\n                      u++;\n                    }\n                    if (!ef(ff, h())) return;\n                    for (; ef(ff, h());) {\n                      if (o = Jm(h(), 10), null === r) r = o;else {\n                        if (0 === r) return;\n                        r = 10 * r + o;\n                      }\n                      if (r > 255) return;\n                      u++;\n                    }\n                    c[d] = 256 * c[d] + r, 2 != ++n && 4 !== n || d++;\n                  }\n                  if (4 !== n) return;\n                  break;\n                }\n                if (\":\" === h()) {\n                  if (u++, !h()) return;\n                } else if (h()) return;\n                c[d++] = t;\n              } else {\n                if (null !== l) return;\n                u++, l = ++d;\n              }\n            }\n            if (null !== l) for (s = d - l, d = 7; 0 !== d && s > 0;) a = c[d], c[d--] = c[l + s - 1], c[l + --s] = a;else if (8 !== d) return;\n            return c;\n          }(df(e, 1, -1)), !t) return pf;\n          this.host = t;\n        } else if (this.isSpecial()) {\n          if (e = xm(e), ef(Cf, e)) return pf;\n          if (t = function (e) {\n            var t,\n              i,\n              n,\n              r,\n              o,\n              s,\n              a,\n              c = cf(e, \".\");\n            if (c.length && \"\" === c[c.length - 1] && c.length--, (t = c.length) > 4) return e;\n            for (i = [], n = 0; n < t; n++) {\n              if (\"\" === (r = c[n])) return e;\n              if (o = 10, r.length > 1 && \"0\" === $m(r, 0) && (o = ef(Sf, r) ? 16 : 8, r = df(r, 8 === o ? 1 : 2)), \"\" === r) s = 0;else {\n                if (!ef(10 === o ? Tf : 8 === o ? gf : Rf, r)) return e;\n                s = Jm(r, o);\n              }\n              of(i, s);\n            }\n            for (n = 0; n < t; n++) if (s = i[n], n === t - 1) {\n              if (s >= Zm(256, 5 - t)) return null;\n            } else if (s > 255) return null;\n            for (a = rf(i), n = 0; n < i.length; n++) a += i[n] * Zm(256, 3 - n);\n            return a;\n          }(e), null === t) return pf;\n          this.host = t;\n        } else {\n          if (ef(vf, e)) return pf;\n          for (t = \"\", i = Mm(e), n = 0; n < i.length; n++) t += Pf(i[n], wf);\n          this.host = t;\n        }\n      },\n      cannotHaveUsernamePasswordPort: function () {\n        return !this.host || this.cannotBeABaseURL || \"file\" === this.scheme;\n      },\n      includesCredentials: function () {\n        return \"\" !== this.username || \"\" !== this.password;\n      },\n      isSpecial: function () {\n        return Lm(Lf, this.scheme);\n      },\n      shortenPath: function () {\n        var e = this.path,\n          t = e.length;\n        !t || \"file\" === this.scheme && 1 === t && kf(e[0], !0) || e.length--;\n      },\n      serialize: function () {\n        var e = this,\n          t = e.scheme,\n          i = e.username,\n          n = e.password,\n          r = e.host,\n          o = e.port,\n          s = e.path,\n          a = e.query,\n          c = e.fragment,\n          d = t + \":\";\n        return null !== r ? (d += \"//\", e.includesCredentials() && (d += i + (n ? \":\" + n : \"\") + \"@\"), d += bf(r), null !== o && (d += \":\" + o)) : \"file\" === t && (d += \"//\"), d += e.cannotBeABaseURL ? s[0] : s.length ? \"/\" + tf(s, \"/\") : \"\", null !== a && (d += \"?\" + a), null !== c && (d += \"#\" + c), d;\n      },\n      setHref: function (e) {\n        var t = this.parse(e);\n        if (t) throw new Xm(t);\n        this.searchParams.update();\n      },\n      getOrigin: function () {\n        var e = this.scheme,\n          t = this.port;\n        if (\"blob\" === e) try {\n          return new oS(e.path[0]).origin;\n        } catch (e) {\n          return \"null\";\n        }\n        return \"file\" !== e && this.isSpecial() ? e + \"://\" + bf(this.host) + (null !== t ? \":\" + t : \"\") : \"null\";\n      },\n      getProtocol: function () {\n        return this.scheme + \":\";\n      },\n      setProtocol: function (e) {\n        this.parse(Fm(e) + \":\", Vf);\n      },\n      getUsername: function () {\n        return this.username;\n      },\n      setUsername: function (e) {\n        var t = Mm(Fm(e));\n        if (!this.cannotHaveUsernamePasswordPort()) {\n          this.username = \"\";\n          for (var i = 0; i < t.length; i++) this.username += Pf(t[i], Df);\n        }\n      },\n      getPassword: function () {\n        return this.password;\n      },\n      setPassword: function (e) {\n        var t = Mm(Fm(e));\n        if (!this.cannotHaveUsernamePasswordPort()) {\n          this.password = \"\";\n          for (var i = 0; i < t.length; i++) this.password += Pf(t[i], Df);\n        }\n      },\n      getHost: function () {\n        var e = this.host,\n          t = this.port;\n        return null === e ? \"\" : null === t ? bf(e) : bf(e) + \":\" + t;\n      },\n      setHost: function (e) {\n        this.cannotBeABaseURL || this.parse(e, zf);\n      },\n      getHostname: function () {\n        var e = this.host;\n        return null === e ? \"\" : bf(e);\n      },\n      setHostname: function (e) {\n        this.cannotBeABaseURL || this.parse(e, qf);\n      },\n      getPort: function () {\n        var e = this.port;\n        return null === e ? \"\" : Fm(e);\n      },\n      setPort: function (e) {\n        this.cannotHaveUsernamePasswordPort() || (\"\" === (e = Fm(e)) ? this.port = null : this.parse(e, Xf));\n      },\n      getPathname: function () {\n        var e = this.path;\n        return this.cannotBeABaseURL ? e[0] : e.length ? \"/\" + tf(e, \"/\") : \"\";\n      },\n      setPathname: function (e) {\n        this.cannotBeABaseURL || (this.path = [], this.parse(e, $f));\n      },\n      getSearch: function () {\n        var e = this.query;\n        return e ? \"?\" + e : \"\";\n      },\n      setSearch: function (e) {\n        \"\" === (e = Fm(e)) ? this.query = null : (\"?\" === $m(e, 0) && (e = df(e, 1)), this.query = \"\", this.parse(e, iS)), this.searchParams.update();\n      },\n      getSearchParams: function () {\n        return this.searchParams.facade;\n      },\n      getHash: function () {\n        var e = this.fragment;\n        return e ? \"#\" + e : \"\";\n      },\n      setHash: function (e) {\n        \"\" !== (e = Fm(e)) ? (\"#\" === $m(e, 0) && (e = df(e, 1)), this.fragment = \"\", this.parse(e, nS)) : this.fragment = null;\n      },\n      update: function () {\n        this.query = this.searchParams.serialize() || null;\n      }\n    };\n    var oS = function (e) {\n        var t = Pm(this, sS),\n          i = jm(arguments.length, 1) > 1 ? arguments[1] : void 0,\n          n = Hm(t, new rS(e, !1, i));\n        Im || (t.href = n.serialize(), t.origin = n.getOrigin(), t.protocol = n.getProtocol(), t.username = n.getUsername(), t.password = n.getPassword(), t.host = n.getHost(), t.hostname = n.getHostname(), t.port = n.getPort(), t.pathname = n.getPathname(), t.search = n.getSearch(), t.searchParams = n.getSearchParams(), t.hash = n.getHash());\n      },\n      sS = oS.prototype,\n      aS = function (e, t) {\n        return {\n          get: function () {\n            return Km(this)[e]();\n          },\n          set: t && function (e) {\n            return Km(this)[t](e);\n          },\n          configurable: !0,\n          enumerable: !0\n        };\n      };\n    if (Im && (Dm(sS, \"href\", aS(\"serialize\", \"setHref\")), Dm(sS, \"origin\", aS(\"getOrigin\")), Dm(sS, \"protocol\", aS(\"getProtocol\", \"setProtocol\")), Dm(sS, \"username\", aS(\"getUsername\", \"setUsername\")), Dm(sS, \"password\", aS(\"getPassword\", \"setPassword\")), Dm(sS, \"host\", aS(\"getHost\", \"setHost\")), Dm(sS, \"hostname\", aS(\"getHostname\", \"setHostname\")), Dm(sS, \"port\", aS(\"getPort\", \"setPort\")), Dm(sS, \"pathname\", aS(\"getPathname\", \"setPathname\")), Dm(sS, \"search\", aS(\"getSearch\", \"setSearch\")), Dm(sS, \"searchParams\", aS(\"getSearchParams\")), Dm(sS, \"hash\", aS(\"getHash\", \"setHash\"))), Nm(sS, \"toJSON\", function () {\n      return Km(this).serialize();\n    }, {\n      enumerable: !0\n    }), Nm(sS, \"toString\", function () {\n      return Km(this).serialize();\n    }, {\n      enumerable: !0\n    }), qm) {\n      var cS = qm.createObjectURL,\n        dS = qm.revokeObjectURL;\n      cS && Nm(oS, \"createObjectURL\", wm(cS, qm)), dS && Nm(oS, \"revokeObjectURL\", wm(dS, qm));\n    }\n    Bm(oS, \"URL\"), ym({\n      global: !0,\n      constructor: !0,\n      forced: !Am,\n      sham: !Im\n    }, {\n      URL: oS\n    });\n    var lS = Oi,\n      uS = n,\n      hS = cd,\n      pS = Sn,\n      _S = a_,\n      ES = re(\"URL\"),\n      mS = _S && uS(function () {\n        ES.canParse();\n      }),\n      fS = uS(function () {\n        return 1 !== ES.canParse.length;\n      });\n    lS({\n      target: \"URL\",\n      stat: !0,\n      forced: !mS || fS\n    }, {\n      canParse: function (e) {\n        var t = hS(arguments.length, 1),\n          i = pS(e),\n          n = t < 2 || void 0 === arguments[1] ? void 0 : pS(arguments[1]);\n        try {\n          return !!new ES(i, n);\n        } catch (e) {\n          return !1;\n        }\n      }\n    });\n    var SS = Oi,\n      gS = cd,\n      TS = Sn,\n      RS = a_,\n      CS = re(\"URL\");\n    SS({\n      target: \"URL\",\n      stat: !0,\n      forced: !RS\n    }, {\n      parse: function (e) {\n        var t = gS(arguments.length, 1),\n          i = TS(e),\n          n = t < 2 || void 0 === arguments[1] ? void 0 : TS(arguments[1]);\n        try {\n          return new CS(i, n);\n        } catch (e) {\n          return null;\n        }\n      }\n    });\n    var vS = i($.URL);\n    let yS = !0,\n      IS = !0;\n    function AS(e, t, i) {\n      const n = e.match(t);\n      return n && n.length >= i && parseInt(n[i], 10);\n    }\n    function bS(e, t, i) {\n      if (!e.RTCPeerConnection) return;\n      const n = e.RTCPeerConnection.prototype,\n        r = n.addEventListener;\n      n.addEventListener = function (e, n) {\n        if (e !== t) return r.apply(this, arguments);\n        const o = e => {\n          const t = i(e);\n          t && (n.handleEvent ? n.handleEvent(t) : n(t));\n        };\n        return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map()), this._eventMap[t].set(n, o), r.apply(this, [e, o]);\n      };\n      const o = n.removeEventListener;\n      n.removeEventListener = function (e, i) {\n        if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments);\n        if (!this._eventMap[t].has(i)) return o.apply(this, arguments);\n        const n = this._eventMap[t].get(i);\n        return this._eventMap[t].delete(i), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, n]);\n      }, Object.defineProperty(n, \"on\" + t, {\n        get() {\n          return this[\"_on\" + t];\n        },\n        set(e) {\n          this[\"_on\" + t] && (this.removeEventListener(t, this[\"_on\" + t]), delete this[\"_on\" + t]), e && this.addEventListener(t, this[\"_on\" + t] = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      });\n    }\n    function wS(e) {\n      return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (yS = e, e ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n    }\n    function OS(e) {\n      return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (IS = !e, \"adapter.js deprecation warnings \" + (e ? \"disabled\" : \"enabled\"));\n    }\n    function NS() {\n      if (false) {\n        if (yS) return;\n        \"undefined\" != typeof console && \"function\" == typeof console.log && console.log.apply(console, arguments);\n      }\n    }\n    function DS(e, t) {\n      IS && console.warn(e + \" is deprecated, please use \" + t + \" instead.\");\n    }\n    function PS(e) {\n      return \"[object Object]\" === Object.prototype.toString.call(e);\n    }\n    function LS(e) {\n      var t;\n      return PS(e) ? nr(t = Object.keys(e)).call(t, function (t, i) {\n        const n = PS(e[i]),\n          r = n ? LS(e[i]) : e[i],\n          o = n && !Object.keys(r).length;\n        return void 0 === r || o ? t : Object.assign(t, {\n          [i]: r\n        });\n      }, {}) : e;\n    }\n    function kS(e, t, i) {\n      t && !i.has(t.id) && (i.set(t.id, t), Object.keys(t).forEach(n => {\n        n.endsWith(\"Id\") ? kS(e, e.get(t[n]), i) : n.endsWith(\"Ids\") && t[n].forEach(t => {\n          kS(e, e.get(t), i);\n        });\n      }));\n    }\n    function MS(e, t, i) {\n      const n = i ? \"outbound-rtp\" : \"inbound-rtp\",\n        r = new Map();\n      if (null === t) return r;\n      const o = [];\n      return e.forEach(e => {\n        \"track\" === e.type && e.trackIdentifier === t.id && o.push(e);\n      }), o.forEach(t => {\n        e.forEach(i => {\n          i.type === n && i.trackId === t.id && kS(e, i, r);\n        });\n      }), r;\n    }\n    const US = NS;\n    function VS(e, t) {\n      const i = e && e.navigator;\n      if (!i.mediaDevices) return;\n      const n = function (e) {\n          if (\"object\" != typeof e || e.mandatory || e.optional) return e;\n          const t = {};\n          return Object.keys(e).forEach(i => {\n            if (\"require\" === i || \"advanced\" === i || \"mediaSource\" === i) return;\n            const n = \"object\" == typeof e[i] ? e[i] : {\n              ideal: e[i]\n            };\n            void 0 !== n.exact && \"number\" == typeof n.exact && (n.min = n.max = n.exact);\n            const r = function (e, t) {\n              return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : \"deviceId\" === t ? \"sourceId\" : t;\n            };\n            if (void 0 !== n.ideal) {\n              t.optional = t.optional || [];\n              let e = {};\n              \"number\" == typeof n.ideal ? (e[r(\"min\", i)] = n.ideal, t.optional.push(e), e = {}, e[r(\"max\", i)] = n.ideal, t.optional.push(e)) : (e[r(\"\", i)] = n.ideal, t.optional.push(e));\n            }\n            void 0 !== n.exact && \"number\" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r(\"\", i)] = n.exact) : [\"min\", \"max\"].forEach(e => {\n              void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, i)] = n[e]);\n            });\n          }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t;\n        },\n        r = function (e, r) {\n          if (t.version >= 61) return r(e);\n          if ((e = JSON.parse(JSON.stringify(e))) && \"object\" == typeof e.audio) {\n            const t = function (e, t, i) {\n              t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n            };\n            t((e = JSON.parse(JSON.stringify(e))).audio, \"autoGainControl\", \"googAutoGainControl\"), t(e.audio, \"noiseSuppression\", \"googNoiseSuppression\"), e.audio = n(e.audio);\n          }\n          if (e && \"object\" == typeof e.video) {\n            let o = e.video.facingMode;\n            o = o && (\"object\" == typeof o ? o : {\n              ideal: o\n            });\n            const s = t.version < 66;\n            if (o && (\"user\" === o.exact || \"environment\" === o.exact || \"user\" === o.ideal || \"environment\" === o.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || s)) {\n              let t;\n              if (delete e.video.facingMode, \"environment\" === o.exact || \"environment\" === o.ideal ? t = [\"back\", \"rear\"] : \"user\" !== o.exact && \"user\" !== o.ideal || (t = [\"front\"]), t) return i.mediaDevices.enumerateDevices().then(i => {\n                i = i.filter(e => \"videoinput\" === e.kind);\n                let s = i.find(e => t.some(t => {\n                  var i;\n                  return Ln(i = e.label.toLowerCase()).call(i, t);\n                }));\n                return !s && i.length && Ln(t).call(t, \"back\") && (s = i[i.length - 1]), s && (e.video.deviceId = o.exact ? {\n                  exact: s.deviceId\n                } : {\n                  ideal: s.deviceId\n                }), e.video = n(e.video), US(\"chrome: \" + JSON.stringify(e)), r(e);\n              });\n            }\n            e.video = n(e.video);\n          }\n          return US(\"chrome: \" + JSON.stringify(e)), r(e);\n        },\n        o = function (e) {\n          return t.version >= 64 ? e : {\n            name: {\n              PermissionDeniedError: \"NotAllowedError\",\n              PermissionDismissedError: \"NotAllowedError\",\n              InvalidStateError: \"NotAllowedError\",\n              DevicesNotFoundError: \"NotFoundError\",\n              ConstraintNotSatisfiedError: \"OverconstrainedError\",\n              TrackStartError: \"NotReadableError\",\n              MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n              MediaDeviceKillSwitchOn: \"NotAllowedError\",\n              TabCaptureError: \"AbortError\",\n              ScreenCaptureError: \"AbortError\",\n              DeviceCaptureError: \"AbortError\"\n            }[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString() {\n              return this.name + (this.message && \": \") + this.message;\n            }\n          };\n        };\n      if (i.getUserMedia = function (e, t, n) {\n        r(e, e => {\n          i.webkitGetUserMedia(e, t, e => {\n            n && n(o(e));\n          });\n        });\n      }.bind(i), i.mediaDevices.getUserMedia) {\n        const e = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n        i.mediaDevices.getUserMedia = function (t) {\n          return r(t, t => e(t).then(e => {\n            if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {\n              e.stop();\n            }), new DOMException(\"\", \"NotFoundError\");\n            return e;\n          }, e => rp.reject(o(e))));\n        };\n      }\n    }\n    function xS(e) {\n      e.MediaStream = e.MediaStream || e.webkitMediaStream;\n    }\n    function FS(e) {\n      if (\"object\" == typeof e && e.RTCPeerConnection && !(\"ontrack\" in e.RTCPeerConnection.prototype)) {\n        Object.defineProperty(e.RTCPeerConnection.prototype, \"ontrack\", {\n          get() {\n            return this._ontrack;\n          },\n          set(e) {\n            this._ontrack && this.removeEventListener(\"track\", this._ontrack), this.addEventListener(\"track\", this._ontrack = e);\n          },\n          enumerable: !0,\n          configurable: !0\n        });\n        const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n        e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n          return this._ontrackpoly || (this._ontrackpoly = t => {\n            t.stream.addEventListener(\"addtrack\", i => {\n              let n;\n              n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.track.id) : {\n                track: i.track\n              };\n              const r = new Event(\"track\");\n              r.track = i.track, r.receiver = n, r.transceiver = {\n                receiver: n\n              }, r.streams = [t.stream], this.dispatchEvent(r);\n            }), t.stream.getTracks().forEach(i => {\n              let n;\n              n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.id) : {\n                track: i\n              };\n              const r = new Event(\"track\");\n              r.track = i, r.receiver = n, r.transceiver = {\n                receiver: n\n              }, r.streams = [t.stream], this.dispatchEvent(r);\n            });\n          }, this.addEventListener(\"addstream\", this._ontrackpoly)), t.apply(this, arguments);\n        };\n      } else bS(e, \"track\", e => (e.transceiver || Object.defineProperty(e, \"transceiver\", {\n        value: {\n          receiver: e.receiver\n        }\n      }), e));\n    }\n    function BS(e) {\n      if (\"object\" == typeof e && e.RTCPeerConnection && !(\"getSenders\" in e.RTCPeerConnection.prototype) && \"createDTMFSender\" in e.RTCPeerConnection.prototype) {\n        const t = function (e, t) {\n          return {\n            track: t,\n            get dtmf() {\n              return void 0 === this._dtmf && (\"audio\" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf;\n            },\n            _pc: e\n          };\n        };\n        if (!e.RTCPeerConnection.prototype.getSenders) {\n          e.RTCPeerConnection.prototype.getSenders = function () {\n            return this._senders = this._senders || [], this._senders.slice();\n          };\n          const i = e.RTCPeerConnection.prototype.addTrack;\n          e.RTCPeerConnection.prototype.addTrack = function (e, n) {\n            let r = i.apply(this, arguments);\n            return r || (r = t(this, e), this._senders.push(r)), r;\n          };\n          const n = e.RTCPeerConnection.prototype.removeTrack;\n          e.RTCPeerConnection.prototype.removeTrack = function (e) {\n            n.apply(this, arguments);\n            const t = this._senders.indexOf(e);\n            -1 !== t && this._senders.splice(t, 1);\n          };\n        }\n        const i = e.RTCPeerConnection.prototype.addStream;\n        e.RTCPeerConnection.prototype.addStream = function (e) {\n          this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach(e => {\n            this._senders.push(t(this, e));\n          });\n        };\n        const n = e.RTCPeerConnection.prototype.removeStream;\n        e.RTCPeerConnection.prototype.removeStream = function (e) {\n          this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {\n            const t = this._senders.find(t => t.track === e);\n            t && this._senders.splice(this._senders.indexOf(t), 1);\n          });\n        };\n      } else if (\"object\" == typeof e && e.RTCPeerConnection && \"getSenders\" in e.RTCPeerConnection.prototype && \"createDTMFSender\" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !(\"dtmf\" in e.RTCRtpSender.prototype)) {\n        const t = e.RTCPeerConnection.prototype.getSenders;\n        e.RTCPeerConnection.prototype.getSenders = function () {\n          const e = t.apply(this, []);\n          return e.forEach(e => e._pc = this), e;\n        }, Object.defineProperty(e.RTCRtpSender.prototype, \"dtmf\", {\n          get() {\n            return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n          }\n        });\n      }\n    }\n    function jS(e) {\n      if (!e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection.prototype.getStats;\n      e.RTCPeerConnection.prototype.getStats = function () {\n        const [e, i, n] = arguments;\n        if (arguments.length > 0 && \"function\" == typeof e) return t.apply(this, arguments);\n        if (0 === t.length && (0 === arguments.length || \"function\" != typeof e)) return t.apply(this, []);\n        const r = function (e) {\n            const t = {};\n            return e.result().forEach(e => {\n              const i = {\n                id: e.id,\n                timestamp: e.timestamp,\n                type: {\n                  localcandidate: \"local-candidate\",\n                  remotecandidate: \"remote-candidate\"\n                }[e.type] || e.type\n              };\n              e.names().forEach(t => {\n                i[t] = e.stat(t);\n              }), t[i.id] = i;\n            }), t;\n          },\n          o = function (e) {\n            return new Map(Object.keys(e).map(t => [t, e[t]]));\n          };\n        if (arguments.length >= 2) {\n          const n = function (e) {\n            i(o(r(e)));\n          };\n          return t.apply(this, [n, e]);\n        }\n        return new rp((e, i) => {\n          t.apply(this, [function (t) {\n            e(o(r(t)));\n          }, i]);\n        }).then(i, n);\n      };\n    }\n    function GS(e) {\n      if (!(\"object\" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;\n      if (!(\"getStats\" in e.RTCRtpSender.prototype)) {\n        const t = e.RTCPeerConnection.prototype.getSenders;\n        t && (e.RTCPeerConnection.prototype.getSenders = function () {\n          const e = t.apply(this, []);\n          return e.forEach(e => e._pc = this), e;\n        });\n        const i = e.RTCPeerConnection.prototype.addTrack;\n        i && (e.RTCPeerConnection.prototype.addTrack = function () {\n          const e = i.apply(this, arguments);\n          return e._pc = this, e;\n        }), e.RTCRtpSender.prototype.getStats = function () {\n          const e = this;\n          return this._pc.getStats().then(t => MS(t, e.track, !0));\n        };\n      }\n      if (!(\"getStats\" in e.RTCRtpReceiver.prototype)) {\n        const t = e.RTCPeerConnection.prototype.getReceivers;\n        t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n          const e = t.apply(this, []);\n          return e.forEach(e => e._pc = this), e;\n        }), bS(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n          const e = this;\n          return this._pc.getStats().then(t => MS(t, e.track, !1));\n        };\n      }\n      if (!(\"getStats\" in e.RTCRtpSender.prototype) || !(\"getStats\" in e.RTCRtpReceiver.prototype)) return;\n      const t = e.RTCPeerConnection.prototype.getStats;\n      e.RTCPeerConnection.prototype.getStats = function () {\n        if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {\n          const e = arguments[0];\n          let t, i, n;\n          return this.getSenders().forEach(i => {\n            i.track === e && (t ? n = !0 : t = i);\n          }), this.getReceivers().forEach(t => (t.track === e && (i ? n = !0 : i = t), t.track === e)), n || t && i ? rp.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : t ? t.getStats() : i ? i.getStats() : rp.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return t.apply(this, arguments);\n      };\n    }\n    function WS(e) {\n      e.RTCPeerConnection.prototype.getLocalStreams = function () {\n        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0]);\n      };\n      const t = e.RTCPeerConnection.prototype.addTrack;\n      e.RTCPeerConnection.prototype.addTrack = function (e, i) {\n        if (!i) return t.apply(this, arguments);\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const n = t.apply(this, arguments);\n        return this._shimmedLocalStreams[i.id] ? -1 === this._shimmedLocalStreams[i.id].indexOf(n) && this._shimmedLocalStreams[i.id].push(n) : this._shimmedLocalStreams[i.id] = [i, n], n;\n      };\n      const i = e.RTCPeerConnection.prototype.addStream;\n      e.RTCPeerConnection.prototype.addStream = function (e) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {\n          const t = this.getSenders().find(t => t.track === e);\n          if (t) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        });\n        const t = this.getSenders();\n        i.apply(this, arguments);\n        const n = this.getSenders().filter(e => -1 === t.indexOf(e));\n        this._shimmedLocalStreams[e.id] = [e].concat(n);\n      };\n      const n = e.RTCPeerConnection.prototype.removeStream;\n      e.RTCPeerConnection.prototype.removeStream = function (e) {\n        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments);\n      };\n      const r = e.RTCPeerConnection.prototype.removeTrack;\n      e.RTCPeerConnection.prototype.removeTrack = function (e) {\n        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {\n          const i = this._shimmedLocalStreams[t].indexOf(e);\n          -1 !== i && this._shimmedLocalStreams[t].splice(i, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t];\n        }), r.apply(this, arguments);\n      };\n    }\n    function HS(e, t) {\n      if (!e.RTCPeerConnection) return;\n      if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return WS(e);\n      const i = e.RTCPeerConnection.prototype.getLocalStreams;\n      e.RTCPeerConnection.prototype.getLocalStreams = function () {\n        const e = i.apply(this);\n        return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id]);\n      };\n      const n = e.RTCPeerConnection.prototype.addStream;\n      e.RTCPeerConnection.prototype.addStream = function (t) {\n        if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {\n          const t = this.getSenders().find(t => t.track === e);\n          if (t) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }), !this._reverseStreams[t.id]) {\n          const i = new e.MediaStream(t.getTracks());\n          this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i;\n        }\n        n.apply(this, [t]);\n      };\n      const r = e.RTCPeerConnection.prototype.removeStream;\n      function o(e, t) {\n        let i = t.sdp;\n        return Object.keys(e._reverseStreams || []).forEach(t => {\n          const n = e._reverseStreams[t],\n            r = e._streams[n.id];\n          i = i.replace(new RegExp(r.id, \"g\"), n.id);\n        }), new RTCSessionDescription({\n          type: t.type,\n          sdp: i\n        });\n      }\n      e.RTCPeerConnection.prototype.removeStream = function (e) {\n        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id];\n      }, e.RTCPeerConnection.prototype.addTrack = function (t, i) {\n        if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        const n = [].slice.call(arguments, 1);\n        if (1 !== n.length || !n[0].getTracks().find(e => e === t)) throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n        const r = this.getSenders().find(e => e.track === t);\n        if (r) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};\n        const o = this._streams[i.id];\n        if (o) o.addTrack(t), rp.resolve().then(() => {\n          this.dispatchEvent(new Event(\"negotiationneeded\"));\n        });else {\n          const n = new e.MediaStream([t]);\n          this._streams[i.id] = n, this._reverseStreams[n.id] = i, this.addStream(n);\n        }\n        return this.getSenders().find(e => e.track === t);\n      }, [\"createOffer\", \"createAnswer\"].forEach(function (t) {\n        const i = e.RTCPeerConnection.prototype[t],\n          n = {\n            [t]() {\n              const e = arguments;\n              return arguments.length && \"function\" == typeof arguments[0] ? i.apply(this, [t => {\n                const i = o(this, t);\n                e[0].apply(null, [i]);\n              }, t => {\n                e[1] && e[1].apply(null, t);\n              }, arguments[2]]) : i.apply(this, arguments).then(e => o(this, e));\n            }\n          };\n        e.RTCPeerConnection.prototype[t] = n[t];\n      });\n      const s = e.RTCPeerConnection.prototype.setLocalDescription;\n      e.RTCPeerConnection.prototype.setLocalDescription = function () {\n        return arguments.length && arguments[0].type ? (arguments[0] = function (e, t) {\n          let i = t.sdp;\n          return Object.keys(e._reverseStreams || []).forEach(t => {\n            const n = e._reverseStreams[t],\n              r = e._streams[n.id];\n            i = i.replace(new RegExp(n.id, \"g\"), r.id);\n          }), new RTCSessionDescription({\n            type: t.type,\n            sdp: i\n          });\n        }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments);\n      };\n      const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, \"localDescription\");\n      Object.defineProperty(e.RTCPeerConnection.prototype, \"localDescription\", {\n        get() {\n          const e = a.get.apply(this);\n          return \"\" === e.type ? e : o(this, e);\n        }\n      }), e.RTCPeerConnection.prototype.removeTrack = function (e) {\n        if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        if (!e._pc) throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n        if (!(e._pc === this)) throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        let t;\n        this._streams = this._streams || {}, Object.keys(this._streams).forEach(i => {\n          this._streams[i].getTracks().find(t => e.track === t) && (t = this._streams[i]);\n        }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event(\"negotiationneeded\")));\n      };\n    }\n    function KS(e, t) {\n      !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n        const i = e.RTCPeerConnection.prototype[t],\n          n = {\n            [t]() {\n              return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n            }\n          };\n        e.RTCPeerConnection.prototype[t] = n[t];\n      });\n    }\n    function YS(e, t) {\n      bS(e, \"negotiationneeded\", e => {\n        const i = e.target;\n        if (!(t.version < 72 || i.getConfiguration && \"plan-b\" === i.getConfiguration().sdpSemantics) || \"stable\" === i.signalingState) return e;\n      });\n    }\n    var zS = Object.freeze({\n      __proto__: null,\n      fixNegotiationNeeded: YS,\n      shimAddTrackRemoveTrack: HS,\n      shimAddTrackRemoveTrackWithNative: WS,\n      shimGetDisplayMedia: function (e, t) {\n        e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (\"function\" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (i) {\n          return t(i).then(t => {\n            const n = i.video && i.video.width,\n              r = i.video && i.video.height,\n              o = i.video && i.video.frameRate;\n            return i.video = {\n              mandatory: {\n                chromeMediaSource: \"desktop\",\n                chromeMediaSourceId: t,\n                maxFrameRate: o || 3\n              }\n            }, n && (i.video.mandatory.maxWidth = n), r && (i.video.mandatory.maxHeight = r), e.navigator.mediaDevices.getUserMedia(i);\n          });\n        } : console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"));\n      },\n      shimGetSendersWithDtmf: BS,\n      shimGetStats: jS,\n      shimGetUserMedia: VS,\n      shimMediaStream: xS,\n      shimOnTrack: FS,\n      shimPeerConnection: KS,\n      shimSenderReceiverGetStats: GS\n    });\n    function qS(e, t) {\n      const i = e && e.navigator,\n        n = e && e.MediaStreamTrack;\n      if (i.getUserMedia = function (e, t, n) {\n        DS(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), i.mediaDevices.getUserMedia(e).then(t, n);\n      }, !(t.version > 55 && \"autoGainControl\" in i.mediaDevices.getSupportedConstraints())) {\n        const e = function (e, t, i) {\n            t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n          },\n          t = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n        if (i.mediaDevices.getUserMedia = function (i) {\n          return \"object\" == typeof i && \"object\" == typeof i.audio && (i = JSON.parse(JSON.stringify(i)), e(i.audio, \"autoGainControl\", \"mozAutoGainControl\"), e(i.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), t(i);\n        }, n && n.prototype.getSettings) {\n          const t = n.prototype.getSettings;\n          n.prototype.getSettings = function () {\n            const i = t.apply(this, arguments);\n            return e(i, \"mozAutoGainControl\", \"autoGainControl\"), e(i, \"mozNoiseSuppression\", \"noiseSuppression\"), i;\n          };\n        }\n        if (n && n.prototype.applyConstraints) {\n          const t = n.prototype.applyConstraints;\n          n.prototype.applyConstraints = function (i) {\n            return \"audio\" === this.kind && \"object\" == typeof i && (i = JSON.parse(JSON.stringify(i)), e(i, \"autoGainControl\", \"mozAutoGainControl\"), e(i, \"noiseSuppression\", \"mozNoiseSuppression\")), t.apply(this, [i]);\n          };\n        }\n      }\n    }\n    function XS(e) {\n      \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n        get() {\n          return {\n            receiver: this.receiver\n          };\n        }\n      });\n    }\n    function JS(e, t) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;\n      !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n        const i = e.RTCPeerConnection.prototype[t],\n          n = {\n            [t]() {\n              return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n            }\n          };\n        e.RTCPeerConnection.prototype[t] = n[t];\n      });\n      const i = {\n          inboundrtp: \"inbound-rtp\",\n          outboundrtp: \"outbound-rtp\",\n          candidatepair: \"candidate-pair\",\n          localcandidate: \"local-candidate\",\n          remotecandidate: \"remote-candidate\"\n        },\n        n = e.RTCPeerConnection.prototype.getStats;\n      e.RTCPeerConnection.prototype.getStats = function () {\n        const [e, r, o] = arguments;\n        return n.apply(this, [e || null]).then(e => {\n          if (t.version < 53 && !r) try {\n            e.forEach(e => {\n              e.type = i[e.type] || e.type;\n            });\n          } catch (t) {\n            if (\"TypeError\" !== t.name) throw t;\n            e.forEach((t, n) => {\n              e.set(n, Object.assign({}, t, {\n                type: i[t.type] || t.type\n              }));\n            });\n          }\n          return e;\n        }).then(r, o);\n      };\n    }\n    function QS(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n      if (e.RTCRtpSender && \"getStats\" in e.RTCRtpSender.prototype) return;\n      const t = e.RTCPeerConnection.prototype.getSenders;\n      t && (e.RTCPeerConnection.prototype.getSenders = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      });\n      const i = e.RTCPeerConnection.prototype.addTrack;\n      i && (e.RTCPeerConnection.prototype.addTrack = function () {\n        const e = i.apply(this, arguments);\n        return e._pc = this, e;\n      }), e.RTCRtpSender.prototype.getStats = function () {\n        return this.track ? this._pc.getStats(this.track) : rp.resolve(new Map());\n      };\n    }\n    function ZS(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n      if (e.RTCRtpSender && \"getStats\" in e.RTCRtpReceiver.prototype) return;\n      const t = e.RTCPeerConnection.prototype.getReceivers;\n      t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      }), bS(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n        return this._pc.getStats(this.track);\n      };\n    }\n    function $S(e) {\n      e.RTCPeerConnection && !(\"removeStream\" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) {\n        DS(\"removeStream\", \"removeTrack\"), this.getSenders().forEach(t => {\n          var i;\n          t.track && Ln(i = e.getTracks()).call(i, t.track) && this.removeTrack(t);\n        });\n      });\n    }\n    function eg(e) {\n      e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel);\n    }\n    function tg(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection.prototype.addTransceiver;\n      t && (e.RTCPeerConnection.prototype.addTransceiver = function () {\n        this.setParametersPromises = [];\n        let e = arguments[1] && arguments[1].sendEncodings;\n        void 0 === e && (e = []), e = [...e];\n        const i = e.length > 0;\n        i && e.forEach(e => {\n          if (\"rid\" in e) {\n            if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError(\"Invalid RID value provided.\");\n          }\n          if (\"scaleResolutionDownBy\" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n          if (\"maxFramerate\" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError(\"max_framerate must be >= 0.0\");\n        });\n        const n = t.apply(this, arguments);\n        if (i) {\n          const {\n              sender: t\n            } = n,\n            i = t.getParameters();\n          (!(\"encodings\" in i) || 1 === i.encodings.length && 0 === Object.keys(i.encodings[0]).length) && (i.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(i).then(() => {\n            delete t.sendEncodings;\n          }).catch(() => {\n            delete t.sendEncodings;\n          })));\n        }\n        return n;\n      });\n    }\n    function ig(e) {\n      if (\"object\" != typeof e || !e.RTCRtpSender) return;\n      const t = e.RTCRtpSender.prototype.getParameters;\n      t && (e.RTCRtpSender.prototype.getParameters = function () {\n        const e = t.apply(this, arguments);\n        return \"encodings\" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e;\n      });\n    }\n    function ng(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection.prototype.createOffer;\n      e.RTCPeerConnection.prototype.createOffer = function () {\n        return this.setParametersPromises && this.setParametersPromises.length ? rp.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n          this.setParametersPromises = [];\n        }) : t.apply(this, arguments);\n      };\n    }\n    function rg(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection.prototype.createAnswer;\n      e.RTCPeerConnection.prototype.createAnswer = function () {\n        return this.setParametersPromises && this.setParametersPromises.length ? rp.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n          this.setParametersPromises = [];\n        }) : t.apply(this, arguments);\n      };\n    }\n    var og = Object.freeze({\n      __proto__: null,\n      shimAddTransceiver: tg,\n      shimCreateAnswer: rg,\n      shimCreateOffer: ng,\n      shimGetDisplayMedia: function (e, t) {\n        e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (i) {\n          if (!i || !i.video) {\n            const e = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n            return e.name = \"NotFoundError\", e.code = 8, rp.reject(e);\n          }\n          return !0 === i.video ? i.video = {\n            mediaSource: t\n          } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i);\n        });\n      },\n      shimGetParameters: ig,\n      shimGetUserMedia: qS,\n      shimOnTrack: XS,\n      shimPeerConnection: JS,\n      shimRTCDataChannel: eg,\n      shimReceiverGetStats: ZS,\n      shimRemoveStream: $S,\n      shimSenderGetStats: QS\n    });\n    function sg(e) {\n      if (\"object\" == typeof e && e.RTCPeerConnection) {\n        if (\"getLocalStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () {\n          return this._localStreams || (this._localStreams = []), this._localStreams;\n        }), !(\"addStream\" in e.RTCPeerConnection.prototype)) {\n          const t = e.RTCPeerConnection.prototype.addTrack;\n          e.RTCPeerConnection.prototype.addStream = function (e) {\n            var i;\n            this._localStreams || (this._localStreams = []), Ln(i = this._localStreams).call(i, e) || this._localStreams.push(e), e.getAudioTracks().forEach(i => t.call(this, i, e)), e.getVideoTracks().forEach(i => t.call(this, i, e));\n          }, e.RTCPeerConnection.prototype.addTrack = function (e) {\n            for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n            return n && n.forEach(e => {\n              var t;\n              this._localStreams ? Ln(t = this._localStreams).call(t, e) || this._localStreams.push(e) : this._localStreams = [e];\n            }), t.apply(this, arguments);\n          };\n        }\n        \"removeStream\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) {\n          this._localStreams || (this._localStreams = []);\n          const t = this._localStreams.indexOf(e);\n          if (-1 === t) return;\n          this._localStreams.splice(t, 1);\n          const i = e.getTracks();\n          this.getSenders().forEach(e => {\n            Ln(i).call(i, e.track) && this.removeTrack(e);\n          });\n        });\n      }\n    }\n    function ag(e) {\n      if (\"object\" == typeof e && e.RTCPeerConnection && (\"getRemoteStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () {\n        return this._remoteStreams ? this._remoteStreams : [];\n      }), !(\"onaddstream\" in e.RTCPeerConnection.prototype))) {\n        Object.defineProperty(e.RTCPeerConnection.prototype, \"onaddstream\", {\n          get() {\n            return this._onaddstream;\n          },\n          set(e) {\n            this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly)), this.addEventListener(\"addstream\", this._onaddstream = e), this.addEventListener(\"track\", this._onaddstreampoly = e => {\n              e.streams.forEach(e => {\n                var t;\n                if (this._remoteStreams || (this._remoteStreams = []), Ln(t = this._remoteStreams).call(t, e)) return;\n                this._remoteStreams.push(e);\n                const i = new Event(\"addstream\");\n                i.stream = e, this.dispatchEvent(i);\n              });\n            });\n          }\n        });\n        const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n        e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n          const e = this;\n          return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function (t) {\n            t.streams.forEach(t => {\n              if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;\n              e._remoteStreams.push(t);\n              const i = new Event(\"addstream\");\n              i.stream = t, e.dispatchEvent(i);\n            });\n          }), t.apply(e, arguments);\n        };\n      }\n    }\n    function cg(e) {\n      if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection.prototype,\n        i = t.createOffer,\n        n = t.createAnswer,\n        r = t.setLocalDescription,\n        o = t.setRemoteDescription,\n        s = t.addIceCandidate;\n      t.createOffer = function (e, t) {\n        const n = arguments.length >= 2 ? arguments[2] : arguments[0],\n          r = i.apply(this, [n]);\n        return t ? (r.then(e, t), rp.resolve()) : r;\n      }, t.createAnswer = function (e, t) {\n        const i = arguments.length >= 2 ? arguments[2] : arguments[0],\n          r = n.apply(this, [i]);\n        return t ? (r.then(e, t), rp.resolve()) : r;\n      };\n      let a = function (e, t, i) {\n        const n = r.apply(this, [e]);\n        return i ? (n.then(t, i), rp.resolve()) : n;\n      };\n      t.setLocalDescription = a, a = function (e, t, i) {\n        const n = o.apply(this, [e]);\n        return i ? (n.then(t, i), rp.resolve()) : n;\n      }, t.setRemoteDescription = a, a = function (e, t, i) {\n        const n = s.apply(this, [e]);\n        return i ? (n.then(t, i), rp.resolve()) : n;\n      }, t.addIceCandidate = a;\n    }\n    function dg(e) {\n      const t = e && e.navigator;\n      if (t.mediaDevices && t.mediaDevices.getUserMedia) {\n        const e = t.mediaDevices,\n          i = e.getUserMedia.bind(e);\n        t.mediaDevices.getUserMedia = e => i(lg(e));\n      }\n      !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, i, n) {\n        t.mediaDevices.getUserMedia(e).then(i, n);\n      }.bind(t));\n    }\n    function lg(e) {\n      return e && void 0 !== e.video ? Object.assign({}, e, {\n        video: LS(e.video)\n      }) : e;\n    }\n    function ug(e) {\n      if (!e.RTCPeerConnection) return;\n      const t = e.RTCPeerConnection;\n      e.RTCPeerConnection = function (e, i) {\n        if (e && e.iceServers) {\n          const t = [];\n          for (let i = 0; i < e.iceServers.length; i++) {\n            let n = e.iceServers[i];\n            !n.hasOwnProperty(\"urls\") && n.hasOwnProperty(\"url\") ? (DS(\"RTCIceServer.url\", \"RTCIceServer.urls\"), n = JSON.parse(JSON.stringify(n)), n.urls = n.url, delete n.url, t.push(n)) : t.push(e.iceServers[i]);\n          }\n          e.iceServers = t;\n        }\n        return new t(e, i);\n      }, e.RTCPeerConnection.prototype = t.prototype, \"generateCertificate\" in t && Object.defineProperty(e.RTCPeerConnection, \"generateCertificate\", {\n        get: () => t.generateCertificate\n      });\n    }\n    function hg(e) {\n      \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n        get() {\n          return {\n            receiver: this.receiver\n          };\n        }\n      });\n    }\n    function pg(e) {\n      const t = e.RTCPeerConnection.prototype.createOffer;\n      e.RTCPeerConnection.prototype.createOffer = function (e) {\n        if (e) {\n          void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);\n          const t = this.getTransceivers().find(e => \"audio\" === e.receiver.track.kind);\n          !1 === e.offerToReceiveAudio && t ? \"sendrecv\" === t.direction ? t.setDirection ? t.setDirection(\"sendonly\") : t.direction = \"sendonly\" : \"recvonly\" === t.direction && (t.setDirection ? t.setDirection(\"inactive\") : t.direction = \"inactive\") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver(\"audio\", {\n            direction: \"recvonly\"\n          }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);\n          const i = this.getTransceivers().find(e => \"video\" === e.receiver.track.kind);\n          !1 === e.offerToReceiveVideo && i ? \"sendrecv\" === i.direction ? i.setDirection ? i.setDirection(\"sendonly\") : i.direction = \"sendonly\" : \"recvonly\" === i.direction && (i.setDirection ? i.setDirection(\"inactive\") : i.direction = \"inactive\") : !0 !== e.offerToReceiveVideo || i || this.addTransceiver(\"video\", {\n            direction: \"recvonly\"\n          });\n        }\n        return t.apply(this, arguments);\n      };\n    }\n    function _g(e) {\n      \"object\" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext);\n    }\n    var Eg = Object.freeze({\n        __proto__: null,\n        shimAudioContext: _g,\n        shimCallbacksAPI: cg,\n        shimConstraints: lg,\n        shimCreateOfferLegacy: pg,\n        shimGetUserMedia: dg,\n        shimLocalStreamsAPI: sg,\n        shimRTCIceServerUrls: ug,\n        shimRemoteStreamsAPI: ag,\n        shimTrackEventTransceiver: hg\n      }),\n      mg = \"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff\",\n      fg = z,\n      Sg = Sn,\n      gg = mg,\n      Tg = d(\"\".replace),\n      Rg = RegExp(\"^[\" + gg + \"]+\"),\n      Cg = RegExp(\"(^|[^\" + gg + \"])[\" + gg + \"]+$\"),\n      vg = function (e) {\n        return function (t) {\n          var i = Sg(fg(t));\n          return 1 & e && (i = Tg(i, Rg, \"\")), 2 & e && (i = Tg(i, Cg, \"$1\")), i;\n        };\n      },\n      yg = {\n        start: vg(1),\n        end: vg(2),\n        trim: vg(3)\n      },\n      Ig = Ra.PROPER,\n      Ag = n,\n      bg = mg,\n      wg = yg.trim;\n    Oi({\n      target: \"String\",\n      proto: !0,\n      forced: function (e) {\n        return Ag(function () {\n          return !!bg[e]() || \"âÂá \" !== \"âÂá \"[e]() || Ig && bg[e].name !== e;\n        });\n      }(\"trim\")\n    }, {\n      trim: function () {\n        return wg(this);\n      }\n    });\n    var Og = Zi(\"String\", \"trim\"),\n      Ng = l,\n      Dg = Og,\n      Pg = String.prototype,\n      Lg = function (e) {\n        var t = e.trim;\n        return \"string\" == typeof e || e === Pg || Ng(Pg, e) && t === Pg.trim ? Dg : t;\n      },\n      kg = i(Lg),\n      Mg = {\n        exports: {}\n      };\n    !function (e) {\n      const t = {\n        generateIdentifier: function () {\n          return Math.random().toString(36).substring(2, 12);\n        }\n      };\n      t.localCName = t.generateIdentifier(), t.splitLines = function (e) {\n        return e.trim().split(\"\\n\").map(e => e.trim());\n      }, t.splitSections = function (e) {\n        return e.split(\"\\nm=\").map((e, t) => (t > 0 ? \"m=\" + e : e).trim() + \"\\r\\n\");\n      }, t.getDescription = function (e) {\n        const i = t.splitSections(e);\n        return i && i[0];\n      }, t.getMediaSections = function (e) {\n        const i = t.splitSections(e);\n        return i.shift(), i;\n      }, t.matchPrefix = function (e, i) {\n        return t.splitLines(e).filter(e => 0 === e.indexOf(i));\n      }, t.parseCandidate = function (e) {\n        let t;\n        t = 0 === e.indexOf(\"a=candidate:\") ? e.substring(12).split(\" \") : e.substring(10).split(\" \");\n        const i = {\n          foundation: t[0],\n          component: {\n            1: \"rtp\",\n            2: \"rtcp\"\n          }[t[1]] || t[1],\n          protocol: t[2].toLowerCase(),\n          priority: parseInt(t[3], 10),\n          ip: t[4],\n          address: t[4],\n          port: parseInt(t[5], 10),\n          type: t[7]\n        };\n        for (let e = 8; e < t.length; e += 2) switch (t[e]) {\n          case \"raddr\":\n            i.relatedAddress = t[e + 1];\n            break;\n          case \"rport\":\n            i.relatedPort = parseInt(t[e + 1], 10);\n            break;\n          case \"tcptype\":\n            i.tcpType = t[e + 1];\n            break;\n          case \"ufrag\":\n            i.ufrag = t[e + 1], i.usernameFragment = t[e + 1];\n            break;\n          default:\n            void 0 === i[t[e]] && (i[t[e]] = t[e + 1]);\n        }\n        return i;\n      }, t.writeCandidate = function (e) {\n        const t = [];\n        t.push(e.foundation);\n        const i = e.component;\n        \"rtp\" === i ? t.push(1) : \"rtcp\" === i ? t.push(2) : t.push(i), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);\n        const n = e.type;\n        return t.push(\"typ\"), t.push(n), \"host\" !== n && e.relatedAddress && e.relatedPort && (t.push(\"raddr\"), t.push(e.relatedAddress), t.push(\"rport\"), t.push(e.relatedPort)), e.tcpType && \"tcp\" === e.protocol.toLowerCase() && (t.push(\"tcptype\"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push(\"ufrag\"), t.push(e.usernameFragment || e.ufrag)), \"candidate:\" + t.join(\" \");\n      }, t.parseIceOptions = function (e) {\n        return e.substring(14).split(\" \");\n      }, t.parseRtpMap = function (e) {\n        let t = e.substring(9).split(\" \");\n        const i = {\n          payloadType: parseInt(t.shift(), 10)\n        };\n        return t = t[0].split(\"/\"), i.name = t[0], i.clockRate = parseInt(t[1], 10), i.channels = 3 === t.length ? parseInt(t[2], 10) : 1, i.numChannels = i.channels, i;\n      }, t.writeRtpMap = function (e) {\n        let t = e.payloadType;\n        void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);\n        const i = e.channels || e.numChannels || 1;\n        return \"a=rtpmap:\" + t + \" \" + e.name + \"/\" + e.clockRate + (1 !== i ? \"/\" + i : \"\") + \"\\r\\n\";\n      }, t.parseExtmap = function (e) {\n        const t = e.substring(9).split(\" \");\n        return {\n          id: parseInt(t[0], 10),\n          direction: t[0].indexOf(\"/\") > 0 ? t[0].split(\"/\")[1] : \"sendrecv\",\n          uri: t[1],\n          attributes: t.slice(2).join(\" \")\n        };\n      }, t.writeExtmap = function (e) {\n        return \"a=extmap:\" + (e.id || e.preferredId) + (e.direction && \"sendrecv\" !== e.direction ? \"/\" + e.direction : \"\") + \" \" + e.uri + (e.attributes ? \" \" + e.attributes : \"\") + \"\\r\\n\";\n      }, t.parseFmtp = function (e) {\n        const t = {};\n        let i;\n        const n = e.substring(e.indexOf(\" \") + 1).split(\";\");\n        for (let e = 0; e < n.length; e++) i = n[e].trim().split(\"=\"), t[i[0].trim()] = i[1];\n        return t;\n      }, t.writeFmtp = function (e) {\n        let t = \"\",\n          i = e.payloadType;\n        if (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {\n          const n = [];\n          Object.keys(e.parameters).forEach(t => {\n            void 0 !== e.parameters[t] ? n.push(t + \"=\" + e.parameters[t]) : n.push(t);\n          }), t += \"a=fmtp:\" + i + \" \" + n.join(\";\") + \"\\r\\n\";\n        }\n        return t;\n      }, t.parseRtcpFb = function (e) {\n        const t = e.substring(e.indexOf(\" \") + 1).split(\" \");\n        return {\n          type: t.shift(),\n          parameter: t.join(\" \")\n        };\n      }, t.writeRtcpFb = function (e) {\n        let t = \"\",\n          i = e.payloadType;\n        return void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => {\n          t += \"a=rtcp-fb:\" + i + \" \" + e.type + (e.parameter && e.parameter.length ? \" \" + e.parameter : \"\") + \"\\r\\n\";\n        }), t;\n      }, t.parseSsrcMedia = function (e) {\n        const t = e.indexOf(\" \"),\n          i = {\n            ssrc: parseInt(e.substring(7, t), 10)\n          },\n          n = e.indexOf(\":\", t);\n        return n > -1 ? (i.attribute = e.substring(t + 1, n), i.value = e.substring(n + 1)) : i.attribute = e.substring(t + 1), i;\n      }, t.parseSsrcGroup = function (e) {\n        const t = e.substring(13).split(\" \");\n        return {\n          semantics: t.shift(),\n          ssrcs: t.map(e => parseInt(e, 10))\n        };\n      }, t.getMid = function (e) {\n        const i = t.matchPrefix(e, \"a=mid:\")[0];\n        if (i) return i.substring(6);\n      }, t.parseFingerprint = function (e) {\n        const t = e.substring(14).split(\" \");\n        return {\n          algorithm: t[0].toLowerCase(),\n          value: t[1].toUpperCase()\n        };\n      }, t.getDtlsParameters = function (e, i) {\n        return {\n          role: \"auto\",\n          fingerprints: t.matchPrefix(e + i, \"a=fingerprint:\").map(t.parseFingerprint)\n        };\n      }, t.writeDtlsParameters = function (e, t) {\n        let i = \"a=setup:\" + t + \"\\r\\n\";\n        return e.fingerprints.forEach(e => {\n          i += \"a=fingerprint:\" + e.algorithm + \" \" + e.value + \"\\r\\n\";\n        }), i;\n      }, t.parseCryptoLine = function (e) {\n        const t = e.substring(9).split(\" \");\n        return {\n          tag: parseInt(t[0], 10),\n          cryptoSuite: t[1],\n          keyParams: t[2],\n          sessionParams: t.slice(3)\n        };\n      }, t.writeCryptoLine = function (e) {\n        return \"a=crypto:\" + e.tag + \" \" + e.cryptoSuite + \" \" + (\"object\" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? \" \" + e.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n      }, t.parseCryptoKeyParams = function (e) {\n        if (0 !== e.indexOf(\"inline:\")) return null;\n        const t = e.substring(7).split(\"|\");\n        return {\n          keyMethod: \"inline\",\n          keySalt: t[0],\n          lifeTime: t[1],\n          mkiValue: t[2] ? t[2].split(\":\")[0] : void 0,\n          mkiLength: t[2] ? t[2].split(\":\")[1] : void 0\n        };\n      }, t.writeCryptoKeyParams = function (e) {\n        return e.keyMethod + \":\" + e.keySalt + (e.lifeTime ? \"|\" + e.lifeTime : \"\") + (e.mkiValue && e.mkiLength ? \"|\" + e.mkiValue + \":\" + e.mkiLength : \"\");\n      }, t.getCryptoParameters = function (e, i) {\n        return t.matchPrefix(e + i, \"a=crypto:\").map(t.parseCryptoLine);\n      }, t.getIceParameters = function (e, i) {\n        const n = t.matchPrefix(e + i, \"a=ice-ufrag:\")[0],\n          r = t.matchPrefix(e + i, \"a=ice-pwd:\")[0];\n        return n && r ? {\n          usernameFragment: n.substring(12),\n          password: r.substring(10)\n        } : null;\n      }, t.writeIceParameters = function (e) {\n        let t = \"a=ice-ufrag:\" + e.usernameFragment + \"\\r\\na=ice-pwd:\" + e.password + \"\\r\\n\";\n        return e.iceLite && (t += \"a=ice-lite\\r\\n\"), t;\n      }, t.parseRtpParameters = function (e) {\n        const i = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n          },\n          n = t.splitLines(e)[0].split(\" \");\n        i.profile = n[2];\n        for (let r = 3; r < n.length; r++) {\n          const o = n[r],\n            s = t.matchPrefix(e, \"a=rtpmap:\" + o + \" \")[0];\n          if (s) {\n            const n = t.parseRtpMap(s),\n              r = t.matchPrefix(e, \"a=fmtp:\" + o + \" \");\n            switch (n.parameters = r.length ? t.parseFmtp(r[0]) : {}, n.rtcpFeedback = t.matchPrefix(e, \"a=rtcp-fb:\" + o + \" \").map(t.parseRtcpFb), i.codecs.push(n), n.name.toUpperCase()) {\n              case \"RED\":\n              case \"ULPFEC\":\n                i.fecMechanisms.push(n.name.toUpperCase());\n            }\n          }\n        }\n        t.matchPrefix(e, \"a=extmap:\").forEach(e => {\n          i.headerExtensions.push(t.parseExtmap(e));\n        });\n        const r = t.matchPrefix(e, \"a=rtcp-fb:* \").map(t.parseRtcpFb);\n        return i.codecs.forEach(e => {\n          r.forEach(t => {\n            e.rtcpFeedback.find(e => e.type === t.type && e.parameter === t.parameter) || e.rtcpFeedback.push(t);\n          });\n        }), i;\n      }, t.writeRtpDescription = function (e, i) {\n        let n = \"\";\n        n += \"m=\" + e + \" \", n += i.codecs.length > 0 ? \"9\" : \"0\", n += \" \" + (i.profile || \"UDP/TLS/RTP/SAVPF\") + \" \", n += i.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(\" \") + \"\\r\\n\", n += \"c=IN IP4 0.0.0.0\\r\\n\", n += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\", i.codecs.forEach(e => {\n          n += t.writeRtpMap(e), n += t.writeFmtp(e), n += t.writeRtcpFb(e);\n        });\n        let r = 0;\n        return i.codecs.forEach(e => {\n          e.maxptime > r && (r = e.maxptime);\n        }), r > 0 && (n += \"a=maxptime:\" + r + \"\\r\\n\"), i.headerExtensions && i.headerExtensions.forEach(e => {\n          n += t.writeExtmap(e);\n        }), n;\n      }, t.parseRtpEncodingParameters = function (e) {\n        const i = [],\n          n = t.parseRtpParameters(e),\n          r = -1 !== n.fecMechanisms.indexOf(\"RED\"),\n          o = -1 !== n.fecMechanisms.indexOf(\"ULPFEC\"),\n          s = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute),\n          a = s.length > 0 && s[0].ssrc;\n        let c;\n        const d = t.matchPrefix(e, \"a=ssrc-group:FID\").map(e => e.substring(17).split(\" \").map(e => parseInt(e, 10)));\n        d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), n.codecs.forEach(e => {\n          if (\"RTX\" === e.name.toUpperCase() && e.parameters.apt) {\n            let t = {\n              ssrc: a,\n              codecPayloadType: parseInt(e.parameters.apt, 10)\n            };\n            a && c && (t.rtx = {\n              ssrc: c\n            }), i.push(t), r && (t = JSON.parse(JSON.stringify(t)), t.fec = {\n              ssrc: a,\n              mechanism: o ? \"red+ulpfec\" : \"red\"\n            }, i.push(t));\n          }\n        }), 0 === i.length && a && i.push({\n          ssrc: a\n        });\n        let l = t.matchPrefix(e, \"b=\");\n        return l.length && (l = 0 === l[0].indexOf(\"b=TIAS:\") ? parseInt(l[0].substring(7), 10) : 0 === l[0].indexOf(\"b=AS:\") ? 1e3 * parseInt(l[0].substring(5), 10) * .95 - 16e3 : void 0, i.forEach(e => {\n          e.maxBitrate = l;\n        })), i;\n      }, t.parseRtcpParameters = function (e) {\n        const i = {},\n          n = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute)[0];\n        n && (i.cname = n.value, i.ssrc = n.ssrc);\n        const r = t.matchPrefix(e, \"a=rtcp-rsize\");\n        i.reducedSize = r.length > 0, i.compound = 0 === r.length;\n        const o = t.matchPrefix(e, \"a=rtcp-mux\");\n        return i.mux = o.length > 0, i;\n      }, t.writeRtcpParameters = function (e) {\n        let t = \"\";\n        return e.reducedSize && (t += \"a=rtcp-rsize\\r\\n\"), e.mux && (t += \"a=rtcp-mux\\r\\n\"), void 0 !== e.ssrc && e.cname && (t += \"a=ssrc:\" + e.ssrc + \" cname:\" + e.cname + \"\\r\\n\"), t;\n      }, t.parseMsid = function (e) {\n        let i;\n        const n = t.matchPrefix(e, \"a=msid:\");\n        if (1 === n.length) return i = n[0].substring(7).split(\" \"), {\n          stream: i[0],\n          track: i[1]\n        };\n        const r = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"msid\" === e.attribute);\n        return r.length > 0 ? (i = r[0].value.split(\" \"), {\n          stream: i[0],\n          track: i[1]\n        }) : void 0;\n      }, t.parseSctpDescription = function (e) {\n        const i = t.parseMLine(e),\n          n = t.matchPrefix(e, \"a=max-message-size:\");\n        let r;\n        n.length > 0 && (r = parseInt(n[0].substring(19), 10)), isNaN(r) && (r = 65536);\n        const o = t.matchPrefix(e, \"a=sctp-port:\");\n        if (o.length > 0) return {\n          port: parseInt(o[0].substring(12), 10),\n          protocol: i.fmt,\n          maxMessageSize: r\n        };\n        const s = t.matchPrefix(e, \"a=sctpmap:\");\n        if (s.length > 0) {\n          const e = s[0].substring(10).split(\" \");\n          return {\n            port: parseInt(e[0], 10),\n            protocol: e[1],\n            maxMessageSize: r\n          };\n        }\n      }, t.writeSctpDescription = function (e, t) {\n        let i = [];\n        return i = \"DTLS/SCTP\" !== e.protocol ? [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.protocol + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctp-port:\" + t.port + \"\\r\\n\"] : [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.port + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctpmap:\" + t.port + \" \" + t.protocol + \" 65535\\r\\n\"], void 0 !== t.maxMessageSize && i.push(\"a=max-message-size:\" + t.maxMessageSize + \"\\r\\n\"), i.join(\"\");\n      }, t.generateSessionId = function () {\n        return Math.random().toString().substr(2, 22);\n      }, t.writeSessionBoilerplate = function (e, i, n) {\n        let r;\n        const o = void 0 !== i ? i : 2;\n        r = e || t.generateSessionId();\n        return \"v=0\\r\\no=\" + (n || \"thisisadapterortc\") + \" \" + r + \" \" + o + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n      }, t.getDirection = function (e, i) {\n        const n = t.splitLines(e);\n        for (let e = 0; e < n.length; e++) switch (n[e]) {\n          case \"a=sendrecv\":\n          case \"a=sendonly\":\n          case \"a=recvonly\":\n          case \"a=inactive\":\n            return n[e].substring(2);\n        }\n        return i ? t.getDirection(i) : \"sendrecv\";\n      }, t.getKind = function (e) {\n        return t.splitLines(e)[0].split(\" \")[0].substring(2);\n      }, t.isRejected = function (e) {\n        return \"0\" === e.split(\" \", 2)[1];\n      }, t.parseMLine = function (e) {\n        const i = t.splitLines(e)[0].substring(2).split(\" \");\n        return {\n          kind: i[0],\n          port: parseInt(i[1], 10),\n          protocol: i[2],\n          fmt: i.slice(3).join(\" \")\n        };\n      }, t.parseOLine = function (e) {\n        const i = t.matchPrefix(e, \"o=\")[0].substring(2).split(\" \");\n        return {\n          username: i[0],\n          sessionId: i[1],\n          sessionVersion: parseInt(i[2], 10),\n          netType: i[3],\n          addressType: i[4],\n          address: i[5]\n        };\n      }, t.isValidSDP = function (e) {\n        if (\"string\" != typeof e || 0 === e.length) return !1;\n        const i = t.splitLines(e);\n        for (let e = 0; e < i.length; e++) if (i[e].length < 2 || \"=\" !== i[e].charAt(1)) return !1;\n        return !0;\n      }, e.exports = t;\n    }(Mg);\n    var Ug = Mg.exports,\n      Vg = i(Ug),\n      xg = e({\n        __proto__: null,\n        default: Vg\n      }, [Ug]);\n    function Fg(e) {\n      if (!e.RTCIceCandidate || e.RTCIceCandidate && \"foundation\" in e.RTCIceCandidate.prototype) return;\n      const t = e.RTCIceCandidate;\n      e.RTCIceCandidate = function (e) {\n        if (\"object\" == typeof e && e.candidate && 0 === e.candidate.indexOf(\"a=\") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {\n          const i = new t(e),\n            n = Vg.parseCandidate(e.candidate),\n            r = Object.assign(i, n);\n          return r.toJSON = function () {\n            return {\n              candidate: r.candidate,\n              sdpMid: r.sdpMid,\n              sdpMLineIndex: r.sdpMLineIndex,\n              usernameFragment: r.usernameFragment\n            };\n          }, r;\n        }\n        return new t(e);\n      }, e.RTCIceCandidate.prototype = t.prototype, bS(e, \"icecandidate\", t => (t.candidate && Object.defineProperty(t, \"candidate\", {\n        value: new e.RTCIceCandidate(t.candidate),\n        writable: \"false\"\n      }), t));\n    }\n    function Bg(e) {\n      !e.RTCIceCandidate || e.RTCIceCandidate && \"relayProtocol\" in e.RTCIceCandidate.prototype || bS(e, \"icecandidate\", e => {\n        if (e.candidate) {\n          const t = Vg.parseCandidate(e.candidate.candidate);\n          \"relay\" === t.type && (e.candidate.relayProtocol = {\n            0: \"tls\",\n            1: \"tcp\",\n            2: \"udp\"\n          }[t.priority >> 24]);\n        }\n        return e;\n      });\n    }\n    function jg(e, t) {\n      if (!e.RTCPeerConnection) return;\n      \"sctp\" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, \"sctp\", {\n        get() {\n          return void 0 === this._sctp ? null : this._sctp;\n        }\n      });\n      const i = function (e) {\n          if (!e || !e.sdp) return !1;\n          const t = Vg.splitSections(e.sdp);\n          return t.shift(), t.some(e => {\n            const t = Vg.parseMLine(e);\n            return t && \"application\" === t.kind && -1 !== t.protocol.indexOf(\"SCTP\");\n          });\n        },\n        n = function (e) {\n          const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n          if (null === t || t.length < 2) return -1;\n          const i = parseInt(t[1], 10);\n          return i != i ? -1 : i;\n        },\n        r = function (e) {\n          let i = 65536;\n          return \"firefox\" === t.browser && (i = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i;\n        },\n        o = function (e, i) {\n          let n = 65536;\n          \"firefox\" === t.browser && 57 === t.version && (n = 65535);\n          const r = Vg.matchPrefix(e.sdp, \"a=max-message-size:\");\n          return r.length > 0 ? n = parseInt(r[0].substr(19), 10) : \"firefox\" === t.browser && -1 !== i && (n = 2147483637), n;\n        },\n        s = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        if (this._sctp = null, \"chrome\" === t.browser && t.version >= 76) {\n          const {\n            sdpSemantics: e\n          } = this.getConfiguration();\n          \"plan-b\" === e && Object.defineProperty(this, \"sctp\", {\n            get() {\n              return void 0 === this._sctp ? null : this._sctp;\n            },\n            enumerable: !0,\n            configurable: !0\n          });\n        }\n        if (i(arguments[0])) {\n          const e = n(arguments[0]),\n            t = r(e),\n            i = o(arguments[0], e);\n          let s;\n          s = 0 === t && 0 === i ? Number.POSITIVE_INFINITY : 0 === t || 0 === i ? Math.max(t, i) : Math.min(t, i);\n          const a = {};\n          Object.defineProperty(a, \"maxMessageSize\", {\n            get: () => s\n          }), this._sctp = a;\n        }\n        return s.apply(this, arguments);\n      };\n    }\n    function Gg(e) {\n      if (!e.RTCPeerConnection || !(\"createDataChannel\" in e.RTCPeerConnection.prototype)) return;\n      function t(e, t) {\n        const i = e.send;\n        e.send = function () {\n          const n = arguments[0],\n            r = n.length || n.size || n.byteLength;\n          if (\"open\" === e.readyState && t.sctp && r > t.sctp.maxMessageSize) throw new TypeError(\"Message too large (can send a maximum of \" + t.sctp.maxMessageSize + \" bytes)\");\n          return i.apply(e, arguments);\n        };\n      }\n      const i = e.RTCPeerConnection.prototype.createDataChannel;\n      e.RTCPeerConnection.prototype.createDataChannel = function () {\n        const e = i.apply(this, arguments);\n        return t(e, this), e;\n      }, bS(e, \"datachannel\", e => (t(e.channel, e.target), e));\n    }\n    function Wg(e) {\n      if (!e.RTCPeerConnection || \"connectionState\" in e.RTCPeerConnection.prototype) return;\n      const t = e.RTCPeerConnection.prototype;\n      Object.defineProperty(t, \"connectionState\", {\n        get() {\n          return {\n            completed: \"connected\",\n            checking: \"connecting\"\n          }[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(t, \"onconnectionstatechange\", {\n        get() {\n          return this._onconnectionstatechange || null;\n        },\n        set(e) {\n          this._onconnectionstatechange && (this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), [\"setLocalDescription\", \"setRemoteDescription\"].forEach(e => {\n        const i = t[e];\n        t[e] = function () {\n          return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {\n            const t = e.target;\n            if (t._lastConnectionState !== t.connectionState) {\n              t._lastConnectionState = t.connectionState;\n              const i = new Event(\"connectionstatechange\", e);\n              t.dispatchEvent(i);\n            }\n            return e;\n          }, this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly)), i.apply(this, arguments);\n        };\n      });\n    }\n    function Hg(e, t) {\n      if (!e.RTCPeerConnection) return;\n      if (\"chrome\" === t.browser && t.version >= 71) return;\n      if (\"safari\" === t.browser && t.version >= 605) return;\n      const i = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {\n        if (t && t.sdp && -1 !== t.sdp.indexOf(\"\\na=extmap-allow-mixed\")) {\n          const i = t.sdp.split(\"\\n\").filter(e => \"a=extmap-allow-mixed\" !== kg(e).call(e)).join(\"\\n\");\n          e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({\n            type: t.type,\n            sdp: i\n          }) : t.sdp = i;\n        }\n        return i.apply(this, arguments);\n      };\n    }\n    function Kg(e, t) {\n      if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n      const i = e.RTCPeerConnection.prototype.addIceCandidate;\n      i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () {\n        return arguments[0] ? (\"chrome\" === t.browser && t.version < 78 || \"firefox\" === t.browser && t.version < 68 || \"safari\" === t.browser) && arguments[0] && \"\" === arguments[0].candidate ? rp.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), rp.resolve());\n      });\n    }\n    function Yg(e, t) {\n      if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n      const i = e.RTCPeerConnection.prototype.setLocalDescription;\n      i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () {\n        let e = arguments[0] || {};\n        if (\"object\" != typeof e || e.type && e.sdp) return i.apply(this, arguments);\n        if (e = {\n          type: e.type,\n          sdp: e.sdp\n        }, !e.type) switch (this.signalingState) {\n          case \"stable\":\n          case \"have-local-offer\":\n          case \"have-remote-pranswer\":\n            e.type = \"offer\";\n            break;\n          default:\n            e.type = \"answer\";\n        }\n        if (e.sdp || \"offer\" !== e.type && \"answer\" !== e.type) return i.apply(this, [e]);\n        return (\"offer\" === e.type ? this.createOffer : this.createAnswer).apply(this).then(e => i.apply(this, [e]));\n      });\n    }\n    var zg = Object.freeze({\n      __proto__: null,\n      removeExtmapAllowMixed: Hg,\n      shimAddIceCandidateNullOrEmpty: Kg,\n      shimConnectionState: Wg,\n      shimMaxMessageSize: jg,\n      shimParameterlessSetLocalDescription: Yg,\n      shimRTCIceCandidate: Fg,\n      shimRTCIceCandidateRelayProtocol: Bg,\n      shimSendThrowTypeError: Gg\n    });\n    !function () {\n      let {\n          window: e\n        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n          shimChrome: !0,\n          shimFirefox: !0,\n          shimSafari: !0\n        };\n      const i = NS,\n        n = function (e) {\n          const t = {\n            browser: null,\n            version: null\n          };\n          if (void 0 === e || !e.navigator) return t.browser = \"Not a browser.\", t;\n          const {\n            navigator: i\n          } = e;\n          if (i.mozGetUserMedia) t.browser = \"firefox\", t.version = AS(i.userAgent, /Firefox\\/(\\d+)\\./, 1);else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = \"chrome\", t.version = AS(i.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);else {\n            if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) return t.browser = \"Not a supported browser.\", t;\n            t.browser = \"safari\", t.version = AS(i.userAgent, /AppleWebKit\\/(\\d+)\\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && \"currentDirection\" in e.RTCRtpTransceiver.prototype;\n          }\n          return t;\n        }(e),\n        r = {\n          browserDetails: n,\n          commonShim: zg,\n          extractVersion: AS,\n          disableLog: wS,\n          disableWarnings: OS,\n          sdp: xg\n        };\n      switch (n.browser) {\n        case \"chrome\":\n          if (!zS || !KS || !t.shimChrome) return i(\"Chrome shim is not included in this adapter release.\"), r;\n          if (null === n.version) return i(\"Chrome shim can not determine version, not shimming.\"), r;\n          i(\"adapter.js shimming chrome.\"), r.browserShim = zS, Kg(e, n), Yg(e), VS(e, n), xS(e), KS(e, n), FS(e), HS(e, n), BS(e), jS(e), GS(e), YS(e, n), Fg(e), Bg(e), Wg(e), jg(e, n), Gg(e), Hg(e, n);\n          break;\n        case \"firefox\":\n          if (!og || !JS || !t.shimFirefox) return i(\"Firefox shim is not included in this adapter release.\"), r;\n          i(\"adapter.js shimming firefox.\"), r.browserShim = og, Kg(e, n), Yg(e), qS(e, n), JS(e, n), XS(e), $S(e), QS(e), ZS(e), eg(e), tg(e), ig(e), ng(e), rg(e), Fg(e), Wg(e), jg(e, n), Gg(e);\n          break;\n        case \"safari\":\n          if (!Eg || !t.shimSafari) return i(\"Safari shim is not included in this adapter release.\"), r;\n          i(\"adapter.js shimming safari.\"), r.browserShim = Eg, Kg(e, n), Yg(e), ug(e), pg(e), cg(e), sg(e), ag(e), hg(e), dg(e), _g(e), Fg(e), Bg(e), jg(e, n), Gg(e), Hg(e, n);\n          break;\n        default:\n          i(\"Unsupported browser!\");\n      }\n    }({\n      window: true ? void 0 : window\n    });\n    var qg = n,\n      Xg = h.RegExp,\n      Jg = !qg(function () {\n        var e = !0;\n        try {\n          Xg(\".\", \"d\");\n        } catch (t) {\n          e = !1;\n        }\n        var t = {},\n          i = \"\",\n          n = e ? \"dgimsy\" : \"gimsy\",\n          r = function (e, n) {\n            Object.defineProperty(t, e, {\n              get: function () {\n                return i += n, !0;\n              }\n            });\n          },\n          o = {\n            dotAll: \"s\",\n            global: \"g\",\n            ignoreCase: \"i\",\n            multiline: \"m\",\n            sticky: \"y\"\n          };\n        for (var s in e && (o.hasIndices = \"d\"), o) r(s, o[s]);\n        return Object.getOwnPropertyDescriptor(Xg.prototype, \"flags\").get.call(t) !== n || i !== n;\n      }),\n      Qg = ni,\n      Zg = D,\n      $g = $e,\n      eT = l,\n      tT = {\n        correct: Jg\n      },\n      iT = function () {\n        var e = Qg(this),\n          t = \"\";\n        return e.hasIndices && (t += \"d\"), e.global && (t += \"g\"), e.ignoreCase && (t += \"i\"), e.multiline && (t += \"m\"), e.dotAll && (t += \"s\"), e.unicode && (t += \"u\"), e.unicodeSets && (t += \"v\"), e.sticky && (t += \"y\"), t;\n      },\n      nT = RegExp.prototype,\n      rT = tT.correct ? function (e) {\n        return e.flags;\n      } : function (e) {\n        return tT.correct || !eT(nT, e) || $g(e, \"flags\") ? e.flags : Zg(iT, e);\n      },\n      oT = d,\n      sT = Je,\n      aT = Math.floor,\n      cT = oT(\"\".charAt),\n      dT = oT(\"\".replace),\n      lT = oT(\"\".slice),\n      uT = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g,\n      hT = /\\$([$&'`]|\\d{1,2})/g,\n      pT = Oi,\n      _T = D,\n      ET = d,\n      mT = z,\n      fT = A,\n      ST = Z,\n      gT = rn,\n      TT = Sn,\n      RT = Le,\n      CT = rT,\n      vT = function (e, t, i, n, r, o) {\n        var s = i + e.length,\n          a = n.length,\n          c = hT;\n        return void 0 !== r && (r = sT(r), c = uT), dT(o, c, function (o, c) {\n          var d;\n          switch (cT(c, 0)) {\n            case \"$\":\n              return \"$\";\n            case \"&\":\n              return e;\n            case \"`\":\n              return lT(t, 0, i);\n            case \"'\":\n              return lT(t, s);\n            case \"<\":\n              d = r[lT(c, 1, -1)];\n              break;\n            default:\n              var l = +c;\n              if (0 === l) return o;\n              if (l > a) {\n                var u = aT(l / 10);\n                return 0 === u ? o : u <= a ? void 0 === n[u - 1] ? cT(c, 1) : n[u - 1] + cT(c, 1) : o;\n              }\n              d = n[l - 1];\n          }\n          return void 0 === d ? \"\" : d;\n        });\n      },\n      yT = pt(\"replace\"),\n      IT = TypeError,\n      AT = ET(\"\".indexOf),\n      bT = ET(\"\".replace),\n      wT = ET(\"\".slice),\n      OT = Math.max;\n    pT({\n      target: \"String\",\n      proto: !0\n    }, {\n      replaceAll: function (e, t) {\n        var i,\n          n,\n          r,\n          o,\n          s,\n          a,\n          c,\n          d,\n          l,\n          u,\n          h = mT(this),\n          p = 0,\n          _ = \"\";\n        if (ST(e)) {\n          if ((i = gT(e)) && (n = TT(mT(CT(e))), !~AT(n, \"g\"))) throw new IT(\"`.replaceAll` does not allow non-global regexes\");\n          if (r = RT(e, yT)) return _T(r, e, h, t);\n          if (i) return bT(TT(h), e, t);\n        }\n        for (o = TT(h), s = TT(e), (a = fT(t)) || (t = TT(t)), c = s.length, d = OT(1, c), l = AT(o, s); -1 !== l;) u = a ? TT(t(s, l, o)) : vT(s, o, l, [], void 0, t), _ += wT(o, p, l) + u, p = l + c, l = l + d > o.length ? -1 : AT(o, s, l + d);\n        return p < o.length && (_ += wT(o, p)), _;\n      }\n    });\n    var NT = Zi(\"String\", \"replaceAll\"),\n      DT = l,\n      PT = NT,\n      LT = String.prototype,\n      kT = function (e) {\n        var t = e.replaceAll;\n        return \"string\" == typeof e || e === LT || DT(LT, e) && t === LT.replaceAll ? PT : t;\n      },\n      MT = i(kT),\n      UT = h;\n    Oi({\n      global: !0,\n      forced: UT.globalThis !== UT\n    }, {\n      globalThis: UT\n    });\n    var VT = i(h),\n      xT = {\n        exports: {}\n      };\n    !function (e, i) {\n      !function (t, n) {\n        var r = \"function\",\n          o = \"undefined\",\n          s = \"object\",\n          a = \"string\",\n          c = \"major\",\n          d = \"model\",\n          l = \"name\",\n          u = \"type\",\n          h = \"vendor\",\n          p = \"version\",\n          _ = \"architecture\",\n          E = \"console\",\n          m = \"mobile\",\n          f = \"tablet\",\n          S = \"smarttv\",\n          g = \"wearable\",\n          T = \"embedded\",\n          R = \"Amazon\",\n          C = \"Apple\",\n          v = \"ASUS\",\n          y = \"BlackBerry\",\n          I = \"Browser\",\n          A = \"Chrome\",\n          b = \"Firefox\",\n          w = \"Google\",\n          O = \"Honor\",\n          N = \"Huawei\",\n          D = \"LG\",\n          P = \"Microsoft\",\n          L = \"Motorola\",\n          k = \"Nvidia\",\n          M = \"OnePlus\",\n          U = \"Opera\",\n          V = \"OPPO\",\n          x = \"Samsung\",\n          F = \"Sharp\",\n          B = \"Sony\",\n          j = \"Xiaomi\",\n          G = \"Zebra\",\n          W = \"Facebook\",\n          H = \"Chromium OS\",\n          K = \"Mac OS\",\n          Y = \" Browser\",\n          z = function (e) {\n            for (var t = {}, i = 0; i < e.length; i++) t[e[i].toUpperCase()] = e[i];\n            return t;\n          },\n          q = function (e, t) {\n            return typeof e === a && -1 !== X(t).indexOf(X(e));\n          },\n          X = function (e) {\n            return e.toLowerCase();\n          },\n          J = function (e, t) {\n            if (typeof e === a) return e = e.replace(/^\\s\\s*/, \"\"), typeof t === o ? e : e.substring(0, 500);\n          },\n          Q = function (e, t) {\n            for (var i, o, a, c, d, l, u = 0; u < t.length && !d;) {\n              var h = t[u],\n                p = t[u + 1];\n              for (i = o = 0; i < h.length && !d && h[i];) if (d = h[i++].exec(e)) for (a = 0; a < p.length; a++) l = d[++o], typeof (c = p[a]) === s && c.length > 0 ? 2 === c.length ? typeof c[1] == r ? this[c[0]] = c[1].call(this, l) : this[c[0]] = c[1] : 3 === c.length ? typeof c[1] !== r || c[1].exec && c[1].test ? this[c[0]] = l ? l.replace(c[1], c[2]) : n : this[c[0]] = l ? c[1].call(this, l, c[2]) : n : 4 === c.length && (this[c[0]] = l ? c[3].call(this, l.replace(c[1], c[2])) : n) : this[c] = l || n;\n              u += 2;\n            }\n          },\n          Z = function (e, t) {\n            for (var i in t) if (typeof t[i] === s && t[i].length > 0) {\n              for (var r = 0; r < t[i].length; r++) if (q(t[i][r], e)) return \"?\" === i ? n : i;\n            } else if (q(t[i], e)) return \"?\" === i ? n : i;\n            return t.hasOwnProperty(\"*\") ? t[\"*\"] : e;\n          },\n          $ = {\n            ME: \"4.90\",\n            \"NT 3.11\": \"NT3.51\",\n            \"NT 4.0\": \"NT4.0\",\n            2e3: \"NT 5.0\",\n            XP: [\"NT 5.1\", \"NT 5.2\"],\n            Vista: \"NT 6.0\",\n            7: \"NT 6.1\",\n            8: \"NT 6.2\",\n            8.1: \"NT 6.3\",\n            10: [\"NT 6.4\", \"NT 10.0\"],\n            RT: \"ARM\"\n          },\n          ee = {\n            browser: [[/\\b(?:crmo|crios)\\/([\\w\\.]+)/i], [p, [l, \"Chrome\"]], [/edg(?:e|ios|a)?\\/([\\w\\.]+)/i], [p, [l, \"Edge\"]], [/(opera mini)\\/([-\\w\\.]+)/i, /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i, /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i], [l, p], [/opios[\\/ ]+([\\w\\.]+)/i], [p, [l, U + \" Mini\"]], [/\\bop(?:rg)?x\\/([\\w\\.]+)/i], [p, [l, U + \" GX\"]], [/\\bopr\\/([\\w\\.]+)/i], [p, [l, U]], [/\\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\\/ ]?([\\w\\.]+)/i], [p, [l, \"Baidu\"]], [/\\b(?:mxbrowser|mxios|myie2)\\/?([-\\w\\.]*)\\b/i], [p, [l, \"Maxthon\"]], [/(kindle)\\/([\\w\\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\\/ ]?([\\w\\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\\/ ]?([\\d\\.]*)/i, /(?:ms|\\()(ie) ([\\w\\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\\/([-\\w\\.]+)/i, /(heytap|ovi|115)browser\\/([\\d\\.]+)/i, /(weibo)__([\\d\\.]+)/i], [l, p], [/quark(?:pc)?\\/([-\\w\\.]+)/i], [p, [l, \"Quark\"]], [/\\bddg\\/([\\w\\.]+)/i], [p, [l, \"DuckDuckGo\"]], [/(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i], [p, [l, \"UC\" + I]], [/microm.+\\bqbcore\\/([\\w\\.]+)/i, /\\bqbcore\\/([\\w\\.]+).+microm/i, /micromessenger\\/([\\w\\.]+)/i], [p, [l, \"WeChat\"]], [/konqueror\\/([\\w\\.]+)/i], [p, [l, \"Konqueror\"]], [/trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i], [p, [l, \"IE\"]], [/ya(?:search)?browser\\/([\\w\\.]+)/i], [p, [l, \"Yandex\"]], [/slbrowser\\/([\\w\\.]+)/i], [p, [l, \"Smart Lenovo \" + I]], [/(avast|avg)\\/([\\w\\.]+)/i], [[l, /(.+)/, \"$1 Secure \" + I], p], [/\\bfocus\\/([\\w\\.]+)/i], [p, [l, b + \" Focus\"]], [/\\bopt\\/([\\w\\.]+)/i], [p, [l, U + \" Touch\"]], [/coc_coc\\w+\\/([\\w\\.]+)/i], [p, [l, \"Coc Coc\"]], [/dolfin\\/([\\w\\.]+)/i], [p, [l, \"Dolphin\"]], [/coast\\/([\\w\\.]+)/i], [p, [l, U + \" Coast\"]], [/miuibrowser\\/([\\w\\.]+)/i], [p, [l, \"MIUI\" + Y]], [/fxios\\/([\\w\\.-]+)/i], [p, [l, b]], [/\\bqihoobrowser\\/?([\\w\\.]*)/i], [p, [l, \"360\"]], [/\\b(qq)\\/([\\w\\.]+)/i], [[l, /(.+)/, \"$1Browser\"], p], [/(oculus|sailfish|huawei|vivo|pico)browser\\/([\\w\\.]+)/i], [[l, /(.+)/, \"$1\" + Y], p], [/samsungbrowser\\/([\\w\\.]+)/i], [p, [l, x + \" Internet\"]], [/metasr[\\/ ]?([\\d\\.]+)/i], [p, [l, \"Sogou Explorer\"]], [/(sogou)mo\\w+\\/([\\d\\.]+)/i], [[l, \"Sogou Mobile\"], p], [/(electron)\\/([\\w\\.]+) safari/i, /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\\w*[\\/ ]?v?([\\w\\.]+)/i], [l, p], [/(lbbrowser|rekonq)/i, /\\[(linkedin)app\\]/i], [l], [/ome\\/([\\w\\.]+) \\w* ?(iron) saf/i, /ome\\/([\\w\\.]+).+qihu (360)[es]e/i], [p, l], [/((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i], [[l, W], p], [/(Klarna)\\/([\\w\\.]+)/i, /(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i, /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i, /(daum)apps[\\/ ]([\\w\\.]+)/i, /safari (line)\\/([\\w\\.]+)/i, /\\b(line)\\/([\\w\\.]+)\\/iab/i, /(alipay)client\\/([\\w\\.]+)/i, /(twitter)(?:and| f.+e\\/([\\w\\.]+))/i, /(chromium|instagram|snapchat)[\\/ ]([-\\w\\.]+)/i], [l, p], [/\\bgsa\\/([\\w\\.]+) .*safari\\//i], [p, [l, \"GSA\"]], [/musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i], [p, [l, \"TikTok\"]], [/headlesschrome(?:\\/([\\w\\.]+)| )/i], [p, [l, A + \" Headless\"]], [/ wv\\).+(chrome)\\/([\\w\\.]+)/i], [[l, A + \" WebView\"], p], [/droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i], [p, [l, \"Android \" + I]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i], [l, p], [/version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i], [p, [l, \"Mobile Safari\"]], [/version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i], [p, l], [/webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i], [l, [p, Z, {\n              \"1.0\": \"/8\",\n              1.2: \"/1\",\n              1.3: \"/3\",\n              \"2.0\": \"/412\",\n              \"2.0.2\": \"/416\",\n              \"2.0.3\": \"/417\",\n              \"2.0.4\": \"/419\",\n              \"?\": \"/\"\n            }]], [/(webkit|khtml)\\/([\\w\\.]+)/i], [l, p], [/(navigator|netscape\\d?)\\/([-\\w\\.]+)/i], [[l, \"Netscape\"], p], [/(wolvic|librewolf)\\/([\\w\\.]+)/i], [l, p], [/mobile vr; rv:([\\w\\.]+)\\).+firefox/i], [p, [l, b + \" Reality\"]], [/ekiohf.+(flow)\\/([\\w\\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\\/ ]?([\\w\\.\\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i, /(firefox)\\/([\\w\\.]+)/i, /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i, /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i, /\\b(links) \\(([\\w\\.]+)/i], [l, [p, /_/g, \".\"]], [/(cobalt)\\/([\\w\\.]+)/i], [l, [p, /master.|lts./, \"\"]]],\n            cpu: [[/\\b((amd|x|x86[-_]?|wow|win)64)\\b/i], [[_, \"amd64\"]], [/(ia32(?=;))/i, /\\b((i[346]|x)86)(pc)?\\b/i], [[_, \"ia32\"]], [/\\b(aarch64|arm(v?[89]e?l?|_?64))\\b/i], [[_, \"arm64\"]], [/\\b(arm(v[67])?ht?n?[fl]p?)\\b/i], [[_, \"armhf\"]], [/( (ce|mobile); ppc;|\\/[\\w\\.]+arm\\b)/i], [[_, \"arm\"]], [/((ppc|powerpc)(64)?)( mac|;|\\))/i], [[_, /ower/, \"\", X]], [/ sun4\\w[;\\)]/i], [[_, \"sparc\"]], [/\\b(avr32|ia64(?=;)|68k(?=\\))|\\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\\b|pa-risc)/i], [[_, X]]],\n            device: [[/\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d, [h, x], [u, f]], [/\\b((?:s[cgp]h|gt|sm)-(?![lr])\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\\w]+)/i, /sec-(sgh\\w+)/i], [d, [h, x], [u, m]], [/(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i], [d, [h, C], [u, m]], [/\\((ipad);[-\\w\\),; ]+apple/i, /applecoremedia\\/[\\w\\.]+ \\((ipad)/i, /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i], [d, [h, C], [u, f]], [/(macintosh);/i], [d, [h, C]], [/\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i], [d, [h, F], [u, m]], [/\\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\\)|;)/i], [d, [h, O], [u, f]], [/honor([-\\w ]+)[;\\)]/i], [d, [h, O], [u, m]], [/\\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\\w\\. ]*(?= bui|\\)))\\b(?!.+d\\/s)/i], [d, [h, N], [u, f]], [/(?:huawei)([-\\w ]+)[;\\)]/i, /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i], [d, [h, N], [u, m]], [/oid[^\\)]+; (2[\\dbc]{4}(182|283|rp\\w{2})[cgl]|m2105k81a?c)(?: bui|\\))/i, /\\b((?:red)?mi[-_ ]?pad[\\w- ]*)(?: bui|\\))/i], [[d, /_/g, \" \"], [h, j], [u, f]], [/\\b(poco[\\w ]+|m2\\d{3}j\\d\\d[a-z]{2})(?: bui|\\))/i, /\\b; (\\w+) build\\/hm\\1/i, /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i, /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i, /oid[^\\)]+; (m?[12][0-389][01]\\w{3,6}[c-y])( bui|; wv|\\))/i, /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\\))/i, / ([\\w ]+) miui\\/v?\\d/i], [[d, /_/g, \" \"], [h, j], [u, m]], [/; (\\w+) bui.+ oppo/i, /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i], [d, [h, V], [u, m]], [/\\b(opd2(\\d{3}a?))(?: bui|\\))/i], [d, [h, Z, {\n              OnePlus: [\"304\", \"403\", \"203\"],\n              \"*\": V\n            }], [u, f]], [/vivo (\\w+)(?: bui|\\))/i, /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i], [d, [h, \"Vivo\"], [u, m]], [/\\b(rmx[1-3]\\d{3})(?: bui|;|\\))/i], [d, [h, \"Realme\"], [u, m]], [/\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i, /\\bmot(?:orola)?[- ](\\w*)/i, /((?:moto(?! 360)[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i], [d, [h, L], [u, m]], [/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i], [d, [h, L], [u, f]], [/((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i], [d, [h, D], [u, f]], [/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i, /\\blg[-e;\\/ ]+((?!browser|netcast|android tv|watch)\\w+)/i, /\\blg-?([\\d\\w]+) bui/i], [d, [h, D], [u, m]], [/(ideatab[-\\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\\d{3,4}(?:f[cu]|xu|[av])|yt\\d?-[jx]?\\d+[lfmx])( bui|;|\\)|\\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\\w- ]+?)|tb[\\w-]{6,7})( bui|;|\\)|\\/)/i], [d, [h, \"Lenovo\"], [u, f]], [/(nokia) (t[12][01])/i], [h, d, [u, f]], [/(?:maemo|nokia).*(n900|lumia \\d+|rm-\\d+)/i, /nokia[-_ ]?(([-\\w\\. ]*))/i], [[d, /_/g, \" \"], [u, m], [h, \"Nokia\"]], [/(pixel (c|tablet))\\b/i], [d, [h, w], [u, f]], [/droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i], [d, [h, w], [u, m]], [/droid.+; (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i], [d, [h, B], [u, m]], [/sony tablet [ps]/i, /\\b(?:sony)?sgp\\w+(?: bui|\\))/i], [[d, \"Xperia Tablet\"], [h, B], [u, f]], [/ (kb2005|in20[12]5|be20[12][59])\\b/i, /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i], [d, [h, M], [u, m]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\\w\\w)( bui|\\))/i, /(kf[a-z]+)( bui|\\)).+silk\\//i], [d, [h, R], [u, f]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i], [[d, /(.+)/g, \"Fire Phone $1\"], [h, R], [u, m]], [/(playbook);[-\\w\\),; ]+(rim)/i], [d, h, [u, f]], [/\\b((?:bb[a-f]|st[hv])100-\\d)/i, /\\(bb10; (\\w+)/i], [d, [h, y], [u, m]], [/(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i], [d, [h, v], [u, f]], [/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i], [d, [h, v], [u, m]], [/(nexus 9)/i], [d, [h, \"HTC\"], [u, f]], [/(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i, /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i], [h, [d, /_/g, \" \"], [u, m]], [/droid [\\w\\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\\w*(\\)| bui)/i], [d, [h, \"TCL\"], [u, f]], [/(itel) ((\\w+))/i], [[h, X], d, [u, Z, {\n              tablet: [\"p10001l\", \"w7001\"],\n              \"*\": \"mobile\"\n            }]], [/droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i], [d, [h, \"Acer\"], [u, f]], [/droid.+; (m[1-5] note) bui/i, /\\bmz-([-\\w]{2,})/i], [d, [h, \"Meizu\"], [u, m]], [/; ((?:power )?armor(?:[\\w ]{0,8}))(?: bui|\\))/i], [d, [h, \"Ulefone\"], [u, m]], [/; (energy ?\\w+)(?: bui|\\))/i, /; energizer ([\\w ]+)(?: bui|\\))/i], [d, [h, \"Energizer\"], [u, m]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\\))/i], [d, [h, \"Cat\"], [u, m]], [/((?:new )?andromax[\\w- ]+)(?: bui|\\))/i], [d, [h, \"Smartfren\"], [u, m]], [/droid.+; (a(?:015|06[35]|142p?))/i], [d, [h, \"Nothing\"], [u, m]], [/; (x67 5g|tikeasy \\w+|ac[1789]\\d\\w+)( b|\\))/i, /archos ?(5|gamepad2?|([\\w ]*[t1789]|hello) ?\\d+[\\w ]*)( b|\\))/i], [d, [h, \"Archos\"], [u, f]], [/archos ([\\w ]+)( b|\\))/i, /; (ac[3-6]\\d\\w{2,8})( b|\\))/i], [d, [h, \"Archos\"], [u, m]], [/(imo) (tab \\w+)/i, /(infinix) (x1101b?)/i], [h, d, [u, f]], [/(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\\w]*)/i, /; (hmd|imo) ([\\w ]+?)(?: bui|\\))/i, /(hp) ([\\w ]+\\w)/i, /(microsoft); (lumia[\\w ]+)/i, /(lenovo)[-_ ]?([-\\w ]+?)(?: bui|\\)|\\/)/i, /(oppo) ?([\\w ]+) bui/i], [h, d, [u, m]], [/(kobo)\\s(ereader|touch)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\\/([\\w\\.]+)/i, /(nook)[\\w ]+build\\/(\\w+)/i, /(dell) (strea[kpr\\d ]*[\\dko])/i, /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i, /(trinity)[- ]*(t\\d{3}) bui/i, /(gigaset)[- ]+(q\\w{1,9}) bui/i, /(vodafone) ([\\w ]+)(?:\\)| bui)/i], [h, d, [u, f]], [/(surface duo)/i], [d, [h, P], [u, f]], [/droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i], [d, [h, \"Fairphone\"], [u, m]], [/(u304aa)/i], [d, [h, \"AT&T\"], [u, m]], [/\\bsie-(\\w*)/i], [d, [h, \"Siemens\"], [u, m]], [/\\b(rct\\w+) b/i], [d, [h, \"RCA\"], [u, f]], [/\\b(venue[\\d ]{2,7}) b/i], [d, [h, \"Dell\"], [u, f]], [/\\b(q(?:mv|ta)\\w+) b/i], [d, [h, \"Verizon\"], [u, f]], [/\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i], [d, [h, \"Barnes & Noble\"], [u, f]], [/\\b(tm\\d{3}\\w+) b/i], [d, [h, \"NuVision\"], [u, f]], [/\\b(k88) b/i], [d, [h, \"ZTE\"], [u, f]], [/\\b(nx\\d{3}j) b/i], [d, [h, \"ZTE\"], [u, m]], [/\\b(gen\\d{3}) b.+49h/i], [d, [h, \"Swiss\"], [u, m]], [/\\b(zur\\d{3}) b/i], [d, [h, \"Swiss\"], [u, f]], [/\\b((zeki)?tb.*\\b) b/i], [d, [h, \"Zeki\"], [u, f]], [/\\b([yr]\\d{2}) b/i, /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i], [[h, \"Dragon Touch\"], d, [u, f]], [/\\b(ns-?\\w{0,9}) b/i], [d, [h, \"Insignia\"], [u, f]], [/\\b((nxa|next)-?\\w{0,9}) b/i], [d, [h, \"NextBook\"], [u, f]], [/\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h, \"Voice\"], d, [u, m]], [/\\b(lvtel\\-)?(v1[12]) b/i], [[h, \"LvTel\"], d, [u, m]], [/\\b(ph-1) /i], [d, [h, \"Essential\"], [u, m]], [/\\b(v(100md|700na|7011|917g).*\\b) b/i], [d, [h, \"Envizen\"], [u, f]], [/\\b(trio[-\\w\\. ]+) b/i], [d, [h, \"MachSpeed\"], [u, f]], [/\\btu_(1491) b/i], [d, [h, \"Rotor\"], [u, f]], [/((?:tegranote|shield t(?!.+d tv))[\\w- ]*?)(?: b|\\))/i], [d, [h, k], [u, f]], [/(sprint) (\\w+)/i], [h, d, [u, m]], [/(kin\\.[onetw]{3})/i], [[d, /\\./g, \" \"], [h, P], [u, m]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i], [d, [h, G], [u, f]], [/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i], [d, [h, G], [u, m]], [/smart-tv.+(samsung)/i], [h, [u, S]], [/hbbtv.+maple;(\\d+)/i], [[d, /^/, \"SmartTV\"], [h, x], [u, S]], [/(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i], [[h, D], [u, S]], [/(apple) ?tv/i], [h, [d, C + \" TV\"], [u, S]], [/crkey/i], [[d, A + \"cast\"], [h, w], [u, S]], [/droid.+aft(\\w+)( bui|\\))/i], [d, [h, R], [u, S]], [/(shield \\w+ tv)/i], [d, [h, k], [u, S]], [/\\(dtv[\\);].+(aquos)/i, /(aquos-tv[\\w ]+)\\)/i], [d, [h, F], [u, S]], [/(bravia[\\w ]+)( bui|\\))/i], [d, [h, B], [u, S]], [/(mi(tv|box)-?\\w+) bui/i], [d, [h, j], [u, S]], [/Hbbtv.*(technisat) (.*);/i], [h, d, [u, S]], [/\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i, /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i], [[h, J], [d, J], [u, S]], [/droid.+; ([\\w- ]+) (?:android tv|smart[- ]?tv)/i], [d, [u, S]], [/\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i], [[u, S]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h, d, [u, E]], [/droid.+; (shield)( bui|\\))/i], [d, [h, k], [u, E]], [/(playstation \\w+)/i], [d, [h, B], [u, E]], [/\\b(xbox(?: one)?(?!; xbox))[\\); ]/i], [d, [h, P], [u, E]], [/\\b(sm-[lr]\\d\\d[0156][fnuw]?s?|gear live)\\b/i], [d, [h, x], [u, g]], [/((pebble))app/i, /(asus|google|lg|oppo) ((pixel |zen)?watch[\\w ]*)( bui|\\))/i], [h, d, [u, g]], [/(ow(?:19|20)?we?[1-3]{1,3})/i], [d, [h, V], [u, g]], [/(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i], [d, [h, C], [u, g]], [/(opwwe\\d{3})/i], [d, [h, M], [u, g]], [/(moto 360)/i], [d, [h, L], [u, g]], [/(smartwatch 3)/i], [d, [h, B], [u, g]], [/(g watch r)/i], [d, [h, D], [u, g]], [/droid.+; (wt63?0{2,3})\\)/i], [d, [h, G], [u, g]], [/droid.+; (glass) \\d/i], [d, [h, w], [u, g]], [/(pico) (4|neo3(?: link|pro)?)/i], [h, d, [u, g]], [/; (quest( \\d| pro)?)/i], [d, [h, W], [u, g]], [/(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i], [h, [u, T]], [/(aeobc)\\b/i], [d, [h, R], [u, T]], [/(homepod).+mac os/i], [d, [h, C], [u, T]], [/windows iot/i], [[u, T]], [/droid .+?; ([^;]+?)(?: bui|; wv\\)|\\) applew).+? mobile safari/i], [d, [u, m]], [/droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i], [d, [u, f]], [/\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i], [[u, f]], [/(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i], [[u, m]], [/droid .+?; ([\\w\\. -]+)( bui|\\))/i], [d, [h, \"Generic\"]]],\n            engine: [[/windows.+ edge\\/([\\w\\.]+)/i], [p, [l, \"EdgeHTML\"]], [/(arkweb)\\/([\\w\\.]+)/i], [l, p], [/webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i], [p, [l, \"Blink\"]], [/(presto)\\/([\\w\\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\\/([\\w\\.]+)/i, /ekioh(flow)\\/([\\w\\.]+)/i, /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i, /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i, /\\b(libweb)/i], [l, p], [/ladybird\\//i], [[l, \"LibWeb\"]], [/rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i], [p, l]],\n            os: [[/microsoft (windows) (vista|xp)/i], [l, p], [/(windows (?:phone(?: os)?|mobile|iot))[\\/ ]?([\\d\\.\\w ]*)/i], [l, [p, Z, $]], [/windows nt 6\\.2; (arm)/i, /windows[\\/ ]([ntce\\d\\. ]+\\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i], [[p, Z, $], [l, \"Windows\"]], [/[adehimnop]{4,7}\\b(?:.*os ([\\w]+) like mac|; opera)/i, /(?:ios;fbsv\\/|iphone.+ios[\\/ ])([\\d\\.]+)/i, /cfnetwork\\/.+darwin/i], [[p, /_/g, \".\"], [l, \"iOS\"]], [/(mac os x) ?([\\w\\. ]*)/i, /(macintosh|mac_powerpc\\b)(?!.+haiku)/i], [[l, K], [p, /_/g, \".\"]], [/droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i], [p, l], [/(ubuntu) ([\\w\\.]+) like android/i], [[l, /(.+)/, \"$1 Touch\"], p], [/(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\\w*[-\\/; ]?([\\d\\.]*)/i], [l, p], [/\\(bb(10);/i], [p, [l, y]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\\/ ]?([\\w\\.]*)/i], [p, [l, \"Symbian\"]], [/mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i], [p, [l, b + \" OS\"]], [/web0s;.+rt(tv)/i, /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i], [p, [l, \"webOS\"]], [/watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i], [p, [l, \"watchOS\"]], [/crkey\\/([\\d\\.]+)/i], [p, [l, A + \"cast\"]], [/(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i], [[l, H], p], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\\/(\\d+\\.[\\w\\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\\);]+)/i, /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i, /(mint)[\\/\\(\\) ]?(\\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i, /(hurd|linux)(?: arm\\w*| x86\\w*| ?)([\\w\\.]*)/i, /(gnu) ?([\\w\\.]*)/i, /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, /(haiku) (\\w+)/i], [l, p], [/(sunos) ?([\\w\\.\\d]*)/i], [[l, \"Solaris\"], p], [/((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i, /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i, /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\\w\\.]*)/i], [l, p]]\n          },\n          te = function (e, i) {\n            if (typeof e === s && (i = e, e = n), !(this instanceof te)) return new te(e, i).getResult();\n            var E = typeof t !== o && t.navigator ? t.navigator : n,\n              S = e || (E && E.userAgent ? E.userAgent : \"\"),\n              g = E && E.userAgentData ? E.userAgentData : n,\n              T = i ? function (e, t) {\n                var i = {};\n                for (var n in e) t[n] && t[n].length % 2 == 0 ? i[n] = t[n].concat(e[n]) : i[n] = e[n];\n                return i;\n              }(ee, i) : ee,\n              R = E && E.userAgent == S;\n            return this.getBrowser = function () {\n              var e = {};\n              return e[l] = n, e[p] = n, Q.call(e, S, T.browser), e[c] = function (e) {\n                return typeof e === a ? e.replace(/[^\\d\\.]/g, \"\").split(\".\")[0] : n;\n              }(e[p]), R && E && E.brave && typeof E.brave.isBrave == r && (e[l] = \"Brave\"), e;\n            }, this.getCPU = function () {\n              var e = {};\n              return e[_] = n, Q.call(e, S, T.cpu), e;\n            }, this.getDevice = function () {\n              var e = {};\n              return e[h] = n, e[d] = n, e[u] = n, Q.call(e, S, T.device), R && !e[u] && g && g.mobile && (e[u] = m), R && \"Macintosh\" == e[d] && E && typeof E.standalone !== o && E.maxTouchPoints && E.maxTouchPoints > 2 && (e[d] = \"iPad\", e[u] = f), e;\n            }, this.getEngine = function () {\n              var e = {};\n              return e[l] = n, e[p] = n, Q.call(e, S, T.engine), e;\n            }, this.getOS = function () {\n              var e = {};\n              return e[l] = n, e[p] = n, Q.call(e, S, T.os), R && !e[l] && g && g.platform && \"Unknown\" != g.platform && (e[l] = g.platform.replace(/chrome os/i, H).replace(/macos/i, K)), e;\n            }, this.getResult = function () {\n              return {\n                ua: this.getUA(),\n                browser: this.getBrowser(),\n                engine: this.getEngine(),\n                os: this.getOS(),\n                device: this.getDevice(),\n                cpu: this.getCPU()\n              };\n            }, this.getUA = function () {\n              return S;\n            }, this.setUA = function (e) {\n              return S = typeof e === a && e.length > 500 ? J(e, 500) : e, this;\n            }, this.setUA(S), this;\n          };\n        te.VERSION = \"0.7.41\", te.BROWSER = z([l, p, c]), te.CPU = z([_]), te.DEVICE = z([d, h, u, E, m, S, f, g, T]), te.ENGINE = te.OS = z([l, p]), e.exports && (i = e.exports = te), i.UAParser = te;\n        var ie = typeof t !== o && (t.jQuery || t.Zepto);\n        if (ie && !ie.ua) {\n          var ne = new te();\n          ie.ua = ne.getResult(), ie.ua.get = function () {\n            return ne.getUA();\n          }, ie.ua.set = function (e) {\n            ne.setUA(e);\n            var t = ne.getResult();\n            for (var i in t) ie.ua[i] = t[i];\n          };\n        }\n      }(false ? window : t);\n    }(xT, xT.exports);\n    var FT = i(xT.exports),\n      BT = Ud.clear;\n    Oi({\n      global: !0,\n      bind: !0,\n      enumerable: !0,\n      forced: h.clearImmediate !== BT\n    }, {\n      clearImmediate: BT\n    });\n    var jT = h,\n      GT = f,\n      WT = A,\n      HT = qn,\n      KT = ae,\n      YT = sd,\n      zT = cd,\n      qT = jT.Function,\n      XT = /MSIE .\\./.test(KT) || \"BUN\" === HT && function () {\n        var e = jT.Bun.version.split(\".\");\n        return e.length < 3 || \"0\" === e[0] && (e[1] < 3 || \"3\" === e[1] && \"0\" === e[2]);\n      }(),\n      JT = Oi,\n      QT = h,\n      ZT = Ud.set,\n      $T = function (e, t) {\n        var i = t ? 2 : 1;\n        return XT ? function (n, r) {\n          var o = zT(arguments.length, 1) > i,\n            s = WT(n) ? n : qT(n),\n            a = o ? YT(arguments, i) : [],\n            c = o ? function () {\n              GT(s, this, a);\n            } : s;\n          return t ? e(c, r) : e(c);\n        } : e;\n      },\n      eR = QT.setImmediate ? $T(ZT, !1) : ZT;\n    JT({\n      global: !0,\n      bind: !0,\n      enumerable: !0,\n      forced: QT.setImmediate !== eR\n    }, {\n      setImmediate: eR\n    });\n    var tR = i($.setImmediate),\n      iR = h,\n      nR = hl,\n      rR = Ne,\n      oR = cd,\n      sR = w;\n    Oi({\n      global: !0,\n      enumerable: !0,\n      dontCallGetSet: !0,\n      forced: n(function () {\n        return sR && 1 !== Object.getOwnPropertyDescriptor(iR, \"queueMicrotask\").value.length;\n      })\n    }, {\n      queueMicrotask: function (e) {\n        oR(arguments.length, 1), nR(rR(e));\n      }\n    });\n    var aR = i($.queueMicrotask);\n    function cR(e, t) {\n      return function () {\n        return e.apply(t, arguments);\n      };\n    }\n    const {\n        toString: dR\n      } = Object.prototype,\n      {\n        getPrototypeOf: lR\n      } = Object,\n      {\n        iterator: uR,\n        toStringTag: hR\n      } = Symbol,\n      pR = (_R = Object.create(null), e => {\n        const t = dR.call(e);\n        return _R[t] || (_R[t] = t.slice(8, -1).toLowerCase());\n      });\n    var _R;\n    const ER = e => (e = e.toLowerCase(), t => pR(t) === e),\n      mR = e => t => typeof t === e,\n      {\n        isArray: fR\n      } = Array,\n      SR = mR(\"undefined\");\n    function gR(e) {\n      return null !== e && !SR(e) && null !== e.constructor && !SR(e.constructor) && CR(e.constructor.isBuffer) && e.constructor.isBuffer(e);\n    }\n    const TR = ER(\"ArrayBuffer\");\n    const RR = mR(\"string\"),\n      CR = mR(\"function\"),\n      vR = mR(\"number\"),\n      yR = e => null !== e && \"object\" == typeof e,\n      IR = e => {\n        if (\"object\" !== pR(e)) return !1;\n        const t = lR(e);\n        return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || hR in e || uR in e);\n      },\n      AR = ER(\"Date\"),\n      bR = ER(\"File\"),\n      wR = ER(\"Blob\"),\n      OR = ER(\"FileList\"),\n      NR = ER(\"URLSearchParams\"),\n      [DR, PR, LR, kR] = [\"ReadableStream\", \"Request\", \"Response\", \"Headers\"].map(ER);\n    function MR(e, t) {\n      let i,\n        n,\n        {\n          allOwnKeys: r = !1\n        } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n      if (null != e) if (\"object\" != typeof e && (e = [e]), fR(e)) for (i = 0, n = e.length; i < n; i++) t.call(null, e[i], i, e);else {\n        if (gR(e)) return;\n        const n = r ? Object.getOwnPropertyNames(e) : Object.keys(e),\n          o = n.length;\n        let s;\n        for (i = 0; i < o; i++) s = n[i], t.call(null, e[s], s, e);\n      }\n    }\n    function UR(e, t) {\n      if (gR(e)) return null;\n      t = t.toLowerCase();\n      const i = Object.keys(e);\n      let n,\n        r = i.length;\n      for (; r-- > 0;) if (n = i[r], t === n.toLowerCase()) return n;\n      return null;\n    }\n    const VR = void 0 !== VT ? VT : \"undefined\" != typeof self ? self : false ? window : global,\n      xR = e => !SR(e) && e !== VR;\n    const FR = (BR = \"undefined\" != typeof Uint8Array && lR(Uint8Array), e => BR && e instanceof BR);\n    var BR;\n    const jR = ER(\"HTMLFormElement\"),\n      GR = (e => {\n        let {\n          hasOwnProperty: t\n        } = e;\n        return (e, i) => t.call(e, i);\n      })(Object.prototype),\n      WR = ER(\"RegExp\"),\n      HR = (e, t) => {\n        const i = Object.getOwnPropertyDescriptors(e),\n          n = {};\n        MR(i, (i, r) => {\n          let o;\n          !1 !== (o = t(i, r, e)) && (n[r] = o || i);\n        }), Object.defineProperties(e, n);\n      };\n    const KR = ER(\"AsyncFunction\"),\n      YR = (zR = \"function\" == typeof tR, qR = CR(VR.postMessage), zR ? tR : qR ? (XR = \"axios@\".concat(Math.random()), JR = [], VR.addEventListener(\"message\", e => {\n        let {\n          source: t,\n          data: i\n        } = e;\n        t === VR && i === XR && JR.length && JR.shift()();\n      }, !1), e => {\n        JR.push(e), VR.postMessage(XR, \"*\");\n      }) : e => setTimeout(e));\n    var zR, qR, XR, JR;\n    const QR = void 0 !== aR ? aR.bind(VR) : \"undefined\" != typeof process && process.nextTick || YR;\n    var ZR = {\n      isArray: fR,\n      isArrayBuffer: TR,\n      isBuffer: gR,\n      isFormData: e => {\n        let t;\n        return e && (\"function\" == typeof FormData && e instanceof FormData || CR(e.append) && (\"formdata\" === (t = pR(e)) || \"object\" === t && CR(e.toString) && \"[object FormData]\" === e.toString()));\n      },\n      isArrayBufferView: function (e) {\n        let t;\n        return t = \"undefined\" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && TR(e.buffer), t;\n      },\n      isString: RR,\n      isNumber: vR,\n      isBoolean: e => !0 === e || !1 === e,\n      isObject: yR,\n      isPlainObject: IR,\n      isEmptyObject: e => {\n        if (!yR(e) || gR(e)) return !1;\n        try {\n          return 0 === Object.keys(e).length && Object.getPrototypeOf(e) === Object.prototype;\n        } catch (e) {\n          return !1;\n        }\n      },\n      isReadableStream: DR,\n      isRequest: PR,\n      isResponse: LR,\n      isHeaders: kR,\n      isUndefined: SR,\n      isDate: AR,\n      isFile: bR,\n      isBlob: wR,\n      isRegExp: WR,\n      isFunction: CR,\n      isStream: e => yR(e) && CR(e.pipe),\n      isURLSearchParams: NR,\n      isTypedArray: FR,\n      isFileList: OR,\n      forEach: MR,\n      merge: function e() {\n        const {\n            caseless: t,\n            skipUndefined: i\n          } = xR(this) && this || {},\n          n = {},\n          r = (r, o) => {\n            const s = t && UR(n, o) || o;\n            IR(n[s]) && IR(r) ? n[s] = e(n[s], r) : IR(r) ? n[s] = e({}, r) : fR(r) ? n[s] = r.slice() : i && SR(r) || (n[s] = r);\n          };\n        for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && MR(arguments[e], r);\n        return n;\n      },\n      extend: function (e, t, i) {\n        let {\n          allOwnKeys: n\n        } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};\n        return MR(t, (t, n) => {\n          i && CR(t) ? e[n] = cR(t, i) : e[n] = t;\n        }, {\n          allOwnKeys: n\n        }), e;\n      },\n      trim: e => kg(e) ? kg(e).call(e) : e.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\"),\n      stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),\n      inherits: (e, t, i, n) => {\n        e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, \"super\", {\n          value: t.prototype\n        }), i && Object.assign(e.prototype, i);\n      },\n      toFlatObject: (e, t, i, n) => {\n        let r, o, s;\n        const a = {};\n        if (t = t || {}, null == e) return t;\n        do {\n          for (r = Object.getOwnPropertyNames(e), o = r.length; o-- > 0;) s = r[o], n && !n(s, e, t) || a[s] || (t[s] = e[s], a[s] = !0);\n          e = !1 !== i && lR(e);\n        } while (e && (!i || i(e, t)) && e !== Object.prototype);\n        return t;\n      },\n      kindOf: pR,\n      kindOfTest: ER,\n      endsWith: (e, t, i) => {\n        e = String(e), (void 0 === i || i > e.length) && (i = e.length), i -= t.length;\n        const n = e.indexOf(t, i);\n        return -1 !== n && n === i;\n      },\n      toArray: e => {\n        if (!e) return null;\n        if (fR(e)) return e;\n        let t = e.length;\n        if (!vR(t)) return null;\n        const i = new Array(t);\n        for (; t-- > 0;) i[t] = e[t];\n        return i;\n      },\n      forEachEntry: (e, t) => {\n        const i = (e && e[uR]).call(e);\n        let n;\n        for (; (n = i.next()) && !n.done;) {\n          const i = n.value;\n          t.call(e, i[0], i[1]);\n        }\n      },\n      matchAll: (e, t) => {\n        let i;\n        const n = [];\n        for (; null !== (i = e.exec(t));) n.push(i);\n        return n;\n      },\n      isHTMLForm: jR,\n      hasOwnProperty: GR,\n      hasOwnProp: GR,\n      reduceDescriptors: HR,\n      freezeMethods: e => {\n        HR(e, (t, i) => {\n          if (CR(e) && -1 !== [\"arguments\", \"caller\", \"callee\"].indexOf(i)) return !1;\n          const n = e[i];\n          CR(n) && (t.enumerable = !1, \"writable\" in t ? t.writable = !1 : t.set || (t.set = () => {\n            throw Error(\"Can not rewrite read-only method '\" + i + \"'\");\n          }));\n        });\n      },\n      toObjectSet: (e, t) => {\n        const i = {},\n          n = e => {\n            e.forEach(e => {\n              i[e] = !0;\n            });\n          };\n        return fR(e) ? n(e) : n(String(e).split(t)), i;\n      },\n      toCamelCase: e => e.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function (e, t, i) {\n        return t.toUpperCase() + i;\n      }),\n      noop: () => {},\n      toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t,\n      findKey: UR,\n      global: VR,\n      isContextDefined: xR,\n      isSpecCompliantForm: function (e) {\n        return !!(e && CR(e.append) && \"FormData\" === e[hR] && e[uR]);\n      },\n      toJSONObject: e => {\n        const t = new Array(10),\n          i = (e, n) => {\n            if (yR(e)) {\n              if (t.indexOf(e) >= 0) return;\n              if (gR(e)) return e;\n              if (!(\"toJSON\" in e)) {\n                t[n] = e;\n                const r = fR(e) ? [] : {};\n                return MR(e, (e, t) => {\n                  const o = i(e, n + 1);\n                  !SR(o) && (r[t] = o);\n                }), t[n] = void 0, r;\n              }\n            }\n            return e;\n          };\n        return i(e, 0);\n      },\n      isAsyncFn: KR,\n      isThenable: e => e && (yR(e) || CR(e)) && CR(e.then) && CR(e.catch),\n      setImmediate: YR,\n      asap: QR,\n      isIterable: e => null != e && CR(e[uR])\n    };\n    function $R(e, t, i, n, r) {\n      Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = \"AxiosError\", t && (this.code = t), i && (this.config = i), n && (this.request = n), r && (this.response = r, this.status = r.status ? r.status : null);\n    }\n    ZR.inherits($R, Error, {\n      toJSON: function () {\n        return {\n          message: this.message,\n          name: this.name,\n          description: this.description,\n          number: this.number,\n          fileName: this.fileName,\n          lineNumber: this.lineNumber,\n          columnNumber: this.columnNumber,\n          stack: this.stack,\n          config: ZR.toJSONObject(this.config),\n          code: this.code,\n          status: this.status\n        };\n      }\n    });\n    const eC = $R.prototype,\n      tC = {};\n    [\"ERR_BAD_OPTION_VALUE\", \"ERR_BAD_OPTION\", \"ECONNABORTED\", \"ETIMEDOUT\", \"ERR_NETWORK\", \"ERR_FR_TOO_MANY_REDIRECTS\", \"ERR_DEPRECATED\", \"ERR_BAD_RESPONSE\", \"ERR_BAD_REQUEST\", \"ERR_CANCELED\", \"ERR_NOT_SUPPORT\", \"ERR_INVALID_URL\"].forEach(e => {\n      tC[e] = {\n        value: e\n      };\n    }), Object.defineProperties($R, tC), Object.defineProperty(eC, \"isAxiosError\", {\n      value: !0\n    }), $R.from = (e, t, i, n, r, o) => {\n      const s = Object.create(eC);\n      ZR.toFlatObject(e, s, function (e) {\n        return e !== Error.prototype;\n      }, e => \"isAxiosError\" !== e);\n      const a = e && e.message ? e.message : \"Error\",\n        c = null == t && e ? e.code : t;\n      return $R.call(s, a, c, i, n, r), e && null == s.cause && Object.defineProperty(s, \"cause\", {\n        value: e,\n        configurable: !0\n      }), s.name = e && e.name || \"Error\", o && Object.assign(s, o), s;\n    };\n    function iC(e) {\n      return ZR.isPlainObject(e) || ZR.isArray(e);\n    }\n    function nC(e) {\n      return ZR.endsWith(e, \"[]\") ? e.slice(0, -2) : e;\n    }\n    function rC(e, t, i) {\n      return e ? e.concat(t).map(function (e, t) {\n        return e = nC(e), !i && t ? \"[\" + e + \"]\" : e;\n      }).join(i ? \".\" : \"\") : t;\n    }\n    const oC = ZR.toFlatObject(ZR, {}, null, function (e) {\n      return /^is[A-Z]/.test(e);\n    });\n    function sC(e, t, i) {\n      if (!ZR.isObject(e)) throw new TypeError(\"target must be an object\");\n      t = t || new FormData();\n      const n = (i = ZR.toFlatObject(i, {\n          metaTokens: !0,\n          dots: !1,\n          indexes: !1\n        }, !1, function (e, t) {\n          return !ZR.isUndefined(t[e]);\n        })).metaTokens,\n        r = i.visitor || d,\n        o = i.dots,\n        s = i.indexes,\n        a = (i.Blob || \"undefined\" != typeof Blob && Blob) && ZR.isSpecCompliantForm(t);\n      if (!ZR.isFunction(r)) throw new TypeError(\"visitor must be a function\");\n      function c(e) {\n        if (null === e) return \"\";\n        if (ZR.isDate(e)) return e.toISOString();\n        if (ZR.isBoolean(e)) return e.toString();\n        if (!a && ZR.isBlob(e)) throw new $R(\"Blob is not supported. Use a Buffer instead.\");\n        return ZR.isArrayBuffer(e) || ZR.isTypedArray(e) ? a && \"function\" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e;\n      }\n      function d(e, i, r) {\n        let a = e;\n        if (e && !r && \"object\" == typeof e) if (ZR.endsWith(i, \"{}\")) i = n ? i : i.slice(0, -2), e = JSON.stringify(e);else if (ZR.isArray(e) && function (e) {\n          return ZR.isArray(e) && !e.some(iC);\n        }(e) || (ZR.isFileList(e) || ZR.endsWith(i, \"[]\")) && (a = ZR.toArray(e))) return i = nC(i), a.forEach(function (e, n) {\n          !ZR.isUndefined(e) && null !== e && t.append(!0 === s ? rC([i], n, o) : null === s ? i : i + \"[]\", c(e));\n        }), !1;\n        return !!iC(e) || (t.append(rC(r, i, o), c(e)), !1);\n      }\n      const l = [],\n        u = Object.assign(oC, {\n          defaultVisitor: d,\n          convertValue: c,\n          isVisitable: iC\n        });\n      if (!ZR.isObject(e)) throw new TypeError(\"data must be an object\");\n      return function e(i, n) {\n        if (!ZR.isUndefined(i)) {\n          if (-1 !== l.indexOf(i)) throw Error(\"Circular reference detected in \" + n.join(\".\"));\n          l.push(i), ZR.forEach(i, function (i, o) {\n            !0 === (!(ZR.isUndefined(i) || null === i) && r.call(t, i, ZR.isString(o) ? kg(o).call(o) : o, n, u)) && e(i, n ? n.concat(o) : [o]);\n          }), l.pop();\n        }\n      }(e), t;\n    }\n    function aC(e) {\n      const t = {\n        \"!\": \"%21\",\n        \"'\": \"%27\",\n        \"(\": \"%28\",\n        \")\": \"%29\",\n        \"~\": \"%7E\",\n        \"%20\": \"+\",\n        \"%00\": \"\\0\"\n      };\n      return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) {\n        return t[e];\n      });\n    }\n    function cC(e, t) {\n      this._pairs = [], e && sC(e, this, t);\n    }\n    const dC = cC.prototype;\n    function lC(e) {\n      return encodeURIComponent(e).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\");\n    }\n    function uC(e, t, i) {\n      if (!t) return e;\n      const n = i && i.encode || lC;\n      ZR.isFunction(i) && (i = {\n        serialize: i\n      });\n      const r = i && i.serialize;\n      let o;\n      if (o = r ? r(t, i) : ZR.isURLSearchParams(t) ? t.toString() : new cC(t, i).toString(n), o) {\n        const t = e.indexOf(\"#\");\n        -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf(\"?\") ? \"?\" : \"&\") + o;\n      }\n      return e;\n    }\n    dC.append = function (e, t) {\n      this._pairs.push([e, t]);\n    }, dC.toString = function (e) {\n      const t = e ? function (t) {\n        return e.call(this, t, aC);\n      } : aC;\n      return this._pairs.map(function (e) {\n        return t(e[0]) + \"=\" + t(e[1]);\n      }, \"\").join(\"&\");\n    };\n    var hC = class {\n        constructor() {\n          this.handlers = [];\n        }\n        use(e, t, i) {\n          return this.handlers.push({\n            fulfilled: e,\n            rejected: t,\n            synchronous: !!i && i.synchronous,\n            runWhen: i ? i.runWhen : null\n          }), this.handlers.length - 1;\n        }\n        eject(e) {\n          this.handlers[e] && (this.handlers[e] = null);\n        }\n        clear() {\n          this.handlers && (this.handlers = []);\n        }\n        forEach(e) {\n          ZR.forEach(this.handlers, function (t) {\n            null !== t && e(t);\n          });\n        }\n      },\n      pC = {\n        silentJSONParsing: !0,\n        forcedJSONParsing: !0,\n        clarifyTimeoutError: !1\n      },\n      _C = {\n        exports: {}\n      },\n      EC = Oi,\n      mC = w,\n      fC = Zt.f;\n    EC({\n      target: \"Object\",\n      stat: !0,\n      forced: Object.defineProperty !== fC,\n      sham: !mC\n    }, {\n      defineProperty: fC\n    });\n    var SC = $.Object,\n      gC = _C.exports = function (e, t, i) {\n        return SC.defineProperty(e, t, i);\n      };\n    SC.defineProperty.sham && (gC.sham = !0);\n    var TC = i(_C.exports),\n      RC = TypeError,\n      CC = or,\n      vC = Qc,\n      yC = Z,\n      IC = pt(\"species\"),\n      AC = Array,\n      bC = function (e) {\n        var t;\n        return CC(e) && (t = e.constructor, (vC(t) && (t === AC || CC(t.prototype)) || yC(t) && null === (t = t[IC])) && (t = void 0)), void 0 === t ? AC : t;\n      },\n      wC = function (e, t) {\n        return new (bC(e))(0 === t ? 0 : t);\n      },\n      OC = n,\n      NC = _e,\n      DC = pt(\"species\"),\n      PC = function (e) {\n        return NC >= 51 || !OC(function () {\n          var t = [];\n          return (t.constructor = {})[DC] = function () {\n            return {\n              foo: 1\n            };\n          }, 1 !== t[e](Boolean).foo;\n        });\n      },\n      LC = Oi,\n      kC = n,\n      MC = or,\n      UC = Z,\n      VC = Je,\n      xC = Wi,\n      FC = function (e) {\n        if (e > 9007199254740991) throw RC(\"Maximum allowed index exceeded\");\n        return e;\n      },\n      BC = qE,\n      jC = wC,\n      GC = PC,\n      WC = _e,\n      HC = pt(\"isConcatSpreadable\"),\n      KC = WC >= 51 || !kC(function () {\n        var e = [];\n        return e[HC] = !1, e.concat()[0] !== e;\n      }),\n      YC = function (e) {\n        if (!UC(e)) return !1;\n        var t = e[HC];\n        return void 0 !== t ? !!t : MC(e);\n      };\n    LC({\n      target: \"Array\",\n      proto: !0,\n      arity: 1,\n      forced: !KC || !GC(\"concat\")\n    }, {\n      concat: function (e) {\n        var t,\n          i,\n          n,\n          r,\n          o,\n          s = VC(this),\n          a = jC(s, 0),\n          c = 0;\n        for (t = -1, n = arguments.length; t < n; t++) if (YC(o = -1 === t ? s : arguments[t])) for (r = xC(o), FC(c + r), i = 0; i < r; i++, c++) i in o && BC(a, c, o[i]);else FC(c + 1), BC(a, c++, o);\n        return a.length = c, a;\n      }\n    });\n    var zC = {},\n      qC = R,\n      XC = J,\n      JC = Br.f,\n      QC = sd,\n      ZC = false && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n    zC.f = function (e) {\n      return ZC && \"Window\" === qC(e) ? function (e) {\n        try {\n          return JC(e);\n        } catch (e) {\n          return QC(ZC);\n        }\n      }(e) : JC(XC(e));\n    };\n    var $C = {},\n      ev = pt;\n    $C.f = ev;\n    var tv = $,\n      iv = $e,\n      nv = $C,\n      rv = Zt.f,\n      ov = function (e) {\n        var t = tv.Symbol || (tv.Symbol = {});\n        iv(t, e) || rv(t, e, {\n          value: nv.f(e)\n        });\n      },\n      sv = D,\n      av = re,\n      cv = pt,\n      dv = va,\n      lv = function () {\n        var e = av(\"Symbol\"),\n          t = e && e.prototype,\n          i = t && t.valueOf,\n          n = cv(\"toPrimitive\");\n        t && !t[n] && dv(t, n, function (e) {\n          return sv(i, this);\n        }, {\n          arity: 1\n        });\n      },\n      uv = Qt,\n      hv = W,\n      pv = Je,\n      _v = Wi,\n      Ev = wC,\n      mv = d([].push),\n      fv = function (e) {\n        var t = 1 === e,\n          i = 2 === e,\n          n = 3 === e,\n          r = 4 === e,\n          o = 6 === e,\n          s = 7 === e,\n          a = 5 === e || o;\n        return function (c, d, l, u) {\n          for (var h, p, _ = pv(c), E = hv(_), m = _v(E), f = uv(d, l), S = 0, g = u || Ev, T = t ? g(c, m) : i || s ? g(c, 0) : void 0; m > S; S++) if ((a || S in E) && (p = f(h = E[S], S, _), e)) if (t) T[S] = p;else if (p) switch (e) {\n            case 3:\n              return !0;\n            case 5:\n              return h;\n            case 6:\n              return S;\n            case 2:\n              mv(T, h);\n          } else switch (e) {\n            case 4:\n              return !1;\n            case 7:\n              mv(T, h);\n          }\n          return o ? -1 : n || r ? r : T;\n        };\n      },\n      Sv = {\n        forEach: fv(0),\n        map: fv(1),\n        filter: fv(2),\n        some: fv(3),\n        every: fv(4),\n        find: fv(5),\n        findIndex: fv(6),\n        filterReject: fv(7)\n      },\n      gv = Oi,\n      Tv = h,\n      Rv = D,\n      Cv = d,\n      vv = w,\n      yv = Se,\n      Iv = n,\n      Av = $e,\n      bv = l,\n      wv = ni,\n      Ov = J,\n      Nv = vt,\n      Dv = Sn,\n      Pv = x,\n      Lv = ko,\n      kv = ho,\n      Mv = Br,\n      Uv = zC,\n      Vv = Qr,\n      xv = b,\n      Fv = Zt,\n      Bv = co,\n      jv = P,\n      Gv = va,\n      Wv = vc,\n      Hv = ze,\n      Kv = jr,\n      Yv = rt,\n      zv = pt,\n      qv = $C,\n      Xv = ov,\n      Jv = lv,\n      Qv = Ga,\n      Zv = Ea,\n      $v = Sv.forEach,\n      ey = gr(\"hidden\"),\n      ty = \"Symbol\",\n      iy = \"prototype\",\n      ny = Zv.set,\n      ry = Zv.getterFor(ty),\n      oy = Object[iy],\n      sy = Tv.Symbol,\n      ay = sy && sy[iy],\n      cy = Tv.RangeError,\n      dy = Tv.TypeError,\n      ly = Tv.QObject,\n      uy = xv.f,\n      hy = Fv.f,\n      py = Uv.f,\n      _y = jv.f,\n      Ey = Cv([].push),\n      my = Hv(\"symbols\"),\n      fy = Hv(\"op-symbols\"),\n      Sy = Hv(\"wks\"),\n      gy = !ly || !ly[iy] || !ly[iy].findChild,\n      Ty = function (e, t, i) {\n        var n = uy(oy, t);\n        n && delete oy[t], hy(e, t, i), n && e !== oy && hy(oy, t, n);\n      },\n      Ry = vv && Iv(function () {\n        return 7 !== Lv(hy({}, \"a\", {\n          get: function () {\n            return hy(this, \"a\", {\n              value: 7\n            }).a;\n          }\n        })).a;\n      }) ? Ty : hy,\n      Cy = function (e, t) {\n        var i = my[e] = Lv(ay);\n        return ny(i, {\n          type: ty,\n          tag: e,\n          description: t\n        }), vv || (i.description = t), i;\n      },\n      vy = function (e, t, i) {\n        e === oy && vy(fy, t, i), wv(e);\n        var n = Nv(t);\n        return wv(i), Av(my, n) ? (i.enumerable ? (Av(e, ey) && e[ey][n] && (e[ey][n] = !1), i = Lv(i, {\n          enumerable: Pv(0, !1)\n        })) : (Av(e, ey) || hy(e, ey, Pv(1, Lv(null))), e[ey][n] = !0), Ry(e, n, i)) : hy(e, n, i);\n      },\n      yy = function (e, t) {\n        wv(e);\n        var i = Ov(t),\n          n = kv(i).concat(wy(i));\n        return $v(n, function (t) {\n          vv && !Rv(Iy, i, t) || vy(e, t, i[t]);\n        }), e;\n      },\n      Iy = function (e) {\n        var t = Nv(e),\n          i = Rv(_y, this, t);\n        return !(this === oy && Av(my, t) && !Av(fy, t)) && (!(i || !Av(this, t) || !Av(my, t) || Av(this, ey) && this[ey][t]) || i);\n      },\n      Ay = function (e, t) {\n        var i = Ov(e),\n          n = Nv(t);\n        if (i !== oy || !Av(my, n) || Av(fy, n)) {\n          var r = uy(i, n);\n          return !r || !Av(my, n) || Av(i, ey) && i[ey][n] || (r.enumerable = !0), r;\n        }\n      },\n      by = function (e) {\n        var t = py(Ov(e)),\n          i = [];\n        return $v(t, function (e) {\n          Av(my, e) || Av(Kv, e) || Ey(i, e);\n        }), i;\n      },\n      wy = function (e) {\n        var t = e === oy,\n          i = py(t ? fy : Ov(e)),\n          n = [];\n        return $v(i, function (e) {\n          !Av(my, e) || t && !Av(oy, e) || Ey(n, my[e]);\n        }), n;\n      };\n    yv || (sy = function () {\n      if (bv(ay, this)) throw new dy(\"Symbol is not a constructor\");\n      var e = arguments.length && void 0 !== arguments[0] ? Dv(arguments[0]) : void 0,\n        t = Yv(e),\n        i = function (e) {\n          var n = void 0 === this ? Tv : this;\n          n === oy && Rv(i, fy, e), Av(n, ey) && Av(n[ey], t) && (n[ey][t] = !1);\n          var r = Pv(1, e);\n          try {\n            Ry(n, t, r);\n          } catch (e) {\n            if (!(e instanceof cy)) throw e;\n            Ty(n, t, r);\n          }\n        };\n      return vv && gy && Ry(oy, t, {\n        configurable: !0,\n        set: i\n      }), Cy(t, e);\n    }, Gv(ay = sy[iy], \"toString\", function () {\n      return ry(this).tag;\n    }), Gv(sy, \"withoutSetter\", function (e) {\n      return Cy(Yv(e), e);\n    }), jv.f = Iy, Fv.f = vy, Bv.f = yy, xv.f = Ay, Mv.f = Uv.f = by, Vv.f = wy, qv.f = function (e) {\n      return Cy(zv(e), e);\n    }, vv && Wv(ay, \"description\", {\n      configurable: !0,\n      get: function () {\n        return ry(this).description;\n      }\n    })), gv({\n      global: !0,\n      constructor: !0,\n      wrap: !0,\n      forced: !yv,\n      sham: !yv\n    }, {\n      Symbol: sy\n    }), $v(kv(Sy), function (e) {\n      Xv(e);\n    }), gv({\n      target: ty,\n      stat: !0,\n      forced: !yv\n    }, {\n      useSetter: function () {\n        gy = !0;\n      },\n      useSimple: function () {\n        gy = !1;\n      }\n    }), gv({\n      target: \"Object\",\n      stat: !0,\n      forced: !yv,\n      sham: !vv\n    }, {\n      create: function (e, t) {\n        return void 0 === t ? Lv(e) : yy(Lv(e), t);\n      },\n      defineProperty: vy,\n      defineProperties: yy,\n      getOwnPropertyDescriptor: Ay\n    }), gv({\n      target: \"Object\",\n      stat: !0,\n      forced: !yv\n    }, {\n      getOwnPropertyNames: by\n    }), Jv(), Qv(sy, ty), Kv[ey] = !0;\n    var Oy = Se && !!Symbol.for && !!Symbol.keyFor,\n      Ny = Oi,\n      Dy = re,\n      Py = $e,\n      Ly = Sn,\n      ky = ze,\n      My = Oy,\n      Uy = ky(\"string-to-symbol-registry\"),\n      Vy = ky(\"symbol-to-string-registry\");\n    Ny({\n      target: \"Symbol\",\n      stat: !0,\n      forced: !My\n    }, {\n      for: function (e) {\n        var t = Ly(e);\n        if (Py(Uy, t)) return Uy[t];\n        var i = Dy(\"Symbol\")(t);\n        return Uy[t] = i, Vy[i] = t, i;\n      }\n    });\n    var xy = Oi,\n      Fy = $e,\n      By = ye,\n      jy = Ae,\n      Gy = Oy,\n      Wy = ze(\"symbol-to-string-registry\");\n    xy({\n      target: \"Symbol\",\n      stat: !0,\n      forced: !Gy\n    }, {\n      keyFor: function (e) {\n        if (!By(e)) throw new TypeError(jy(e) + \" is not a symbol\");\n        if (Fy(Wy, e)) return Wy[e];\n      }\n    });\n    var Hy = or,\n      Ky = A,\n      Yy = R,\n      zy = Sn,\n      qy = d([].push),\n      Xy = Oi,\n      Jy = re,\n      Qy = f,\n      Zy = D,\n      $y = d,\n      eI = n,\n      tI = A,\n      iI = ye,\n      nI = sd,\n      rI = function (e) {\n        if (Ky(e)) return e;\n        if (Hy(e)) {\n          for (var t = e.length, i = [], n = 0; n < t; n++) {\n            var r = e[n];\n            \"string\" == typeof r ? qy(i, r) : \"number\" != typeof r && \"Number\" !== Yy(r) && \"String\" !== Yy(r) || qy(i, zy(r));\n          }\n          var o = i.length,\n            s = !0;\n          return function (e, t) {\n            if (s) return s = !1, t;\n            if (Hy(this)) return t;\n            for (var n = 0; n < o; n++) if (i[n] === e) return t;\n          };\n        }\n      },\n      oI = Se,\n      sI = String,\n      aI = Jy(\"JSON\", \"stringify\"),\n      cI = $y(/./.exec),\n      dI = $y(\"\".charAt),\n      lI = $y(\"\".charCodeAt),\n      uI = $y(\"\".replace),\n      hI = $y(1.1.toString),\n      pI = /[\\uD800-\\uDFFF]/g,\n      _I = /^[\\uD800-\\uDBFF]$/,\n      EI = /^[\\uDC00-\\uDFFF]$/,\n      mI = !oI || eI(function () {\n        var e = Jy(\"Symbol\")(\"stringify detection\");\n        return \"[null]\" !== aI([e]) || \"{}\" !== aI({\n          a: e\n        }) || \"{}\" !== aI(Object(e));\n      }),\n      fI = eI(function () {\n        return '\"\\\\udf06\\\\ud834\"' !== aI(\"\\udf06\\ud834\") || '\"\\\\udead\"' !== aI(\"\\udead\");\n      }),\n      SI = function (e, t) {\n        var i = nI(arguments),\n          n = rI(t);\n        if (tI(n) || void 0 !== e && !iI(e)) return i[1] = function (e, t) {\n          if (tI(n) && (t = Zy(n, this, sI(e), t)), !iI(t)) return t;\n        }, Qy(aI, null, i);\n      },\n      gI = function (e, t, i) {\n        var n = dI(i, t - 1),\n          r = dI(i, t + 1);\n        return cI(_I, e) && !cI(EI, r) || cI(EI, e) && !cI(_I, n) ? \"\\\\u\" + hI(lI(e, 0), 16) : e;\n      };\n    aI && Xy({\n      target: \"JSON\",\n      stat: !0,\n      arity: 3,\n      forced: mI || fI\n    }, {\n      stringify: function (e, t, i) {\n        var n = nI(arguments),\n          r = Qy(mI ? SI : aI, null, n);\n        return fI && \"string\" == typeof r ? uI(r, pI, gI) : r;\n      }\n    });\n    var TI = Qr,\n      RI = Je;\n    Oi({\n      target: \"Object\",\n      stat: !0,\n      forced: !Se || n(function () {\n        TI.f(1);\n      })\n    }, {\n      getOwnPropertySymbols: function (e) {\n        var t = TI.f;\n        return t ? t(RI(e)) : [];\n      }\n    }), ov(\"asyncDispose\"), ov(\"asyncIterator\"), ov(\"dispose\"), ov(\"hasInstance\"), ov(\"isConcatSpreadable\"), ov(\"iterator\"), ov(\"match\"), ov(\"matchAll\"), ov(\"replace\"), ov(\"search\"), ov(\"species\"), ov(\"split\");\n    var CI = lv;\n    ov(\"toPrimitive\"), CI();\n    var vI = re,\n      yI = Ga;\n    ov(\"toStringTag\"), yI(vI(\"Symbol\"), \"Symbol\"), ov(\"unscopables\"), Ga(h.JSON, \"JSON\", !0);\n    var II = $.Symbol,\n      AI = pt,\n      bI = Zt.f,\n      wI = AI(\"metadata\"),\n      OI = Function.prototype;\n    void 0 === OI[wI] && bI(OI, wI, {\n      value: null\n    }), ov(\"metadata\");\n    var NI = II,\n      DI = d,\n      PI = re(\"Symbol\"),\n      LI = PI.keyFor,\n      kI = DI(PI.prototype.valueOf),\n      MI = PI.isRegisteredSymbol || function (e) {\n        try {\n          return void 0 !== LI(kI(e));\n        } catch (e) {\n          return !1;\n        }\n      };\n    Oi({\n      target: \"Symbol\",\n      stat: !0\n    }, {\n      isRegisteredSymbol: MI\n    });\n    for (var UI = ze, VI = re, xI = d, FI = ye, BI = pt, jI = VI(\"Symbol\"), GI = jI.isWellKnownSymbol, WI = VI(\"Object\", \"getOwnPropertyNames\"), HI = xI(jI.prototype.valueOf), KI = UI(\"wks\"), YI = 0, zI = WI(jI), qI = zI.length; YI < qI; YI++) try {\n      var XI = zI[YI];\n      FI(jI[XI]) && BI(XI);\n    } catch (e) {}\n    var JI = function (e) {\n      if (GI && GI(e)) return !0;\n      try {\n        for (var t = HI(e), i = 0, n = WI(KI), r = n.length; i < r; i++) if (KI[n[i]] == t) return !0;\n      } catch (e) {}\n      return !1;\n    };\n    Oi({\n      target: \"Symbol\",\n      stat: !0,\n      forced: !0\n    }, {\n      isWellKnownSymbol: JI\n    }), ov(\"customMatcher\"), ov(\"observable\"), Oi({\n      target: \"Symbol\",\n      stat: !0,\n      name: \"isRegisteredSymbol\"\n    }, {\n      isRegistered: MI\n    }), Oi({\n      target: \"Symbol\",\n      stat: !0,\n      name: \"isWellKnownSymbol\",\n      forced: !0\n    }, {\n      isWellKnown: JI\n    }), ov(\"matcher\"), ov(\"metadataKey\"), ov(\"patternMatch\"), ov(\"replaceAll\");\n    var QI = i(NI),\n      ZI = i($C.f(\"iterator\"));\n    function $I(e) {\n      return $I = \"function\" == typeof QI && \"symbol\" == typeof ZI ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof QI && e.constructor === QI && e !== QI.prototype ? \"symbol\" : typeof e;\n      }, $I(e);\n    }\n    var eA = i($C.f(\"toPrimitive\"));\n    function tA(e) {\n      var t = function (e, t) {\n        if (\"object\" != $I(e) || !e) return e;\n        var i = e[eA];\n        if (void 0 !== i) {\n          var n = i.call(e, t || \"default\");\n          if (\"object\" != $I(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === t ? String : Number)(e);\n      }(e, \"string\");\n      return \"symbol\" == $I(t) ? t : t + \"\";\n    }\n    function iA(e, t, i) {\n      return (t = tA(t)) in e ? TC(e, t, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = i, e;\n    }\n    var nA = i(OE),\n      rA = {\n        isBrowser: !0,\n        classes: {\n          URLSearchParams: void 0 !== nA ? nA : cC,\n          FormData: \"undefined\" != typeof FormData ? FormData : null,\n          Blob: \"undefined\" != typeof Blob ? Blob : null\n        },\n        protocols: [\"http\", \"https\", \"file\", \"blob\", \"url\", \"data\"]\n      };\n    const oA = false && \"undefined\" != typeof document,\n      sA = \"object\" == typeof navigator && navigator || void 0,\n      aA = oA && (!sA || [\"ReactNative\", \"NativeScript\", \"NS\"].indexOf(sA.product) < 0),\n      cA = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && \"function\" == typeof self.importScripts,\n      dA = oA && window.location.href || \"http://localhost\";\n    function lA(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function uA(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? lA(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : lA(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    var hA = uA(uA({}, Object.freeze({\n      __proto__: null,\n      hasBrowserEnv: oA,\n      hasStandardBrowserEnv: aA,\n      hasStandardBrowserWebWorkerEnv: cA,\n      navigator: sA,\n      origin: dA\n    })), rA);\n    function pA(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function _A(e, t) {\n      return sC(e, new hA.classes.URLSearchParams(), function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var i = null != arguments[t] ? arguments[t] : {};\n          t % 2 ? pA(Object(i), !0).forEach(function (t) {\n            iA(e, t, i[t]);\n          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : pA(Object(i)).forEach(function (t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n          });\n        }\n        return e;\n      }({\n        visitor: function (e, t, i, n) {\n          return hA.isNode && ZR.isBuffer(e) ? (this.append(t, e.toString(\"base64\")), !1) : n.defaultVisitor.apply(this, arguments);\n        }\n      }, t));\n    }\n    var EA = Gh.charAt,\n      mA = D,\n      fA = ni,\n      SA = A,\n      gA = R,\n      TA = /./.exec,\n      RA = TypeError,\n      CA = Oi,\n      vA = D,\n      yA = y,\n      IA = Xa,\n      AA = pc,\n      bA = z,\n      wA = ji,\n      OA = Sn,\n      NA = ni,\n      DA = Z,\n      PA = R,\n      LA = rn,\n      kA = rT,\n      MA = Le,\n      UA = n,\n      VA = od,\n      xA = function (e, t, i) {\n        return t + (i ? EA(e, t).length : 1);\n      },\n      FA = function (e, t) {\n        var i = e.exec;\n        if (SA(i)) {\n          var n = mA(i, e, t);\n          return null !== n && fA(n), n;\n        }\n        if (\"RegExp\" === gA(e)) return mA(TA, e, t);\n        throw new RA(\"RegExp#exec called on incompatible receiver\");\n      },\n      BA = Ea,\n      jA = pt(\"matchAll\"),\n      GA = \"RegExp String\",\n      WA = GA + \" Iterator\",\n      HA = BA.set,\n      KA = BA.getterFor(WA),\n      YA = TypeError,\n      zA = yA(\"\".indexOf),\n      qA = yA(\"\".matchAll),\n      XA = !!qA && !UA(function () {\n        qA(\"a\", /./);\n      }),\n      JA = IA(function (e, t, i, n) {\n        HA(this, {\n          type: WA,\n          regexp: e,\n          string: t,\n          global: i,\n          unicode: n,\n          done: !1\n        });\n      }, GA, function () {\n        var e = KA(this);\n        if (e.done) return AA(void 0, !0);\n        var t = e.regexp,\n          i = e.string,\n          n = FA(t, i);\n        return null === n ? (e.done = !0, AA(void 0, !0)) : e.global ? (\"\" === OA(n[0]) && (t.lastIndex = xA(i, wA(t.lastIndex), e.unicode)), AA(n, !1)) : (e.done = !0, AA(n, !1));\n      }),\n      QA = function (e) {\n        var t,\n          i,\n          n,\n          r = NA(this),\n          o = OA(e),\n          s = VA(r, RegExp),\n          a = OA(kA(r));\n        return t = new s(s === RegExp ? r.source : r, a), i = !!~zA(a, \"g\"), n = !!~zA(a, \"u\"), t.lastIndex = wA(r.lastIndex), new JA(t, o, i, n);\n      };\n    CA({\n      target: \"String\",\n      proto: !0,\n      forced: XA\n    }, {\n      matchAll: function (e) {\n        var t,\n          i,\n          n,\n          r,\n          o = bA(this);\n        if (DA(e)) {\n          if (LA(e) && (t = OA(bA(kA(e))), !~zA(t, \"g\"))) throw new YA(\"`.matchAll` does not allow non-global regexes\");\n          if (XA) return qA(o, e);\n          if (void 0 === (n = MA(e, jA)) && \"RegExp\" === PA(e) && (n = QA), n) return vA(n, e, o);\n        } else if (XA) return qA(o, e);\n        return i = OA(o), r = new RegExp(e, \"g\"), vA(QA, r, i);\n      }\n    });\n    var ZA = Zi(\"String\", \"matchAll\"),\n      $A = l,\n      eb = ZA,\n      tb = String.prototype,\n      ib = function (e) {\n        var t = e.matchAll;\n        return \"string\" == typeof e || e === tb || $A(tb, e) && t === tb.matchAll ? eb : t;\n      },\n      nb = i(ib);\n    function rb(e) {\n      function t(e, i, n, r) {\n        let o = e[r++];\n        if (\"__proto__\" === o) return !0;\n        const s = Number.isFinite(+o),\n          a = r >= e.length;\n        if (o = !o && ZR.isArray(n) ? n.length : o, a) return ZR.hasOwnProp(n, o) ? n[o] = [n[o], i] : n[o] = i, !s;\n        n[o] && ZR.isObject(n[o]) || (n[o] = []);\n        return t(e, i, n[o], r) && ZR.isArray(n[o]) && (n[o] = function (e) {\n          const t = {},\n            i = Object.keys(e);\n          let n;\n          const r = i.length;\n          let o;\n          for (n = 0; n < r; n++) o = i[n], t[o] = e[o];\n          return t;\n        }(n[o])), !s;\n      }\n      if (ZR.isFormData(e) && ZR.isFunction(e.entries)) {\n        const i = {};\n        return ZR.forEachEntry(e, (e, n) => {\n          t(function (e) {\n            return nb(ZR).call(ZR, /\\w+|\\[(\\w*)]/g, e).map(e => \"[]\" === e[0] ? \"\" : e[1] || e[0]);\n          }(e), n, i, 0);\n        }), i;\n      }\n      return null;\n    }\n    const ob = {\n      transitional: pC,\n      adapter: [\"xhr\", \"http\", \"fetch\"],\n      transformRequest: [function (e, t) {\n        const i = t.getContentType() || \"\",\n          n = i.indexOf(\"application/json\") > -1,\n          r = ZR.isObject(e);\n        r && ZR.isHTMLForm(e) && (e = new FormData(e));\n        if (ZR.isFormData(e)) return n ? JSON.stringify(rb(e)) : e;\n        if (ZR.isArrayBuffer(e) || ZR.isBuffer(e) || ZR.isStream(e) || ZR.isFile(e) || ZR.isBlob(e) || ZR.isReadableStream(e)) return e;\n        if (ZR.isArrayBufferView(e)) return e.buffer;\n        if (ZR.isURLSearchParams(e)) return t.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", !1), e.toString();\n        let o;\n        if (r) {\n          if (i.indexOf(\"application/x-www-form-urlencoded\") > -1) return _A(e, this.formSerializer).toString();\n          if ((o = ZR.isFileList(e)) || i.indexOf(\"multipart/form-data\") > -1) {\n            const t = this.env && this.env.FormData;\n            return sC(o ? {\n              \"files[]\": e\n            } : e, t && new t(), this.formSerializer);\n          }\n        }\n        return r || n ? (t.setContentType(\"application/json\", !1), function (e, t, i) {\n          if (ZR.isString(e)) try {\n            return (t || JSON.parse)(e), kg(ZR).call(ZR, e);\n          } catch (e) {\n            if (\"SyntaxError\" !== e.name) throw e;\n          }\n          return (i || JSON.stringify)(e);\n        }(e)) : e;\n      }],\n      transformResponse: [function (e) {\n        const t = this.transitional || ob.transitional,\n          i = t && t.forcedJSONParsing,\n          n = \"json\" === this.responseType;\n        if (ZR.isResponse(e) || ZR.isReadableStream(e)) return e;\n        if (e && ZR.isString(e) && (i && !this.responseType || n)) {\n          const i = !(t && t.silentJSONParsing) && n;\n          try {\n            return JSON.parse(e, this.parseReviver);\n          } catch (e) {\n            if (i) {\n              if (\"SyntaxError\" === e.name) throw $R.from(e, $R.ERR_BAD_RESPONSE, this, null, this.response);\n              throw e;\n            }\n          }\n        }\n        return e;\n      }],\n      timeout: 0,\n      xsrfCookieName: \"XSRF-TOKEN\",\n      xsrfHeaderName: \"X-XSRF-TOKEN\",\n      maxContentLength: -1,\n      maxBodyLength: -1,\n      env: {\n        FormData: hA.classes.FormData,\n        Blob: hA.classes.Blob\n      },\n      validateStatus: function (e) {\n        return e >= 200 && e < 300;\n      },\n      headers: {\n        common: {\n          Accept: \"application/json, text/plain, */*\",\n          \"Content-Type\": void 0\n        }\n      }\n    };\n    ZR.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\"], e => {\n      ob.headers[e] = {};\n    });\n    var sb = ob;\n    const ab = ZR.toObjectSet([\"age\", \"authorization\", \"content-length\", \"content-type\", \"etag\", \"expires\", \"from\", \"host\", \"if-modified-since\", \"if-unmodified-since\", \"last-modified\", \"location\", \"max-forwards\", \"proxy-authorization\", \"referer\", \"retry-after\", \"user-agent\"]);\n    const cb = Symbol(\"internals\");\n    function db(e) {\n      var t;\n      return e && kg(t = String(e)).call(t).toLowerCase();\n    }\n    function lb(e) {\n      return !1 === e || null == e ? e : ZR.isArray(e) ? e.map(lb) : String(e);\n    }\n    function ub(e, t, i, n, r) {\n      return ZR.isFunction(n) ? n.call(this, t, i) : (r && (t = i), ZR.isString(t) ? ZR.isString(n) ? -1 !== t.indexOf(n) : ZR.isRegExp(n) ? n.test(t) : void 0 : void 0);\n    }\n    class hb {\n      constructor(e) {\n        e && this.set(e);\n      }\n      set(e, t, i) {\n        const n = this;\n        function r(e, t, i) {\n          const r = db(t);\n          if (!r) throw new Error(\"header name must be a non-empty string\");\n          const o = ZR.findKey(n, r);\n          (!o || void 0 === n[o] || !0 === i || void 0 === i && !1 !== n[o]) && (n[o || t] = lb(e));\n        }\n        const o = (e, t) => ZR.forEach(e, (e, i) => r(e, i, t));\n        if (ZR.isPlainObject(e) || e instanceof this.constructor) o(e, t);else if (ZR.isString(e) && (e = kg(e).call(e)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(kg(s = e).call(s))) o((e => {\n          const t = {};\n          let i, n, r;\n          return e && e.split(\"\\n\").forEach(function (e) {\n            var o, s;\n            r = e.indexOf(\":\"), i = kg(o = e.substring(0, r)).call(o).toLowerCase(), n = kg(s = e.substring(r + 1)).call(s), !i || t[i] && ab[i] || (\"set-cookie\" === i ? t[i] ? t[i].push(n) : t[i] = [n] : t[i] = t[i] ? t[i] + \", \" + n : n);\n          }), t;\n        })(e), t);else if (ZR.isObject(e) && ZR.isIterable(e)) {\n          let i,\n            n,\n            r = {};\n          for (const t of e) {\n            if (!ZR.isArray(t)) throw TypeError(\"Object iterator must return a key-value pair\");\n            r[n = t[0]] = (i = r[n]) ? ZR.isArray(i) ? [...i, t[1]] : [i, t[1]] : t[1];\n          }\n          o(r, t);\n        } else null != e && r(t, e, i);\n        var s;\n        return this;\n      }\n      get(e, t) {\n        if (e = db(e)) {\n          const i = ZR.findKey(this, e);\n          if (i) {\n            const e = this[i];\n            if (!t) return e;\n            if (!0 === t) return function (e) {\n              const t = Object.create(null),\n                i = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n              let n;\n              for (; n = i.exec(e);) t[n[1]] = n[2];\n              return t;\n            }(e);\n            if (ZR.isFunction(t)) return t.call(this, e, i);\n            if (ZR.isRegExp(t)) return t.exec(e);\n            throw new TypeError(\"parser must be boolean|regexp|function\");\n          }\n        }\n      }\n      has(e, t) {\n        if (e = db(e)) {\n          const i = ZR.findKey(this, e);\n          return !(!i || void 0 === this[i] || t && !ub(0, this[i], i, t));\n        }\n        return !1;\n      }\n      delete(e, t) {\n        const i = this;\n        let n = !1;\n        function r(e) {\n          if (e = db(e)) {\n            const r = ZR.findKey(i, e);\n            !r || t && !ub(0, i[r], r, t) || (delete i[r], n = !0);\n          }\n        }\n        return ZR.isArray(e) ? e.forEach(r) : r(e), n;\n      }\n      clear(e) {\n        const t = Object.keys(this);\n        let i = t.length,\n          n = !1;\n        for (; i--;) {\n          const r = t[i];\n          e && !ub(0, this[r], r, e, !0) || (delete this[r], n = !0);\n        }\n        return n;\n      }\n      normalize(e) {\n        const t = this,\n          i = {};\n        return ZR.forEach(this, (n, r) => {\n          var o;\n          const s = ZR.findKey(i, r);\n          if (s) return t[s] = lb(n), void delete t[r];\n          const a = e ? function (e) {\n            return kg(e).call(e).toLowerCase().replace(/([a-z\\d])(\\w*)/g, (e, t, i) => t.toUpperCase() + i);\n          }(r) : kg(o = String(r)).call(o);\n          a !== r && delete t[r], t[a] = lb(n), i[a] = !0;\n        }), this;\n      }\n      concat() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        return this.constructor.concat(this, ...t);\n      }\n      toJSON(e) {\n        const t = Object.create(null);\n        return ZR.forEach(this, (i, n) => {\n          null != i && !1 !== i && (t[n] = e && ZR.isArray(i) ? i.join(\", \") : i);\n        }), t;\n      }\n      [Symbol.iterator]() {\n        return Object.entries(this.toJSON())[Symbol.iterator]();\n      }\n      toString() {\n        return Object.entries(this.toJSON()).map(e => {\n          let [t, i] = e;\n          return t + \": \" + i;\n        }).join(\"\\n\");\n      }\n      getSetCookie() {\n        return this.get(\"set-cookie\") || [];\n      }\n      get [Symbol.toStringTag]() {\n        return \"AxiosHeaders\";\n      }\n      static from(e) {\n        return e instanceof this ? e : new this(e);\n      }\n      static concat(e) {\n        const t = new this(e);\n        for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n        return n.forEach(e => t.set(e)), t;\n      }\n      static accessor(e) {\n        const t = (this[cb] = this[cb] = {\n            accessors: {}\n          }).accessors,\n          i = this.prototype;\n        function n(e) {\n          const n = db(e);\n          t[n] || (!function (e, t) {\n            const i = ZR.toCamelCase(\" \" + t);\n            [\"get\", \"set\", \"has\"].forEach(n => {\n              Object.defineProperty(e, n + i, {\n                value: function (e, i, r) {\n                  return this[n].call(this, t, e, i, r);\n                },\n                configurable: !0\n              });\n            });\n          }(i, e), t[n] = !0);\n        }\n        return ZR.isArray(e) ? e.forEach(n) : n(e), this;\n      }\n    }\n    hb.accessor([\"Content-Type\", \"Content-Length\", \"Accept\", \"Accept-Encoding\", \"User-Agent\", \"Authorization\"]), ZR.reduceDescriptors(hb.prototype, (e, t) => {\n      let {\n          value: i\n        } = e,\n        n = t[0].toUpperCase() + t.slice(1);\n      return {\n        get: () => i,\n        set(e) {\n          this[n] = e;\n        }\n      };\n    }), ZR.freezeMethods(hb);\n    var pb = hb;\n    function _b(e, t) {\n      const i = this || sb,\n        n = t || i,\n        r = pb.from(n.headers);\n      let o = n.data;\n      return ZR.forEach(e, function (e) {\n        o = e.call(i, o, r.normalize(), t ? t.status : void 0);\n      }), r.normalize(), o;\n    }\n    function Eb(e) {\n      return !(!e || !e.__CANCEL__);\n    }\n    function mb(e, t, i) {\n      $R.call(this, null == e ? \"canceled\" : e, $R.ERR_CANCELED, t, i), this.name = \"CanceledError\";\n    }\n    function fb(e, t, i) {\n      const n = i.config.validateStatus;\n      i.status && n && !n(i.status) ? t(new $R(\"Request failed with status code \" + i.status, [$R.ERR_BAD_REQUEST, $R.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i)) : e(i);\n    }\n    ZR.inherits(mb, $R, {\n      __CANCEL__: !0\n    });\n    const Sb = function (e, t) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3,\n          n = 0;\n        const r = function (e, t) {\n          e = e || 10;\n          const i = new Array(e),\n            n = new Array(e);\n          let r,\n            o = 0,\n            s = 0;\n          return t = void 0 !== t ? t : 1e3, function (a) {\n            const c = Date.now(),\n              d = n[s];\n            r || (r = c), i[o] = a, n[o] = c;\n            let l = s,\n              u = 0;\n            for (; l !== o;) u += i[l++], l %= e;\n            if (o = (o + 1) % e, o === s && (s = (s + 1) % e), c - r < t) return;\n            const h = d && c - d;\n            return h ? Math.round(1e3 * u / h) : void 0;\n          };\n        }(50, 250);\n        return function (e, t) {\n          let i,\n            n,\n            r = 0,\n            o = 1e3 / t;\n          const s = function (t) {\n            let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();\n            r = o, i = null, n && (clearTimeout(n), n = null), e(...t);\n          };\n          return [function () {\n            const e = Date.now(),\n              t = e - r;\n            for (var a = arguments.length, c = new Array(a), d = 0; d < a; d++) c[d] = arguments[d];\n            t >= o ? s(c, e) : (i = c, n || (n = setTimeout(() => {\n              n = null, s(i);\n            }, o - t)));\n          }, () => i && s(i)];\n        }(i => {\n          const o = i.loaded,\n            s = i.lengthComputable ? i.total : void 0,\n            a = o - n,\n            c = r(a);\n          n = o;\n          e({\n            loaded: o,\n            total: s,\n            progress: s ? o / s : void 0,\n            bytes: a,\n            rate: c || void 0,\n            estimated: c && s && o <= s ? (s - o) / c : void 0,\n            event: i,\n            lengthComputable: null != s,\n            [t ? \"download\" : \"upload\"]: !0\n          });\n        }, i);\n      },\n      gb = (e, t) => {\n        const i = null != e;\n        return [n => t[0]({\n          lengthComputable: i,\n          total: e,\n          loaded: n\n        }), t[1]];\n      },\n      Tb = e => function () {\n        for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++) i[n] = arguments[n];\n        return ZR.asap(() => e(...i));\n      };\n    var Rb = hA.hasStandardBrowserEnv ? ((e, t) => i => (i = new vS(i, hA.origin), e.protocol === i.protocol && e.host === i.host && (t || e.port === i.port)))(new vS(hA.origin), hA.navigator && /(msie|trident)/i.test(hA.navigator.userAgent)) : () => !0,\n      Cb = hA.hasStandardBrowserEnv ? {\n        write(e, t, i, n, r, o, s) {\n          if (\"undefined\" == typeof document) return;\n          const a = [\"\".concat(e, \"=\").concat(encodeURIComponent(t))];\n          ZR.isNumber(i) && a.push(\"expires=\".concat(new Date(i).toUTCString())), ZR.isString(n) && a.push(\"path=\".concat(n)), ZR.isString(r) && a.push(\"domain=\".concat(r)), !0 === o && a.push(\"secure\"), ZR.isString(s) && a.push(\"SameSite=\".concat(s)), document.cookie = a.join(\"; \");\n        },\n        read(e) {\n          if (\"undefined\" == typeof document) return null;\n          const t = document.cookie.match(new RegExp(\"(?:^|; )\" + e + \"=([^;]*)\"));\n          return t ? decodeURIComponent(t[1]) : null;\n        },\n        remove(e) {\n          this.write(e, \"\", Date.now() - 864e5, \"/\");\n        }\n      } : {\n        write() {},\n        read: () => null,\n        remove() {}\n      };\n    function vb(e, t, i) {\n      let n = !function (e) {\n        return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(e);\n      }(t);\n      return e && (n || 0 == i) ? function (e, t) {\n        return t ? e.replace(/\\/?\\/$/, \"\") + \"/\" + t.replace(/^\\/+/, \"\") : e;\n      }(e, t) : t;\n    }\n    function yb(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function Ib(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? yb(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : yb(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    const Ab = e => e instanceof pb ? Ib({}, e) : e;\n    function bb(e, t) {\n      t = t || {};\n      const i = {};\n      function n(e, t, i, n) {\n        return ZR.isPlainObject(e) && ZR.isPlainObject(t) ? ZR.merge.call({\n          caseless: n\n        }, e, t) : ZR.isPlainObject(t) ? ZR.merge({}, t) : ZR.isArray(t) ? t.slice() : t;\n      }\n      function r(e, t, i, r) {\n        return ZR.isUndefined(t) ? ZR.isUndefined(e) ? void 0 : n(void 0, e, 0, r) : n(e, t, 0, r);\n      }\n      function o(e, t) {\n        if (!ZR.isUndefined(t)) return n(void 0, t);\n      }\n      function s(e, t) {\n        return ZR.isUndefined(t) ? ZR.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t);\n      }\n      function a(i, r, o) {\n        return o in t ? n(i, r) : o in e ? n(void 0, i) : void 0;\n      }\n      const c = {\n        url: o,\n        method: o,\n        data: o,\n        baseURL: s,\n        transformRequest: s,\n        transformResponse: s,\n        paramsSerializer: s,\n        timeout: s,\n        timeoutMessage: s,\n        withCredentials: s,\n        withXSRFToken: s,\n        adapter: s,\n        responseType: s,\n        xsrfCookieName: s,\n        xsrfHeaderName: s,\n        onUploadProgress: s,\n        onDownloadProgress: s,\n        decompress: s,\n        maxContentLength: s,\n        maxBodyLength: s,\n        beforeRedirect: s,\n        transport: s,\n        httpAgent: s,\n        httpsAgent: s,\n        cancelToken: s,\n        socketPath: s,\n        responseEncoding: s,\n        validateStatus: a,\n        headers: (e, t, i) => r(Ab(e), Ab(t), 0, !0)\n      };\n      return ZR.forEach(Object.keys(Ib(Ib({}, e), t)), function (n) {\n        const o = c[n] || r,\n          s = o(e[n], t[n], n);\n        ZR.isUndefined(s) && o !== a || (i[n] = s);\n      }), i;\n    }\n    var wb = e => {\n      const t = bb({}, e);\n      let {\n        data: i,\n        withXSRFToken: n,\n        xsrfHeaderName: r,\n        xsrfCookieName: o,\n        headers: s,\n        auth: a\n      } = t;\n      if (t.headers = s = pb.from(s), t.url = uC(vb(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && s.set(\"Authorization\", \"Basic \" + btoa((a.username || \"\") + \":\" + (a.password ? unescape(encodeURIComponent(a.password)) : \"\"))), ZR.isFormData(i)) if (hA.hasStandardBrowserEnv || hA.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0);else if (ZR.isFunction(i.getHeaders)) {\n        const e = i.getHeaders(),\n          t = [\"content-type\", \"content-length\"];\n        Object.entries(e).forEach(e => {\n          let [i, n] = e;\n          Ln(t).call(t, i.toLowerCase()) && s.set(i, n);\n        });\n      }\n      if (hA.hasStandardBrowserEnv && (n && ZR.isFunction(n) && (n = n(t)), n || !1 !== n && Rb(t.url))) {\n        const e = r && o && Cb.read(o);\n        e && s.set(r, e);\n      }\n      return t;\n    };\n    var Ob = \"undefined\" != typeof XMLHttpRequest && function (e) {\n      return new rp(function (t, i) {\n        const n = wb(e);\n        let r = n.data;\n        const o = pb.from(n.headers).normalize();\n        let s,\n          a,\n          c,\n          d,\n          l,\n          {\n            responseType: u,\n            onUploadProgress: h,\n            onDownloadProgress: p\n          } = n;\n        function _() {\n          d && d(), l && l(), n.cancelToken && n.cancelToken.unsubscribe(s), n.signal && n.signal.removeEventListener(\"abort\", s);\n        }\n        let E = new XMLHttpRequest();\n        function m() {\n          if (!E) return;\n          const n = pb.from(\"getAllResponseHeaders\" in E && E.getAllResponseHeaders());\n          fb(function (e) {\n            t(e), _();\n          }, function (e) {\n            i(e), _();\n          }, {\n            data: u && \"text\" !== u && \"json\" !== u ? E.response : E.responseText,\n            status: E.status,\n            statusText: E.statusText,\n            headers: n,\n            config: e,\n            request: E\n          }), E = null;\n        }\n        E.open(n.method.toUpperCase(), n.url, !0), E.timeout = n.timeout, \"onloadend\" in E ? E.onloadend = m : E.onreadystatechange = function () {\n          E && 4 === E.readyState && (0 !== E.status || E.responseURL && 0 === E.responseURL.indexOf(\"file:\")) && setTimeout(m);\n        }, E.onabort = function () {\n          E && (i(new $R(\"Request aborted\", $R.ECONNABORTED, e, E)), E = null);\n        }, E.onerror = function (t) {\n          const n = new $R(t && t.message ? t.message : \"Network Error\", $R.ERR_NETWORK, e, E);\n          n.event = t || null, i(n), E = null;\n        }, E.ontimeout = function () {\n          let t = n.timeout ? \"timeout of \" + n.timeout + \"ms exceeded\" : \"timeout exceeded\";\n          const r = n.transitional || pC;\n          n.timeoutErrorMessage && (t = n.timeoutErrorMessage), i(new $R(t, r.clarifyTimeoutError ? $R.ETIMEDOUT : $R.ECONNABORTED, e, E)), E = null;\n        }, void 0 === r && o.setContentType(null), \"setRequestHeader\" in E && ZR.forEach(o.toJSON(), function (e, t) {\n          E.setRequestHeader(t, e);\n        }), ZR.isUndefined(n.withCredentials) || (E.withCredentials = !!n.withCredentials), u && \"json\" !== u && (E.responseType = n.responseType), p && ([c, l] = Sb(p, !0), E.addEventListener(\"progress\", c)), h && E.upload && ([a, d] = Sb(h), E.upload.addEventListener(\"progress\", a), E.upload.addEventListener(\"loadend\", d)), (n.cancelToken || n.signal) && (s = t => {\n          E && (i(!t || t.type ? new mb(null, e, E) : t), E.abort(), E = null);\n        }, n.cancelToken && n.cancelToken.subscribe(s), n.signal && (n.signal.aborted ? s() : n.signal.addEventListener(\"abort\", s)));\n        const f = function (e) {\n          const t = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(e);\n          return t && t[1] || \"\";\n        }(n.url);\n        f && -1 === hA.protocols.indexOf(f) ? i(new $R(\"Unsupported protocol \" + f + \":\", $R.ERR_BAD_REQUEST, e)) : E.send(r || null);\n      });\n    };\n    var Nb = (e, t) => {\n        const {\n          length: i\n        } = e = e ? e.filter(Boolean) : [];\n        if (t || i) {\n          let i,\n            n = new AbortController();\n          const r = function (e) {\n            if (!i) {\n              i = !0, s();\n              const t = e instanceof Error ? e : this.reason;\n              n.abort(t instanceof $R ? t : new mb(t instanceof Error ? t.message : t));\n            }\n          };\n          let o = t && setTimeout(() => {\n            o = null, r(new $R(\"timeout \".concat(t, \" of ms exceeded\"), $R.ETIMEDOUT));\n          }, t);\n          const s = () => {\n            e && (o && clearTimeout(o), o = null, e.forEach(e => {\n              e.unsubscribe ? e.unsubscribe(r) : e.removeEventListener(\"abort\", r);\n            }), e = null);\n          };\n          e.forEach(e => e.addEventListener(\"abort\", r));\n          const {\n            signal: a\n          } = n;\n          return a.unsubscribe = () => ZR.asap(s), a;\n        }\n      },\n      Db = i(np),\n      Pb = $C.f(\"asyncIterator\"),\n      Lb = i(Pb);\n    function kb(e, t) {\n      this.v = e, this.k = t;\n    }\n    function Mb(e) {\n      return function () {\n        return new Ub(e.apply(this, arguments));\n      };\n    }\n    function Ub(e) {\n      var t, i;\n      function n(t, i) {\n        try {\n          var o = e[t](i),\n            s = o.value,\n            a = s instanceof kb;\n          Db.resolve(a ? s.v : s).then(function (i) {\n            if (a) {\n              var c = \"return\" === t ? \"return\" : \"next\";\n              if (!s.k || i.done) return n(c, i);\n              i = e[c](i).value;\n            }\n            r(o.done ? \"return\" : \"normal\", i);\n          }, function (e) {\n            n(\"throw\", e);\n          });\n        } catch (e) {\n          r(\"throw\", e);\n        }\n      }\n      function r(e, r) {\n        switch (e) {\n          case \"return\":\n            t.resolve({\n              value: r,\n              done: !0\n            });\n            break;\n          case \"throw\":\n            t.reject(r);\n            break;\n          default:\n            t.resolve({\n              value: r,\n              done: !1\n            });\n        }\n        (t = t.next) ? n(t.key, t.arg) : i = null;\n      }\n      this._invoke = function (e, r) {\n        return new Db(function (o, s) {\n          var a = {\n            key: e,\n            arg: r,\n            resolve: o,\n            reject: s,\n            next: null\n          };\n          i ? i = i.next = a : (t = i = a, n(e, r));\n        });\n      }, \"function\" != typeof e.return && (this.return = void 0);\n    }\n    function Vb(e) {\n      return new kb(e, 0);\n    }\n    function xb(e) {\n      var t = {},\n        i = !1;\n      function n(t, n) {\n        return i = !0, n = new Db(function (i) {\n          i(e[t](n));\n        }), {\n          done: !1,\n          value: new kb(n, 1)\n        };\n      }\n      return t[void 0 !== QI && ZI || \"@@iterator\"] = function () {\n        return this;\n      }, t.next = function (e) {\n        return i ? (i = !1, e) : n(\"next\", e);\n      }, \"function\" == typeof e.throw && (t.throw = function (e) {\n        if (i) throw i = !1, e;\n        return n(\"throw\", e);\n      }), \"function\" == typeof e.return && (t.return = function (e) {\n        return i ? (i = !1, e) : n(\"return\", e);\n      }), t;\n    }\n    Ub.prototype[\"function\" == typeof QI && Lb || \"@@asyncIterator\"] = function () {\n      return this;\n    }, Ub.prototype.next = function (e) {\n      return this._invoke(\"next\", e);\n    }, Ub.prototype.throw = function (e) {\n      return this._invoke(\"throw\", e);\n    }, Ub.prototype.return = function (e) {\n      return this._invoke(\"return\", e);\n    };\n    var Fb = i(Pb);\n    function Bb(e) {\n      var t,\n        i,\n        n,\n        r = 2;\n      for (\"undefined\" != typeof Symbol && (i = Fb, n = Symbol.iterator); r--;) {\n        if (i && null != (t = e[i])) return t.call(e);\n        if (n && null != (t = e[n])) return new jb(t.call(e));\n        i = \"@@asyncIterator\", n = \"@@iterator\";\n      }\n      throw new TypeError(\"Object is not async iterable\");\n    }\n    function jb(e) {\n      function t(e) {\n        if (Object(e) !== e) return rp.reject(new TypeError(e + \" is not an object.\"));\n        var t = e.done;\n        return rp.resolve(e.value).then(function (e) {\n          return {\n            value: e,\n            done: t\n          };\n        });\n      }\n      return jb = function (e) {\n        this.s = e, this.n = e.next;\n      }, jb.prototype = {\n        s: null,\n        n: null,\n        next: function () {\n          return t(this.n.apply(this.s, arguments));\n        },\n        return: function (e) {\n          var i = this.s.return;\n          return void 0 === i ? rp.resolve({\n            value: e,\n            done: !0\n          }) : t(i.apply(this.s, arguments));\n        },\n        throw: function (e) {\n          var i = this.s.return;\n          return void 0 === i ? rp.reject(e) : t(i.apply(this.s, arguments));\n        }\n      }, new jb(e);\n    }\n    const Gb = function* (e, t) {\n        let i = e.byteLength;\n        if (!t || i < t) return void (yield e);\n        let n,\n          r = 0;\n        for (; r < i;) n = r + t, yield e.slice(r, n), r = n;\n      },\n      Wb = function () {\n        var e = Mb(function* (e, t) {\n          var i,\n            n = !1,\n            r = !1;\n          try {\n            for (var o, s = Bb(Hb(e)); n = !(o = yield Vb(s.next())).done; n = !1) {\n              const e = o.value;\n              yield* xb(Bb(Gb(e, t)));\n            }\n          } catch (e) {\n            r = !0, i = e;\n          } finally {\n            try {\n              n && null != s.return && (yield Vb(s.return()));\n            } finally {\n              if (r) throw i;\n            }\n          }\n        });\n        return function (t, i) {\n          return e.apply(this, arguments);\n        };\n      }(),\n      Hb = function () {\n        var e = Mb(function* (e) {\n          if (e[Fb]) return void (yield* xb(Bb(e)));\n          const t = e.getReader();\n          try {\n            for (;;) {\n              const {\n                done: e,\n                value: i\n              } = yield Vb(t.read());\n              if (e) break;\n              yield i;\n            }\n          } finally {\n            yield Vb(t.cancel());\n          }\n        });\n        return function (t) {\n          return e.apply(this, arguments);\n        };\n      }(),\n      Kb = (e, t, i, n) => {\n        const r = Wb(e, t);\n        let o,\n          s = 0,\n          a = e => {\n            o || (o = !0, n && n(e));\n          };\n        return new ReadableStream({\n          async pull(e) {\n            try {\n              const {\n                done: t,\n                value: n\n              } = await r.next();\n              if (t) return a(), void e.close();\n              let o = n.byteLength;\n              if (i) {\n                let e = s += o;\n                i(e);\n              }\n              e.enqueue(new Uint8Array(n));\n            } catch (e) {\n              throw a(e), e;\n            }\n          },\n          cancel: e => (a(e), r.return())\n        }, {\n          highWaterMark: 2\n        });\n      };\n    function Yb(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function zb(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? Yb(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Yb(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    const {\n        isFunction: qb\n      } = ZR,\n      Xb = (e => {\n        let {\n          Request: t,\n          Response: i\n        } = e;\n        return {\n          Request: t,\n          Response: i\n        };\n      })(ZR.global),\n      {\n        ReadableStream: Jb,\n        TextEncoder: Qb\n      } = ZR.global,\n      Zb = function (e) {\n        try {\n          for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];\n          return !!e(...i);\n        } catch (e) {\n          return !1;\n        }\n      },\n      $b = e => {\n        e = ZR.merge.call({\n          skipUndefined: !0\n        }, Xb, e);\n        const {\n            fetch: t,\n            Request: i,\n            Response: n\n          } = e,\n          r = t ? qb(t) : \"function\" == typeof fetch,\n          o = qb(i),\n          s = qb(n);\n        if (!r) return !1;\n        const a = r && qb(Jb),\n          c = r && (\"function\" == typeof Qb ? (d = new Qb(), e => d.encode(e)) : async e => new Uint8Array(await new i(e).arrayBuffer()));\n        var d;\n        const l = o && a && Zb(() => {\n            let e = !1;\n            const t = new i(hA.origin, {\n              body: new Jb(),\n              method: \"POST\",\n              get duplex() {\n                return e = !0, \"half\";\n              }\n            }).headers.has(\"Content-Type\");\n            return e && !t;\n          }),\n          u = s && a && Zb(() => ZR.isReadableStream(new n(\"\").body)),\n          h = {\n            stream: u && (e => e.body)\n          };\n        r && [\"text\", \"arrayBuffer\", \"blob\", \"formData\", \"stream\"].forEach(e => {\n          !h[e] && (h[e] = (t, i) => {\n            let n = t && t[e];\n            if (n) return n.call(t);\n            throw new $R(\"Response type '\".concat(e, \"' is not supported\"), $R.ERR_NOT_SUPPORT, i);\n          });\n        });\n        const p = async (e, t) => {\n          const n = ZR.toFiniteNumber(e.getContentLength());\n          return null == n ? (async e => {\n            if (null == e) return 0;\n            if (ZR.isBlob(e)) return e.size;\n            if (ZR.isSpecCompliantForm(e)) {\n              const t = new i(hA.origin, {\n                method: \"POST\",\n                body: e\n              });\n              return (await t.arrayBuffer()).byteLength;\n            }\n            return ZR.isArrayBufferView(e) || ZR.isArrayBuffer(e) ? e.byteLength : (ZR.isURLSearchParams(e) && (e += \"\"), ZR.isString(e) ? (await c(e)).byteLength : void 0);\n          })(t) : n;\n        };\n        return async e => {\n          let {\n              url: r,\n              method: s,\n              data: a,\n              signal: c,\n              cancelToken: d,\n              timeout: _,\n              onDownloadProgress: E,\n              onUploadProgress: m,\n              responseType: f,\n              headers: S,\n              withCredentials: g = \"same-origin\",\n              fetchOptions: T\n            } = wb(e),\n            R = t || fetch;\n          f = f ? (f + \"\").toLowerCase() : \"text\";\n          let C = Nb([c, d && d.toAbortSignal()], _),\n            v = null;\n          const y = C && C.unsubscribe && (() => {\n            C.unsubscribe();\n          });\n          let I;\n          try {\n            if (m && l && \"get\" !== s && \"head\" !== s && 0 !== (I = await p(S, a))) {\n              let e,\n                t = new i(r, {\n                  method: \"POST\",\n                  body: a,\n                  duplex: \"half\"\n                });\n              if (ZR.isFormData(a) && (e = t.headers.get(\"content-type\")) && S.setContentType(e), t.body) {\n                const [e, i] = gb(I, Sb(Tb(m)));\n                a = Kb(t.body, 65536, e, i);\n              }\n            }\n            ZR.isString(g) || (g = g ? \"include\" : \"omit\");\n            const t = o && \"credentials\" in i.prototype,\n              c = zb(zb({}, T), {}, {\n                signal: C,\n                method: s.toUpperCase(),\n                headers: S.normalize().toJSON(),\n                body: a,\n                duplex: \"half\",\n                credentials: t ? g : void 0\n              });\n            v = o && new i(r, c);\n            let d = await (o ? R(v, T) : R(r, c));\n            const _ = u && (\"stream\" === f || \"response\" === f);\n            if (u && (E || _ && y)) {\n              const e = {};\n              [\"status\", \"statusText\", \"headers\"].forEach(t => {\n                e[t] = d[t];\n              });\n              const t = ZR.toFiniteNumber(d.headers.get(\"content-length\")),\n                [i, r] = E && gb(t, Sb(Tb(E), !0)) || [];\n              d = new n(Kb(d.body, 65536, i, () => {\n                r && r(), y && y();\n              }), e);\n            }\n            f = f || \"text\";\n            let A = await h[ZR.findKey(h, f) || \"text\"](d, e);\n            return !_ && y && y(), await new rp((t, i) => {\n              fb(t, i, {\n                data: A,\n                headers: pb.from(d.headers),\n                status: d.status,\n                statusText: d.statusText,\n                config: e,\n                request: v\n              });\n            });\n          } catch (t) {\n            if (y && y(), t && \"TypeError\" === t.name && /Load failed|fetch/i.test(t.message)) throw Object.assign(new $R(\"Network Error\", $R.ERR_NETWORK, e, v), {\n              cause: t.cause || t\n            });\n            throw $R.from(t, t && t.code, e, v);\n          }\n        };\n      },\n      ew = new Map(),\n      tw = e => {\n        let t = e && e.env || {};\n        const {\n            fetch: i,\n            Request: n,\n            Response: r\n          } = t,\n          o = [n, r, i];\n        let s,\n          a,\n          c = o.length,\n          d = ew;\n        for (; c--;) s = o[c], a = d.get(s), void 0 === a && d.set(s, a = c ? new Map() : $b(t)), d = a;\n        return a;\n      };\n    tw();\n    const iw = {\n      http: null,\n      xhr: Ob,\n      fetch: {\n        get: tw\n      }\n    };\n    ZR.forEach(iw, (e, t) => {\n      if (e) {\n        try {\n          Object.defineProperty(e, \"name\", {\n            value: t\n          });\n        } catch (e) {}\n        Object.defineProperty(e, \"adapterName\", {\n          value: t\n        });\n      }\n    });\n    const nw = e => \"- \".concat(e),\n      rw = e => ZR.isFunction(e) || null === e || !1 === e;\n    var ow = {\n      getAdapter: function (e, t) {\n        e = ZR.isArray(e) ? e : [e];\n        const {\n          length: i\n        } = e;\n        let n, r;\n        const o = {};\n        for (let s = 0; s < i; s++) {\n          let i;\n          if (n = e[s], r = n, !rw(n) && (r = iw[(i = String(n)).toLowerCase()], void 0 === r)) throw new $R(\"Unknown adapter '\".concat(i, \"'\"));\n          if (r && (ZR.isFunction(r) || (r = r.get(t)))) break;\n          o[i || \"#\" + s] = r;\n        }\n        if (!r) {\n          const e = Object.entries(o).map(e => {\n            let [t, i] = e;\n            return \"adapter \".concat(t, \" \") + (!1 === i ? \"is not supported by the environment\" : \"is not available in the build\");\n          });\n          throw new $R(\"There is no suitable adapter to dispatch the request \" + (i ? e.length > 1 ? \"since :\\n\" + e.map(nw).join(\"\\n\") : \" \" + nw(e[0]) : \"as no adapter specified\"), \"ERR_NOT_SUPPORT\");\n        }\n        return r;\n      },\n      adapters: iw\n    };\n    function sw(e) {\n      if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new mb(null, e);\n    }\n    function aw(e) {\n      sw(e), e.headers = pb.from(e.headers), e.data = _b.call(e, e.transformRequest), -1 !== [\"post\", \"put\", \"patch\"].indexOf(e.method) && e.headers.setContentType(\"application/x-www-form-urlencoded\", !1);\n      return ow.getAdapter(e.adapter || sb.adapter, e)(e).then(function (t) {\n        return sw(e), t.data = _b.call(e, e.transformResponse, t), t.headers = pb.from(t.headers), t;\n      }, function (t) {\n        return Eb(t) || (sw(e), t && t.response && (t.response.data = _b.call(e, e.transformResponse, t.response), t.response.headers = pb.from(t.response.headers))), rp.reject(t);\n      });\n    }\n    const cw = \"1.13.2\",\n      dw = {};\n    [\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach((e, t) => {\n      dw[e] = function (i) {\n        return typeof i === e || \"a\" + (t < 1 ? \"n \" : \" \") + e;\n      };\n    });\n    const lw = {};\n    dw.transitional = function (e, t, i) {\n      function n(e, t) {\n        return \"[Axios v\" + cw + \"] Transitional option '\" + e + \"'\" + t + (i ? \". \" + i : \"\");\n      }\n      return (i, r, o) => {\n        if (!1 === e) throw new $R(n(r, \" has been removed\" + (t ? \" in \" + t : \"\")), $R.ERR_DEPRECATED);\n        return t && !lw[r] && (lw[r] = !0, console.warn(n(r, \" has been deprecated since v\" + t + \" and will be removed in the near future\"))), !e || e(i, r, o);\n      };\n    }, dw.spelling = function (e) {\n      return (t, i) => (console.warn(\"\".concat(i, \" is likely a misspelling of \").concat(e)), !0);\n    };\n    var uw = {\n      assertOptions: function (e, t, i) {\n        if (\"object\" != typeof e) throw new $R(\"options must be an object\", $R.ERR_BAD_OPTION_VALUE);\n        const n = Object.keys(e);\n        let r = n.length;\n        for (; r-- > 0;) {\n          const o = n[r],\n            s = t[o];\n          if (s) {\n            const t = e[o],\n              i = void 0 === t || s(t, o, e);\n            if (!0 !== i) throw new $R(\"option \" + o + \" must be \" + i, $R.ERR_BAD_OPTION_VALUE);\n          } else if (!0 !== i) throw new $R(\"Unknown option \" + o, $R.ERR_BAD_OPTION);\n        }\n      },\n      validators: dw\n    };\n    const hw = uw.validators;\n    let pw = class {\n      constructor(e) {\n        this.defaults = e || {}, this.interceptors = {\n          request: new hC(),\n          response: new hC()\n        };\n      }\n      async request(e, t) {\n        try {\n          return await this._request(e, t);\n        } catch (e) {\n          if (e instanceof Error) {\n            let t = {};\n            Error.captureStackTrace ? Error.captureStackTrace(t) : t = new Error();\n            const i = t.stack ? t.stack.replace(/^.+\\n/, \"\") : \"\";\n            try {\n              e.stack ? i && !String(e.stack).endsWith(i.replace(/^.+\\n.+\\n/, \"\")) && (e.stack += \"\\n\" + i) : e.stack = i;\n            } catch (e) {}\n          }\n          throw e;\n        }\n      }\n      _request(e, t) {\n        \"string\" == typeof e ? (t = t || {}).url = e : t = e || {}, t = bb(this.defaults, t);\n        const {\n          transitional: i,\n          paramsSerializer: n,\n          headers: r\n        } = t;\n        void 0 !== i && uw.assertOptions(i, {\n          silentJSONParsing: hw.transitional(hw.boolean),\n          forcedJSONParsing: hw.transitional(hw.boolean),\n          clarifyTimeoutError: hw.transitional(hw.boolean)\n        }, !1), null != n && (ZR.isFunction(n) ? t.paramsSerializer = {\n          serialize: n\n        } : uw.assertOptions(n, {\n          encode: hw.function,\n          serialize: hw.function\n        }, !0)), void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), uw.assertOptions(t, {\n          baseUrl: hw.spelling(\"baseURL\"),\n          withXsrfToken: hw.spelling(\"withXSRFToken\")\n        }, !0), t.method = (t.method || this.defaults.method || \"get\").toLowerCase();\n        let o = r && ZR.merge(r.common, r[t.method]);\n        r && ZR.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"], e => {\n          delete r[e];\n        }), t.headers = pb.concat(o, r);\n        const s = [];\n        let a = !0;\n        this.interceptors.request.forEach(function (e) {\n          \"function\" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, s.unshift(e.fulfilled, e.rejected));\n        });\n        const c = [];\n        let d;\n        this.interceptors.response.forEach(function (e) {\n          c.push(e.fulfilled, e.rejected);\n        });\n        let l,\n          u = 0;\n        if (!a) {\n          const e = [aw.bind(this), void 0];\n          for (e.unshift(...s), e.push(...c), l = e.length, d = rp.resolve(t); u < l;) d = d.then(e[u++], e[u++]);\n          return d;\n        }\n        l = s.length;\n        let h = t;\n        for (; u < l;) {\n          const e = s[u++],\n            t = s[u++];\n          try {\n            h = e(h);\n          } catch (e) {\n            t.call(this, e);\n            break;\n          }\n        }\n        try {\n          d = aw.call(this, h);\n        } catch (e) {\n          return rp.reject(e);\n        }\n        for (u = 0, l = c.length; u < l;) d = d.then(c[u++], c[u++]);\n        return d;\n      }\n      getUri(e) {\n        return uC(vb((e = bb(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer);\n      }\n    };\n    ZR.forEach([\"delete\", \"get\", \"head\", \"options\"], function (e) {\n      pw.prototype[e] = function (t, i) {\n        return this.request(bb(i || {}, {\n          method: e,\n          url: t,\n          data: (i || {}).data\n        }));\n      };\n    }), ZR.forEach([\"post\", \"put\", \"patch\"], function (e) {\n      function t(t) {\n        return function (i, n, r) {\n          return this.request(bb(r || {}, {\n            method: e,\n            headers: t ? {\n              \"Content-Type\": \"multipart/form-data\"\n            } : {},\n            url: i,\n            data: n\n          }));\n        };\n      }\n      pw.prototype[e] = t(), pw.prototype[e + \"Form\"] = t(!0);\n    });\n    var _w = pw;\n    class Ew {\n      constructor(e) {\n        if (\"function\" != typeof e) throw new TypeError(\"executor must be a function.\");\n        let t;\n        this.promise = new rp(function (e) {\n          t = e;\n        });\n        const i = this;\n        this.promise.then(e => {\n          if (!i._listeners) return;\n          let t = i._listeners.length;\n          for (; t-- > 0;) i._listeners[t](e);\n          i._listeners = null;\n        }), this.promise.then = e => {\n          let t;\n          const n = new rp(e => {\n            i.subscribe(e), t = e;\n          }).then(e);\n          return n.cancel = function () {\n            i.unsubscribe(t);\n          }, n;\n        }, e(function (e, n, r) {\n          i.reason || (i.reason = new mb(e, n, r), t(i.reason));\n        });\n      }\n      throwIfRequested() {\n        if (this.reason) throw this.reason;\n      }\n      subscribe(e) {\n        this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e];\n      }\n      unsubscribe(e) {\n        if (!this._listeners) return;\n        const t = this._listeners.indexOf(e);\n        -1 !== t && this._listeners.splice(t, 1);\n      }\n      toAbortSignal() {\n        const e = new AbortController(),\n          t = t => {\n            e.abort(t);\n          };\n        return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;\n      }\n      static source() {\n        let e;\n        const t = new Ew(function (t) {\n          e = t;\n        });\n        return {\n          token: t,\n          cancel: e\n        };\n      }\n    }\n    var mw = Ew;\n    const fw = {\n      Continue: 100,\n      SwitchingProtocols: 101,\n      Processing: 102,\n      EarlyHints: 103,\n      Ok: 200,\n      Created: 201,\n      Accepted: 202,\n      NonAuthoritativeInformation: 203,\n      NoContent: 204,\n      ResetContent: 205,\n      PartialContent: 206,\n      MultiStatus: 207,\n      AlreadyReported: 208,\n      ImUsed: 226,\n      MultipleChoices: 300,\n      MovedPermanently: 301,\n      Found: 302,\n      SeeOther: 303,\n      NotModified: 304,\n      UseProxy: 305,\n      Unused: 306,\n      TemporaryRedirect: 307,\n      PermanentRedirect: 308,\n      BadRequest: 400,\n      Unauthorized: 401,\n      PaymentRequired: 402,\n      Forbidden: 403,\n      NotFound: 404,\n      MethodNotAllowed: 405,\n      NotAcceptable: 406,\n      ProxyAuthenticationRequired: 407,\n      RequestTimeout: 408,\n      Conflict: 409,\n      Gone: 410,\n      LengthRequired: 411,\n      PreconditionFailed: 412,\n      PayloadTooLarge: 413,\n      UriTooLong: 414,\n      UnsupportedMediaType: 415,\n      RangeNotSatisfiable: 416,\n      ExpectationFailed: 417,\n      ImATeapot: 418,\n      MisdirectedRequest: 421,\n      UnprocessableEntity: 422,\n      Locked: 423,\n      FailedDependency: 424,\n      TooEarly: 425,\n      UpgradeRequired: 426,\n      PreconditionRequired: 428,\n      TooManyRequests: 429,\n      RequestHeaderFieldsTooLarge: 431,\n      UnavailableForLegalReasons: 451,\n      InternalServerError: 500,\n      NotImplemented: 501,\n      BadGateway: 502,\n      ServiceUnavailable: 503,\n      GatewayTimeout: 504,\n      HttpVersionNotSupported: 505,\n      VariantAlsoNegotiates: 506,\n      InsufficientStorage: 507,\n      LoopDetected: 508,\n      NotExtended: 510,\n      NetworkAuthenticationRequired: 511,\n      WebServerIsDown: 521,\n      ConnectionTimedOut: 522,\n      OriginIsUnreachable: 523,\n      TimeoutOccurred: 524,\n      SslHandshakeFailed: 525,\n      InvalidSslCertificate: 526\n    };\n    Object.entries(fw).forEach(e => {\n      let [t, i] = e;\n      fw[i] = t;\n    });\n    var Sw = fw;\n    const gw = function e(t) {\n      const i = new _w(t),\n        n = cR(_w.prototype.request, i);\n      return ZR.extend(n, _w.prototype, i, {\n        allOwnKeys: !0\n      }), ZR.extend(n, i, null, {\n        allOwnKeys: !0\n      }), n.create = function (i) {\n        return e(bb(t, i));\n      }, n;\n    }(sb);\n    gw.Axios = _w, gw.CanceledError = mb, gw.CancelToken = mw, gw.isCancel = Eb, gw.VERSION = cw, gw.toFormData = sC, gw.AxiosError = $R, gw.Cancel = gw.CanceledError, gw.all = function (e) {\n      return rp.all(e);\n    }, gw.spread = function (e) {\n      return function (t) {\n        return e.apply(null, t);\n      };\n    }, gw.isAxiosError = function (e) {\n      return ZR.isObject(e) && !0 === e.isAxiosError;\n    }, gw.mergeConfig = bb, gw.AxiosHeaders = pb, gw.formToJSON = e => rb(ZR.isHTMLForm(e) ? new FormData(e) : e), gw.getAdapter = ow.getAdapter, gw.HttpStatusCode = Sw, gw.default = gw;\n    var Tw = gw;\n    const Rw = () => {};\n    function Cw() {\n      const e = {\n        promise: void 0,\n        isResolved: !1,\n        isRejected: !1,\n        isFinished: !1,\n        resolve: void 0,\n        reject: void 0,\n        cancel: Rw\n      };\n      return e.promise = new rp((t, i) => {\n        e.resolve = i => {\n          e.isFinished || (e.isResolved = !0, e.isFinished = !0, t(i), e.value = i);\n        }, e.reject = t => {\n          e.isFinished || (e.isRejected = !0, e.isFinished = !0, i(t));\n        };\n      }), e;\n    }\n    const vw = new Map(),\n      yw = new Map(),\n      Iw = new Map();\n    let Aw = function (e) {\n        return e.WIN_10 = \"Windows 10\", e.WIN_81 = \"Windows 8.1\", e.WIN_8 = \"Windows 8\", e.WIN_7 = \"Windows 7\", e.WIN_VISTA = \"Windows Vista\", e.WIN_SERVER_2003 = \"Windows Server 2003\", e.WIN_XP = \"Windows XP\", e.WIN_2000 = \"Windows 2000\", e.ANDROID = \"Android\", e.HARMONY_OS = \"HarmonyOS\", e.OPEN_BSD = \"Open BSD\", e.SUN_OS = \"Sun OS\", e.LINUX = \"Linux\", e.IOS = \"iOS\", e.MAC_OS = \"Mac OS\", e.CHROMIUM_OS = \"Chromium OS\", e.QNX = \"QNX\", e.UNIX = \"UNIX\", e.BEOS = \"BeOS\", e.OS_2 = \"OS/2\", e.SEARCH_BOT = \"Search Bot\", e;\n      }({}),\n      bw = function (e) {\n        return e.CHROME = \"Chrome\", e.SAFARI = \"Safari\", e.EDGE = \"Edge\", e.FIREFOX = \"Firefox\", e.OPERA = \"OPR\", e.QQ = \"QQBrowser\", e.WECHAT = \"MicroMessenger\", e;\n      }({});\n    const ww = new FT();\n    let Ow = ww.getResult(),\n      Nw = null;\n    function Dw(e) {\n      if (!Nw) {\n        e && ww.setUA(e), Ow = ww.getResult();\n        const t = function (e) {\n            if (\"Blink\" === e.engine.name && \"WeChat\" !== e.browser.name) return bw.CHROME;\n            switch (e.browser.name) {\n              case \"Chrome Headless\":\n              case \"Chrome\":\n              case \"Chromium\":\n                return bw.CHROME;\n              case \"Safari\":\n              case \"Mobile Safari\":\n                return bw.SAFARI;\n              case \"Edge\":\n                return bw.EDGE;\n              case \"Firefox\":\n                return bw.FIREFOX;\n              case \"QQ\":\n              case \"QQBrowser\":\n                return bw.QQ;\n              case \"Opera\":\n                return bw.OPERA;\n              case \"WeChat\":\n                return bw.WECHAT;\n              default:\n                return e.browser.name || \"\";\n            }\n          }(Ow),\n          i = Pw(Ow),\n          n = function (e) {\n            return \"Windows\" === e.os.name ? e.os.version ? e.os.name + \" \" + e.os.version : e.os.name : e.os.name || \"\";\n          }(Ow),\n          r = Ow.os.version,\n          o = Pw(Ow, !1),\n          s = Ow.device.type;\n        if (!(t && i && n && r)) return {\n          name: t,\n          version: i,\n          os: n,\n          osVersion: r,\n          browserVersion: o,\n          deviceType: s\n        };\n        Nw = {\n          name: t,\n          version: i,\n          os: n,\n          osVersion: r,\n          browserVersion: o,\n          deviceType: s\n        };\n      }\n      return Nw;\n    }\n    function Pw(e) {\n      let t,\n        i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      return t = \"Blink\" === e.engine.name ? e.engine.version || \"\" : e.browser.version || \"\", i ? t.split(\".\")[0] : t;\n    }\n    function Lw() {\n      return Dw().os;\n    }\n    function kw() {\n      const e = Dw();\n      return \"\".concat(e.os, \" \").concat(e.osVersion);\n    }\n    function Mw() {\n      const e = Dw();\n      return !!(\"WebKit\" === Ow.engine.name && e.os === Aw.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e.name !== bw.SAFARI || jw() && e.name !== bw.SAFARI);\n    }\n    function Uw() {\n      return Dw().name === bw.CHROME;\n    }\n    function Vw() {\n      return Dw().name === bw.SAFARI;\n    }\n    function xw() {\n      const e = Dw();\n      if (e.name !== bw.SAFARI || !e.browserVersion) return !1;\n      const t = e.browserVersion.split(\".\");\n      return Number(t[0]) > 15 || 15 === Number(t[0]) && Number(t[1]) >= 4;\n    }\n    function Fw() {\n      return Dw().name === bw.EDGE;\n    }\n    function Bw() {\n      return Dw().name === bw.FIREFOX;\n    }\n    function jw() {\n      return Dw().os === Aw.IOS;\n    }\n    function Gw(e) {\n      const t = Dw();\n      return !(t.name !== bw.CHROME || !t.osVersion) && Number(t.version) >= e;\n    }\n    function Ww(e) {\n      const t = Dw();\n      return !(t.name !== bw.CHROME || !t.osVersion) && Number(t.version) < e;\n    }\n    function Hw(e, t, i) {\n      const n = Dw();\n      return !(n.name !== e || !n.osVersion) && (i ? Number(n.version) >= t && Number(n.version) <= i : Number(n.version) === t);\n    }\n    function Kw(e) {\n      const t = Dw();\n      return !(t.name !== bw.EDGE || !t.osVersion) && Number(t.version) >= e;\n    }\n    function Yw(e) {\n      const t = Dw();\n      return !(t.name !== bw.FIREFOX || !t.osVersion) && Number(t.version) >= e;\n    }\n    function zw(e) {\n      const t = Dw();\n      return !(t.name !== bw.SAFARI || !t.osVersion) && Number(t.version) >= e;\n    }\n    function qw(e, t, i) {\n      const n = Dw();\n      if (n.os !== Aw.IOS || !n.osVersion) return !1;\n      const r = n.osVersion.split(\".\");\n      return i ? t && Number(r[0]) === e && Number(r[1]) > t || Number(r[0]) > e : t ? Number(r[0]) === e && Number(r[1]) >= t || Number(r[0]) > e : Number(r[0]) >= e;\n    }\n    function Xw(e, t, i) {\n      const n = Dw();\n      if (n.os !== Aw.IOS || !n.osVersion) return !1;\n      const r = n.osVersion.split(\".\");\n      return i ? t && Number(r[0]) === e && Number(r[1]) < t || Number(r[0]) < e : t ? Number(r[0]) === e && Number(r[1]) <= t || Number(r[0]) < e : Number(r[0]) <= e;\n    }\n    function Jw(e, t, i) {\n      const n = Dw();\n      if (n.name !== bw.SAFARI || !n.osVersion || !n.browserVersion) return !1;\n      const r = n.browserVersion.split(\".\");\n      return i ? t && Number(r[0]) === e && Number(r[1]) < t || Number(r[0]) < e : t ? Number(r[0]) === e && Number(r[1]) <= t || Number(r[0]) < e : Number(r[0]) <= e;\n    }\n    function Qw(e) {\n      const t = Dw();\n      return !(t.name !== bw.OPERA || !t.osVersion) && Number(t.version) >= e;\n    }\n    function Zw() {\n      const e = Dw();\n      if (e.os !== Aw.IOS || !e.osVersion) return !1;\n      const t = e.osVersion.split(\".\");\n      return Number(t[0]) < 14 || 14 === Number(t[0]) && Number(t[1]) <= 6;\n    }\n    function $w() {\n      const e = Dw();\n      if (e.os !== Aw.IOS || !e.osVersion) return !1;\n      const t = e.osVersion.split(\".\");\n      return 15 === Number(t[0]);\n    }\n    function eO() {\n      const e = Dw();\n      if (e.os !== Aw.IOS || !e.osVersion) return !1;\n      const t = e.osVersion.split(\".\");\n      return 16 === Number(t[0]);\n    }\n    function tO() {\n      const e = Dw();\n      if (e.os !== Aw.IOS || !e.osVersion) return !1;\n      const t = e.osVersion.split(\".\");\n      return 15 === Number(t[0]) && Number(t[1]) >= 1;\n    }\n    function iO() {\n      return Vw() && navigator.maxTouchPoints > 0;\n    }\n    function nO() {\n      return Dw().name === bw.WECHAT;\n    }\n    function rO() {\n      return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./) && window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./)[1] <= 35;\n    }\n    function oO() {\n      const e = Lw();\n      return function () {\n        const {\n          deviceType: e\n        } = Dw();\n        return \"mobile\" === e || \"tablet\" === e;\n      }() || e === Aw.ANDROID || e === Aw.IOS || e === Aw.HARMONY_OS;\n    }\n    function sO() {\n      const e = Dw();\n      return e.name !== bw.EDGE && e.name !== bw.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]./i);\n    }\n    function aO() {\n      return Lw() === Aw.ANDROID;\n    }\n    function cO() {\n      const e = Dw();\n      return aO() && (e.name === bw.CHROME || e.name === bw.WECHAT || /chrome|chromium/i.test(navigator.userAgent));\n    }\n    function dO(e, t, i) {\n      return (t = function (e) {\n        var t = function (e, t) {\n          if (\"object\" != typeof e || !e) return e;\n          var i = e[Symbol.toPrimitive];\n          if (void 0 !== i) {\n            var n = i.call(e, \"string\");\n            if (\"object\" != typeof n) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return String(e);\n        }(e);\n        return \"symbol\" == typeof t ? t : t + \"\";\n      }(t)) in e ? Object.defineProperty(e, t, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = i, e;\n    }\n    function lO(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function uO(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? lO(Object(i), !0).forEach(function (t) {\n          dO(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : lO(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    let hO = function (e) {\n        return e.UNEXPECTED_ERROR = \"UNEXPECTED_ERROR\", e.UNEXPECTED_RESPONSE = \"UNEXPECTED_RESPONSE\", e.TIMEOUT = \"TIMEOUT\", e.INVALID_PARAMS = \"INVALID_PARAMS\", e.NOT_READABLE = \"NOT_READABLE\", e.NOT_SUPPORTED = \"NOT_SUPPORTED\", e.INVALID_OPERATION = \"INVALID_OPERATION\", e.OPERATION_ABORTED = \"OPERATION_ABORTED\", e.WEB_SECURITY_RESTRICT = \"WEB_SECURITY_RESTRICT\", e.EXCHANGE_SDP_FAILED = \"EXCHANGE_SDP_FAILED\", e.ADD_CANDIDATE_FAILED = \"ADD_CANDIDATE_FAILED\", e.DATACHANNEL_FAILED = \"DATACHANNEL_FAILED\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.NETWORK_TIMEOUT = \"NETWORK_TIMEOUT\", e.NETWORK_RESPONSE_ERROR = \"NETWORK_RESPONSE_ERROR\", e.API_INVOKE_TIMEOUT = \"API_INVOKE_TIMEOUT\", e.ENUMERATE_DEVICES_FAILED = \"ENUMERATE_DEVICES_FAILED\", e.DEVICE_NOT_FOUND = \"DEVICE_NOT_FOUND\", e.ELECTRON_IS_NULL = \"ELECTRON_IS_NULL\", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = \"ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR\", e.CHROME_PLUGIN_NO_RESPONSE = \"CHROME_PLUGIN_NO_RESPONSE\", e.CHROME_PLUGIN_NOT_INSTALL = \"CHROME_PLUGIN_NOT_INSTALL\", e.MEDIA_OPTION_INVALID = \"MEDIA_OPTION_INVALID\", e.PERMISSION_DENIED = \"PERMISSION_DENIED\", e.CONSTRAINT_NOT_SATISFIED = \"CONSTRAINT_NOT_SATISFIED\", e.TRACK_IS_DISABLED = \"TRACK_IS_DISABLED\", e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = \"GET_VIDEO_ELEMENT_VISIBLE_ERROR\", e.SHARE_AUDIO_NOT_ALLOWED = \"SHARE_AUDIO_NOT_ALLOWED\", e.LOW_STREAM_ENCODING_ERROR = \"LOW_STREAM_ENCODING_ERROR\", e.SET_ENCODING_PARAMETER_ERROR = \"SET_ENCODING_PARAMETER_ERROR\", e.TRACK_STATE_UNREACHABLE = \"TRACK_STATE_UNREACHABLE\", e.INVALID_UINT_UID_FROM_STRING_UID = \"INVALID_UINT_UID_FROM_STRING_UID\", e.CAN_NOT_GET_PROXY_SERVER = \"CAN_NOT_GET_PROXY_SERVER\", e.CAN_NOT_GET_GATEWAY_SERVER = \"CAN_NOT_GET_GATEWAY_SERVER\", e.VOID_GATEWAY_ADDRESS = \"VOID_GATEWAY_ADDRESS\", e.UID_CONFLICT = \"UID_CONFLICT\", e.MULTI_UNILBS_RESPONSE_ERROR = \"MULTI_UNILBS_RESPONSE_ERROR\", e.UPDATE_TICKET_FAILED = \"UPDATE_TICKET_FAILED\", e.TOKEN_EXPIRE = \"TOKEN_EXPIRE\", e.INVALID_LOCAL_TRACK = \"INVALID_LOCAL_TRACK\", e.INVALID_TRACK = \"INVALID_TRACK\", e.SENDER_NOT_FOUND = \"SENDER_NOT_FOUND\", e.CREATE_OFFER_FAILED = \"CREATE_OFFER_FAILED\", e.SET_ANSWER_FAILED = \"SET_ANSWER_FAILED\", e.ICE_FAILED = \"ICE_FAILED\", e.PC_CLOSED = \"PC_CLOSED\", e.SENDER_REPLACE_FAILED = \"SENDER_REPLACE_FAILED\", e.GET_LOCAL_CAPABILITIES_FAILED = \"GET_LOCAL_CAPABILITIES_FAILED\", e.GET_LOCAL_CONNECTION_PARAMS_FAILED = \"GET_LOCAL_CONNECTION_PARAMS_FAILED\", e.SUBSCRIBE_FAILED = \"SUBSCRIBE_FAILED\", e.UNSUBSCRIBE_FAILED = \"UNSUBSCRIBE_FAILED\", e.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\", e.NO_ICE_CANDIDATE = \"NO_ICE_CANDIDATE\", e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = \"CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS\", e.EXIST_DISABLED_VIDEO_TRACK = \"EXIST_DISABLED_VIDEO_TRACK\", e.INVALID_REMOTE_USER = \"INVALID_REMOTE_USER\", e.REMOTE_USER_IS_NOT_PUBLISHED = \"REMOTE_USER_IS_NOT_PUBLISHED\", e.CUSTOM_REPORT_SEND_FAILED = \"CUSTOM_REPORT_SEND_FAILED\", e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = \"CUSTOM_REPORT_FREQUENCY_TOO_HIGH\", e.FETCH_AUDIO_FILE_FAILED = \"FETCH_AUDIO_FILE_FAILED\", e.READ_LOCAL_AUDIO_FILE_ERROR = \"READ_LOCAL_AUDIO_FILE_ERROR\", e.DECODE_AUDIO_FILE_FAILED = \"DECODE_AUDIO_FILE_FAILED\", e.WS_ABORT = \"WS_ABORT\", e.WS_DISCONNECT = \"WS_DISCONNECT\", e.WS_ERR = \"WS_ERR\", e.EXTERNAL_SIGNAL_ABORT = \"EXTERNAL_SIGNAL_ABORT\", e.LIVE_STREAMING_TASK_CONFLICT = \"LIVE_STREAMING_TASK_CONFLICT\", e.LIVE_STREAMING_INVALID_ARGUMENT = \"LIVE_STREAMING_INVALID_ARGUMENT\", e.LIVE_STREAMING_INTERNAL_SERVER_ERROR = \"LIVE_STREAMING_INTERNAL_SERVER_ERROR\", e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = \"LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED\", e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = \"LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED\", e.LIVE_STREAMING_CDN_ERROR = \"LIVE_STREAMING_CDN_ERROR\", e.LIVE_STREAMING_INVALID_RAW_STREAM = \"LIVE_STREAMING_INVALID_RAW_STREAM\", e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = \"LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT\", e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = \"LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE\", e.LIVE_STREAMING_WARN_FREQUENT_REQUEST = \"LIVE_STREAMING_WARN_FREQUENT_REQUEST\", e.WEBGL_INTERNAL_ERROR = \"WEBGL_INTERNAL_ERROR\", e.BEAUTY_PROCESSOR_INTERNAL_ERROR = \"BEAUTY_PROCESSOR_INTERNAL_ERROR\", e.CROSS_CHANNEL_WAIT_STATUS_ERROR = \"CROSS_CHANNEL_WAIT_STATUS_ERROR\", e.CROSS_CHANNEL_FAILED_JOIN_SRC = \"CROSS_CHANNEL_FAILED_JOIN_SEC\", e.CROSS_CHANNEL_FAILED_JOIN_DEST = \"CROSS_CHANNEL_FAILED_JOIN_DEST\", e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = \"CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST\", e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = \"CROSS_CHANNEL_SERVER_ERROR_RESPONSE\", e.METADATA_OUT_OF_RANGE = \"METADATA_OUT_OF_RANGE\", e.LOCAL_AEC_ERROR = \"LOCAL_AEC_ERROR\", e.INVALID_PLUGIN = \"INVALID_PLUGIN\", e.DISCONNECT_P2P = \"DISCONNECT_P2P\", e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = \"CONVERTING_IMAGEDATA_TO_BLOB_FAILED\", e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = \"CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED\", e.INIT_DATACHANNEL_TIMEOUT = \"INIT_DATACHANNEL_TIMEOUT\", e.CREATE_DATACHANNEL_ERROR = \"CREATE_DATACHANNEL_ERROR\", e.DATACHANNEL_CONNECTION_TIMEOUT = \"DATACHANNEL_CONNECTION_TIMEOUT\", e.PROHIBITED_OPERATION = \"PROHIBITED_OPERATION\", e.IMAGE_MODERATION_UPLOAD_FAILED = \"IMAGE_MODERATION_UPLOAD_FAILED\", e.P2P_MESSAGE_FAILED = \"P2P_MESSAGE_FAILED\", e;\n      }({}),\n      pO = class extends Error {\n        constructor(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\",\n            i = arguments.length > 2 ? arguments[2] : void 0;\n          super(t), dO(this, \"code\", void 0), dO(this, \"message\", void 0), dO(this, \"data\", void 0), dO(this, \"name\", \"AgoraRTCException\"), this.code = e, this.message = \"AgoraRTCError \".concat(this.code, \": \").concat(t), this.data = i;\n        }\n        toString() {\n          return this.data ? \"\".concat(this.message, \"\\ndata: \").concat(JSON.stringify(this.data)) : this.message;\n        }\n        print() {\n          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"error\",\n            t = arguments.length > 1 ? arguments[1] : void 0;\n          return \"error\" === e && (t || console).error(this.toString()), \"warning\" === e && (t || console).warn(this.toString()), this;\n        }\n        throw(e) {\n          throw this.print(\"error\", e), this;\n        }\n      };\n    function _O(e, t) {\n      if (\"boolean\" != typeof e) throw new pO(hO.INVALID_PARAMS, \"Invalid \".concat(t, \": The value is of the boolean type.\"));\n    }\n    function EO(e, t, i) {\n      if (!Ln(i).call(i, e)) throw new pO(hO.INVALID_PARAMS, \"\".concat(t, \" can only be set as \").concat(JSON.stringify(i)));\n    }\n    function mO(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;\n      if (e < i || e > n || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function (e) {\n        return \"number\" == typeof e && e % 1 == 0;\n      }(e)) throw new pO(hO.INVALID_PARAMS, \"invalid \".concat(t, \": the value range is [\").concat(i, \", \").concat(n, \"]. integer only\"));\n    }\n    function fO(e, t) {\n      if (\"number\" != typeof e) {\n        if (!(e.min || e.max || e.ideal || e.exact)) throw new pO(hO.INVALID_PARAMS, \"\".concat(t, \" is not a valid ConstrainLong\"));\n        void 0 !== e.min && mO(e.min, \"\".concat(t, \".min\"), 0, 1 / 0), void 0 !== e.max && mO(e.max, \"\".concat(t, \".max\"), 1, 1 / 0), void 0 !== e.exact && mO(e.exact, \"\".concat(t, \".exact\"), 1, 1 / 0), void 0 !== e.ideal && mO(e.ideal, \"\".concat(t, \".ideal\"), 1, 1 / 0);\n      } else mO(e, t, 1, 1 / 0);\n    }\n    function SO(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255,\n        r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];\n      if (null == e) throw new pO(hO.INVALID_PARAMS, \"\".concat(t || \"param\", \" cannot be empty\"));\n      if (!RO(e, i, n, r)) throw new pO(hO.INVALID_PARAMS, \"Invalid \".concat(t || \"string param\", \": Length of the string: [\").concat(i, \",\").concat(n, \"].\").concat(r ? \" ASCII characters only.\" : \"\"));\n    }\n    function gO(e, t) {\n      if (!Array.isArray(e)) throw new pO(hO.INVALID_PARAMS, \"\".concat(t, \" should be an array\"));\n    }\n    function TO(e) {\n      return null == e;\n    }\n    function RO(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255,\n        n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n      return \"string\" == typeof e && e.length <= i && e.length >= t && (!n || function (e) {\n        if (\"string\" != typeof e) return !1;\n        for (let t = 0; t < e.length; t += 1) {\n          const i = e.charCodeAt(t);\n          if (i < 0 || i > 255) return !1;\n        }\n        return !0;\n      }(e));\n    }\n    function CO(e, t, i) {\n      if (\"getBigUint64\" in DataView.prototype) return e.getBigUint64(t, i);\n      const n = e.getUint32(t, i),\n        r = e.getUint32(t + 4, i),\n        o = Number(!!i),\n        s = Number(!i);\n      return BigInt(n * s + r * o) << BigInt(32) | BigInt(n * o + r * s);\n    }\n    function vO(e, t, i, n) {\n      if (\"setBigUint64\" in DataView.prototype) return e.setBigUint64(t, i, n);\n      const r = Number(i >> BigInt(32)),\n        o = Number(i & BigInt(4294967295));\n      n ? (e.setUint32(t + 4, r, n), e.setUint32(t, o, n)) : (e.setUint32(t, r, n), e.setUint32(t + 4, o, n));\n    }\n    var yO = function (e) {\n        return e.COVERED = \"COVERED\", e.POSITION = \"POSITION\", e.SIZE = \"SIZE\", e.STYLE = \"STYLE\", e;\n      }(yO || {}),\n      IO = function (e) {\n        return e.UNMOUNTED = \"UNMOUNTED\", e.INVALID_HTML_ELEMENT = \"INVALID_HTML_ELEMENT\", e;\n      }(IO || {});\n    const AO = new class {\n      constructor() {\n        dO(this, \"_clientSize\", null), dO(this, \"getClientWidth\", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), dO(this, \"getClientHeight\", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), dO(this, \"getStyle\", e => window.getComputedStyle(e, null)), dO(this, \"checkCssVisibleProperty\", e => {\n          var t;\n          let i = !0;\n          const n = this.getStyle(e),\n            {\n              display: r,\n              visibility: o,\n              opacity: s,\n              filter: a\n            } = n;\n          return (\"none\" === r || Ln(t = [\"hidden\", \"collapse\"]).call(t, o) || Number(s) < .1) && (i = !1), !!i && (a && a.split(\" \").filter(e => {\n            var t;\n            const i = e.split(\"(\")[0];\n            return Ln(t = [\"brightness\", \"blur\", \"opacity\"]).call(t, i);\n          }).map(e => {\n            const [t, i] = e.split(/\\(|\\)/);\n            return [t, Number(i.match(/^[0-9\\.]+/))];\n          }).forEach(e => {\n            const [t, n] = e;\n            switch (t) {\n              case \"brightness\":\n                (n < .1 || n > 3) && (i = !1);\n                break;\n              case \"blur\":\n                n > 3 && (i = !1);\n                break;\n              case \"opacity\":\n                n < .1 && (i = !1);\n            }\n          }), i);\n        }), dO(this, \"checkPropertyUpToAllParentNodes\", (e, t) => {\n          let i = !0,\n            n = !0;\n          const r = e => t(e);\n          let o = e;\n          for (; o && n;) r(o) || (i = !1, n = !1), o = o.parentElement, o || (n = !1);\n          return i;\n        }), dO(this, \"checkActualCssVisibleIncludeInherit\", e => this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty)), dO(this, \"getSizeAboutClient\", e => {\n          const {\n              width: t,\n              height: i,\n              left: n,\n              right: r,\n              top: o,\n              bottom: s\n            } = e.getBoundingClientRect(),\n            a = this.getClientWidth(),\n            c = this.getClientHeight();\n          return {\n            width: t,\n            height: i,\n            left: n,\n            right: r,\n            top: o,\n            bottom: s,\n            clientWidth: a,\n            clientHeight: c,\n            clientMin: Math.min(a, c)\n          };\n        }), dO(this, \"checkActualSize\", () => {\n          const {\n            width: e,\n            height: t,\n            clientMin: i\n          } = this._clientSize;\n          return this.checkSizeIsVisible(e, t, i);\n        }), dO(this, \"elementFromPoint\", (e, t) => document.elementFromPoint ? document.elementFromPoint(e, t) : null), dO(this, \"checkCoverForAPoint\", (e, t, i) => {\n          const n = this.elementFromPoint(e, t);\n          return null !== n && n !== i;\n        }), dO(this, \"getPointPositionList\", () => {\n          const {\n              width: e,\n              height: t,\n              left: i,\n              top: n\n            } = this._clientSize,\n            r = e / 6,\n            o = t / 6,\n            s = [],\n            a = 10 ** 6;\n          for (let e = 0; e < 5; e++) for (let t = 0; t < 5; t++) {\n            const c = (i * a + (0 === e ? .1 : 4 === e ? (r * e * a - 1e5) / a : r * e) * a) / a,\n              d = (n * a + (0 === t ? .1 : 4 === t ? (o * t * a - 1e5) / a : o * t) * a) / a;\n            s.push({\n              x: c,\n              y: d\n            });\n          }\n          return [...s];\n        }), dO(this, \"checkElementCover\", e => this.getPointPositionList().map(t => this.checkCoverForAPoint(t.x, t.y, e)).filter(e => !!e).length > 6), dO(this, \"checkSizeIsVisible\", (e, t, i) => (e > 50 || i / e <= 10) && (t > 50 || i / t <= 10)), dO(this, \"checkSizeOfPartInClient\", () => {\n          const {\n            left: e,\n            right: t,\n            top: i,\n            bottom: n,\n            clientHeight: r,\n            clientWidth: o,\n            clientMin: s\n          } = this._clientSize;\n          let a, c, d, l;\n          if (e < 0) a = 0;else {\n            if (!(e < o)) return !1;\n            a = e;\n          }\n          if (t < 0) return !1;\n          if (c = t < o ? t : o, i < 0) d = 0;else {\n            if (!(i < r)) return !1;\n            d = i;\n          }\n          if (n < 0) return !1;\n          l = n < r ? n : r;\n          const u = c - a,\n            h = l - d;\n          return this.checkSizeIsVisible(u, h, s);\n        }), dO(this, \"returnHiddenResult\", e => (this._clientSize = null, {\n          visible: !1,\n          reason: e\n        })), dO(this, \"checkOneElementVisible\", e => {\n          if (e instanceof HTMLElement) {\n            if (this.checkElementIsMountedOnDom(e)) {\n              if (this.checkActualCssVisibleIncludeInherit(e)) {\n                if (this._clientSize = this.getSizeAboutClient(e), this.checkElementCover(e)) return this.returnHiddenResult(yO.COVERED);\n                {\n                  const e = this.checkActualSize(),\n                    t = this.checkSizeOfPartInClient();\n                  return e && !t ? this.returnHiddenResult(yO.POSITION) : e ? (this._clientSize = null, {\n                    visible: !0\n                  }) : this.returnHiddenResult(yO.SIZE);\n                }\n              }\n              return this.returnHiddenResult(yO.STYLE);\n            }\n            return this.returnHiddenResult(IO.UNMOUNTED);\n          }\n          return this.returnHiddenResult(IO.INVALID_HTML_ELEMENT);\n        }), dO(this, \"checkElementIsMountedOnDom\", e => this.checkPropertyUpToAllParentNodes(e, e => \"HTML\" !== e.nodeName.toUpperCase() ? null !== e.parentElement : !!document.documentElement));\n      }\n    }();\n    function bO(e) {\n      return new TextEncoder().encode(e);\n    }\n    const wO = function (e, t) {\n      const i = new Uint8Array(e.byteLength + t.byteLength);\n      return i.set(new Uint8Array(e), 0), i.set(new Uint8Array(t), e.byteLength), i;\n    };\n    const OO = async e => function (e, t) {\n      let i = \"\";\n      return new Uint8Array(e).forEach(e => {\n        i += e.toString(t).padStart(2, \"0\");\n      }), i;\n    }(await crypto.subtle.digest(\"SHA-256\", bO(e)), 16);\n    let NO = class {\n      constructor() {\n        dO(this, \"_events\", {}), dO(this, \"addListener\", this.on);\n      }\n      getListeners(e) {\n        return this._events[e] ? this._events[e].map(e => e.listener) : [];\n      }\n      on(e, t) {\n        this._events[e] || (this._events[e] = []);\n        const i = this._events[e];\n        -1 === this._indexOfListener(i, t) && i.push({\n          listener: t,\n          once: !1\n        });\n      }\n      once(e, t) {\n        this._events[e] || (this._events[e] = []);\n        const i = this._events[e];\n        -1 === this._indexOfListener(i, t) && i.push({\n          listener: t,\n          once: !0\n        });\n      }\n      off(e, t) {\n        if (!this._events[e]) return;\n        const i = this._events[e],\n          n = this._indexOfListener(i, t);\n        -1 !== n && i.splice(n, 1), 0 === this._events[e].length && delete this._events[e];\n      }\n      removeAllListeners(e) {\n        e ? delete this._events[e] : this._events = {};\n      }\n      emit(e) {\n        this._events[e] || (this._events[e] = []);\n        const t = this._events[e].map(e => e);\n        for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n        for (let i = 0; i < t.length; i += 1) {\n          const r = t[i];\n          r.once && this.off(e, r.listener), r.listener.apply(this, n || []);\n        }\n      }\n      safeEmit(e) {\n        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];\n        [...(this._events[e] || [])].forEach(t => {\n          t.once && this.off(e, t.listener);\n          try {\n            t.listener.apply(this, i);\n          } catch (t) {\n            console.error(\"safeEmit event:\".concat(e, \" error \").concat(null == t ? void 0 : t.toString()));\n          }\n        });\n      }\n      _indexOfListener(e, t) {\n        let i = e.length;\n        for (; i--;) if (e[i].listener === t) return i;\n        return -1;\n      }\n    };\n    let DO = null;\n    function PO() {\n      if (DO) return DO;\n      if (window.electron) return DO = window.electron;\n      if (!window.require) return null;\n      try {\n        return DO = window.require(\"electron\"), DO;\n      } catch (e) {\n        return null;\n      }\n    }\n    let LO = function (e) {\n        return e.CREATE_CLIENT = \"createClient\", e.CHECK_SYSTEM_REQUIREMENTS = \"checkSystemRequirements\", e.SET_AREA = \"setArea\", e.PRELOAD = \"PRELOAD\", e.CHECK_VIDEO_TRACK_IS_ACTIVE = \"checkVideoTrackIsActive\", e.CHECK_AUDIO_TRACK_IS_ACTIVE = \"checkAudioTrackIsActive\", e.CREATE_MIC_AUDIO_TRACK = \"createMicrophoneAudioTrack\", e.CREATE_CUSTOM_AUDIO_TRACK = \"createCustomAudioTrack\", e.CREATE_BUFFER_AUDIO_TRACK = \"createBufferSourceAudioTrack\", e.CREATE_CAM_VIDEO_TRACK = \"createCameraVideoTrack\", e.CREATE_CUSTOM_VIDEO_TRACK = \"createCustomVideoTrack\", e.CREATE_MIC_AND_CAM_TRACKS = \"createMicrophoneAndCameraTracks\", e.CREATE_SCREEN_VIDEO_TRACK = \"createScreenVideoTrack\", e.SET_ENCRYPTION_CONFIG = \"Client.setEncryptionConfig\", e.START_PROXY_SERVER = \"Client.startProxyServer\", e.STOP_PROXY_SERVER = \"Client.stopProxyServer\", e.SET_PROXY_SERVER = \"Client.setProxyServer\", e.SET_TURN_SERVER = \"Client.setTurnServer\", e.SET_CLIENT_ROLE = \"Client.setClientRole\", e.SET_LOW_STREAM_PARAMETER = \"Client.setLowStreamParameter\", e.ENABLE_DUAL_STREAM = \"Client.enableDualStream\", e.DISABLE_DUAL_STREAM = \"Client.disableDualStream\", e.JOIN = \"Client.join\", e.LEAVE = \"Client.leave\", e.PUBLISH = \"Client.publish\", e.UNPUBLISH = \"Client.unpublish\", e.SUBSCRIBE = \"Client.subscribe\", e.MASS_SUBSCRIBE = \"Client.massSubscribe\", e.MASS_UNSUBSCRIBE = \"Client.massUnsubscribe\", e.UNSUBSCRIBE = \"Client.unsubscribe\", e.RENEW_TOKEN = \"Client.renewToken\", e.SET_REMOTE_VIDEO_STREAM_TYPE = \"Client.setRemoteVideoStreamType\", e.SET_STREAM_FALLBACK_OPTION = \"Client.setStreamFallbackOption\", e.ENABLE_AUDIO_VOLUME_INDICATOR = \"Client.enableAudioVolumeIndicator\", e.SEND_CUSTOM_REPORT_MESSAGE = \"Client.sendCustomReportMessage\", e.INSPECT_VIDEO_CONTENT = \"Client.inspectVideoContent\", e.STOP_INSPECT_VIDEO_CONTENT = \"Client.stopInspectVideoContent\", e.JOIN_FALLBACK_TO_PROXY = \"Client._joinFallbackToProxy\", e.ON_LIVE_STREAM_WARNING = \"Client.onLiveStreamWarning\", e.ON_LIVE_STREAM_ERROR = \"Client.onLiveStreamingError\", e.START_LIVE_STREAMING = \"Client.startLiveStreaming\", e.SET_LIVE_TRANSCODING = \"Client.setLiveTranscoding\", e.STOP_LIVE_STREAMING = \"Client.stopLiveStreaming\", e.START_CHANNEL_MEDIA_RELAY = \"Client.startChannelMediaRelay\", e.UPDATE_CHANNEL_MEDIA_RELAY = \"Client.updateChannelMediaRelay\", e.STOP_CHANNEL_MEDIA_RELAY = \"Client.stopChannelMediaRelay\", e.REQUEST_CONFIG_DISTRIBUTE = \"_config-distribute-request\", e.SET_CONFIG_DISTRIBUTE = \"_configDistribute\", e.LOCAL_TRACK_SET_MUTED = \"LocalTrack.setMute\", e.LOCAL_AUDIO_TRACK_PLAY = \"LocalAudioTrack.play\", e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = \"LocalAudioTrack.playInElement\", e.LOCAL_AUDIO_TRACK_STOP = \"LocalAudioTrack.stop\", e.LOCAL_AUDIO_TRACK_SET_VOLUME = \"LocalAudioTrack.setVolume\", e.MIC_AUDIO_TRACK_SET_DEVICE = \"MicrophoneAudioTrack.setDevice\", e.BUFFER_AUDIO_TRACK_START = \"BufferSourceAudioTrack.startProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_STOP = \"BufferSourceAudioTrack.stopProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_PAUSE = \"BufferSourceAudioTrack.pauseProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_RESUME = \"BufferSourceAudioTrack.resumeProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_SEEK = \"BufferSourceAudioTrack.seekAudioBuffer\", e.LOCAL_VIDEO_TRACK_PLAY = \"LocalVideoTrack.play\", e.LOCAL_VIDEO_TRACK_STOP = \"LocalVideoTrack.stop\", e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"LocalVideoTrack.getVideoElementVisibleStatus\", e.LOCAL_VIDEO_TRACK_BEAUTY = \"LocalVideoTrack.setBeautyEffect\", e.LOCAL_VIDEO_SEND_SEI_DATA = \"LocalVideoTrack.sendSeiData\", e.CAM_VIDEO_TRACK_SET_DEVICE = \"CameraVideoTrack.setDevice\", e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = \"CameraVideoTrack.setEncoderConfiguration\", e.REMOTE_VIDEO_TRACK_PLAY = \"RemoteVideoTrack.play\", e.REMOTE_VIDEO_TRACK_STOP = \"RemoteVideoTrack.stop\", e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"RemoteVideoTrack.getVideoElementVisibleStatus\", e.REMOTE_AUDIO_TRACK_PLAY = \"RemoteAudioTrack.play\", e.REMOTE_AUDIO_TRACK_STOP = \"RemoteAudioTrack.stop\", e.REMOTE_AUDIO_SET_VOLUME = \"RemoteAudioTrack.setVolume\", e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = \"RemoteAudioTrack.setOutputDevice\", e.GET_MEDIA_STREAM_TRACK = \"Track.getMediaStreamTrack\", e.STREAM_TYPE_CHANGE = \"streamTypeChange\", e.CONNECTION_STATE_CHANGE = \"connectionStateChange\", e.LOAD_CONFIG_FROM_LOCALSTORAGE = \"loadConfigFromLocalStorage\", e.IMAGE_MODERATION_UPLOAD = \"imageModerationUpload\", e.REPUB_AFTER_PC_CONNECTED = \"repubAfterPCConnected\", e.PRELOAD_MEDIA_FAILED = \"preloadMediaFailed\", e.MISMATCH_DTLS_PARAMETERS = \"mismatchDtlsParameters\", e.VOS_FALLBACK_CN = \"vosFallbackCN\", e.DATACHANNEL_FAILBACK = \"datachannelFailback\", e;\n      }({}),\n      kO = function (e) {\n        return e.TRACER = \"tracer\", e;\n      }({});\n    function MO(e) {\n      return mO(e.timeout, \"config.timeout\", 0, 1e5), mO(e.timeoutFactor, \"config.timeoutFactor\", 0, 100, !1), mO(e.maxRetryCount, \"config.maxRetryConfig\", 0, 1 / 0), mO(e.maxRetryTimeout, \"config.maxRetryTimeout\", 0, 1 / 0), !0;\n    }\n    let UO = function (e) {\n        return e[e.AUDIENCE_LEVEL_LOW_LATENCY = 1] = \"AUDIENCE_LEVEL_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = \"AUDIENCE_LEVEL_ULTRA_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = \"AUDIENCE_LEVEL_SYNC_LATENCY\", e;\n      }({}),\n      VO = function (e) {\n        return e.LEAVE = \"LEAVE\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.UID_BANNED = \"UID_BANNED\", e.FALLBACK = \"FALLBACK\", e.IP_BANNED = \"IP_BANNED\", e.CHANNEL_BANNED = \"CHANNEL_BANNED\", e.LICENSE_MISSING = \"LICENSE_MISSING\", e.LICENSE_EXPIRED = \"LICENSE_EXPIRED\", e.LICENSE_MINUTES_EXCEEDED = \"LICENSE_MINUTES_EXCEEDED\", e.LICENSE_PERIOD_INVALID = \"LICENSE_PERIOD_INVALID\", e.LICENSE_MULTIPLE_SDK_SERVICE = \"LICENSE_MULTIPLE_SDK_SERVICE\", e.LICENSE_ILLEGAL = \"LICENSE_ILLEGAL\", e.TOKEN_EXPIRE = \"TOKEN_EXPIRE\", e.FALLBACK_TO_HLS = \"FALLBACK_TO_HLS\", e.UID_CONFLICT = \"UID_CONFLICT\", e;\n      }({});\n    function xO(e) {\n      if (!Array.isArray(e) || e.length < 1) return !1;\n      try {\n        e.forEach(e => {\n          if (!e.urls) throw Error();\n        });\n      } catch (e) {\n        return !1;\n      }\n      return !0;\n    }\n    function FO(e) {\n      return SO(e.turnServerURL, \"turnServerURL\"), SO(e.username, \"username\"), SO(e.password, \"password\"), e.udpport && mO(e.udpport, \"udpport\", 1, 99999, !0), e.forceturn && _O(e.forceturn, \"forceturn\"), e.security && _O(e.security, \"security\"), e.tcpport && mO(e.tcpport, \"tcpport\", 1, 99999, !0), !0;\n    }\n    let BO = function (e) {\n      return e[e.AUTO_SIMULCAST_STREAM = -1] = \"AUTO_SIMULCAST_STREAM\", e[e.DISABLE_SIMULCAST_STREM = 0] = \"DISABLE_SIMULCAST_STREM\", e[e.ENABLE_SIMULCAST_STREAM = 1] = \"ENABLE_SIMULCAST_STREAM\", e;\n    }({});\n    function jO(e) {\n      return void 0 !== e.level && EO(e.level, \"level\", [1, 2, 3]), void 0 !== e.delay && mO(e.delay, \"delay\", 0, 3e3, !0), !0;\n    }\n    let GO = function (e) {\n        return e.PEERCONNECTION_STATE_CHANGE = \"peerconnection-state-change\", e.AUDIO_METADATA = \"audio-metadata\", e.AUDIO_PTS = \"audio-pts\", e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.MEDIA_RECONNECT_START = \"media-reconnect-start\", e.MEDIA_RECONNECT_END = \"media-reconnect-end\", e.IS_USING_CLOUD_PROXY = \"is-using-cloud-proxy\", e.USER_JOINED = \"user-joined\", e.USER_LEAVED = \"user-left\", e.USER_PUBLISHED = \"user-published\", e.USER_UNPUBLISHED = \"user-unpublished\", e.USER_INFO_UPDATED = \"user-info-updated\", e.CLIENT_BANNED = \"client-banned\", e.CHANNEL_MEDIA_RELAY_STATE = \"channel-media-relay-state\", e.CHANNEL_MEDIA_RELAY_EVENT = \"channel-media-relay-event\", e.VOLUME_INDICATOR = \"volume-indicator\", e.CRYPT_ERROR = \"crypt-error\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"token-privilege-will-expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"token-privilege-did-expire\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGED = \"stream-type-changed\", e.STREAM_FALLBACK = \"stream-fallback\", e.RECEIVE_METADATA = \"receive-metadata\", e.STREAM_MESSAGE = \"stream-message\", e.LIVE_STREAMING_ERROR = \"live-streaming-error\", e.LIVE_STREAMING_WARNING = \"live-streaming-warning\", e.EXCEPTION = \"exception\", e.ERROR = \"error\", e.P2P_LOST = \"p2p_lost\", e.JOIN_FALLBACK_TO_PROXY = \"join-fallback-to-proxy\", e.CHANNEL_FALLBACK_TO_WEBSOCKET = \"channel-fallback-to-websocket\", e.MEDIA_CONNECTION_TYPE_CHANGE = \"media-connection-type-change\", e.PUBLISHED_USER_LIST = \"published-user-list\", e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = \"content-inspect-connection-state-change\", e.CONTENT_INSPECT_ERROR = \"content-inspect-error\", e.CONTENT_INSPECT_RESULT = \"content-inspect-result\", e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = \"image-moderation-connection-state-change\", e.FALLBACK_TO_HLS = \"fallback-to-hls\", e.FIRST_VIDEO_BUFFER_READY = \"first-video-buffer-ready\", e.FIRST_VIDEO_PRE_RENDER = \"first-video-pre-render\", e.AV1_DECODABLE_RESULT = \"av1-decodable-result\", e;\n      }({}),\n      WO = function (e) {\n        return e.CONFIG = \"config\", e.VOSERROR = \"vos_error\", e.AP_ERROR = \"ap_error\", e;\n      }({}),\n      HO = function (e) {\n        return e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\", e.REGIONAL_DISTRIBUTION = \"REGIONAL_DISTRIBUTION\", e;\n      }({}),\n      KO = function (e) {\n        return e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\", e;\n      }({}),\n      YO = function (e) {\n        return e.NETWORK_STATE_CHANGE = \"NETWORK_STATE_CHANGE\", e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\", e;\n      }({});\n    function zO(e, t) {\n      for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n      return 0 === e.getListeners(t).length ? rp.reject(new pO(hO.UNEXPECTED_ERROR, \"can not emit promise\")) : new rp((i, r) => {\n        e.emit(t, ...n, i, r);\n      });\n    }\n    function qO(e, t) {\n      if (0 === e.getListeners(t).length) return rp.resolve();\n      for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n      return zO(e, t, ...n);\n    }\n    function XO(e, t) {\n      if (0 === e.getListeners(t).length) return null;\n      for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n      return JO(e, t, ...n);\n    }\n    function JO(e, t) {\n      let i = null,\n        n = null;\n      for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++) o[s - 2] = arguments[s];\n      if (e.emit(t, ...o, e => {\n        i = e;\n      }, e => {\n        n = e;\n      }), null !== n) throw n;\n      if (null === i) throw new pO(hO.UNEXPECTED_ERROR, \"handler is not sync\");\n      return i;\n    }\n    const QO = new class extends NO {\n        set networkState(e) {\n          this.emit(YO.NETWORK_STATE_CHANGE, e, this._networkState), e === KO.ONLINE ? this.emit(YO.ONLINE) : e === KO.OFFLINE && (this.onlineWaiter = new rp(e => {\n            this.once(YO.ONLINE, () => {\n              this.onlineWaiter = void 0, e(KO.ONLINE);\n            });\n          }), this.emit(YO.OFFLINE)), this._networkState = e;\n        }\n        get networkState() {\n          return this._networkState;\n        }\n        get isOnline() {\n          return this._networkState === KO.ONLINE;\n        }\n        constructor() {\n          super(), dO(this, \"_moduleName\", \"network-indicator\"), dO(this, \"_networkState\", KO.ONLINE), dO(this, \"onlineWaiter\", void 0), window.addEventListener(\"online\", () => {\n            this.networkState = KO.ONLINE;\n          }), window.addEventListener(\"offline\", () => {\n            this.networkState = KO.OFFLINE;\n          });\n        }\n      }(),\n      ZO = [];\n    for (let e = 0; e < 256; ++e) ZO.push((e + 256).toString(16).slice(1));\n    const $O = \"undefined\" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n    let eN;\n    const tN = new Uint8Array(16);\n    function iN() {\n      return $O ? $O() : function (e, t, i) {\n        var n, r, o, s;\n        const a = null !== (n = null !== (r = (e = e || {}).random) && void 0 !== r ? r : null === (o = (s = e).rng) || void 0 === o ? void 0 : o.call(s)) && void 0 !== n ? n : function () {\n          if (!eN) {\n            if (\"undefined\" == typeof crypto || !crypto.getRandomValues) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n            eN = crypto.getRandomValues.bind(crypto);\n          }\n          return eN(tN);\n        }();\n        if (a.length < 16) throw new Error(\"Random bytes length must be >= 16\");\n        if (a[6] = 15 & a[6] | 64, a[8] = 63 & a[8] | 128, t) {\n          if ((i = i || 0) < 0 || i + 16 > t.length) throw new RangeError(\"UUID byte range \".concat(i, \":\").concat(i + 15, \" is out of buffer bounds\"));\n          for (let e = 0; e < 16; ++e) t[i + e] = a[e];\n          return t;\n        }\n        return function (e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n          return (ZO[e[t + 0]] + ZO[e[t + 1]] + ZO[e[t + 2]] + ZO[e[t + 3]] + \"-\" + ZO[e[t + 4]] + ZO[e[t + 5]] + \"-\" + ZO[e[t + 6]] + ZO[e[t + 7]] + \"-\" + ZO[e[t + 8]] + ZO[e[t + 9]] + \"-\" + ZO[e[t + 10]] + ZO[e[t + 11]] + ZO[e[t + 12]] + ZO[e[t + 13]] + ZO[e[t + 14]] + ZO[e[t + 15]]).toLowerCase();\n        }(a);\n      }(e, t, undefined);\n      var e, t;\n    }\n    function nN(e, t) {\n      const i = e.indexOf(t);\n      -1 !== i && e.splice(i, 1);\n    }\n    function rN(e) {\n      const t = [];\n      return e.forEach(e => {\n        -1 === t.indexOf(e) && t.push(e);\n      }), t;\n    }\n    function oN(e) {\n      void 0 !== rp ? rp.resolve().then(e) : setTimeout(e, 0);\n    }\n    function sN(e) {\n      return JSON.parse(JSON.stringify(e));\n    }\n    function aN(e) {\n      try {\n        return sN(e);\n      } catch (t) {\n        return e;\n      }\n    }\n    const cN = {};\n    function dN(e, t) {\n      cN[t] || (cN[t] = !0, e());\n    }\n    function lN(e) {\n      const t = window.atob(e),\n        i = new Uint8Array(new ArrayBuffer(t.length));\n      for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);\n      return i;\n    }\n    function uN(e) {\n      let t = \"\";\n      for (let i = 0; i < e.length; i += 1) t += String.fromCharCode(e[i]);\n      return window.btoa(t);\n    }\n    function hN(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,\n        i = new TextEncoder().encode(e);\n      if (i.length > t) i = i.slice(0, t);else if (i.length < t) {\n        const e = new Uint8Array(t);\n        e.set(i), i = e;\n      }\n      return i;\n    }\n    function pN() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = nr(t).call(t, (e, t) => e + t.length, 0),\n        r = new Uint8Array(new ArrayBuffer(n));\n      let o = 0;\n      return t.forEach(e => {\n        r.set(e, o), o += e.length;\n      }), r;\n    }\n    function _N(e) {\n      return window.TextEncoder ? new TextEncoder().encode(e).length : e.length;\n    }\n    function EN(e) {\n      let t = 0;\n      return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e.realFormData && (e = e.realFormData), e.forEach(e => {\n        t += \"string\" == typeof e ? _N(e) : e.size;\n      }), t + 138;\n    }\n    function mN(e) {\n      const t = new pO(hO.TIMEOUT, \"timeout\");\n      return new rp((i, n) => {\n        window.setTimeout(() => n(t), e);\n      });\n    }\n    function fN(e) {\n      return new rp(t => {\n        window.setTimeout(t, e);\n      });\n    }\n    function SN() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,\n        t = arguments.length > 1 ? arguments[1] : void 0;\n      const i = Math.random().toString(16).substr(2, e).toLowerCase();\n      return i.length === e ? \"\".concat(t).concat(i) : \"\".concat(t).concat(i) + SN(e - i.length, \"\");\n    }\n    function gN() {\n      let e,\n        t = !1;\n      try {\n        var i;\n        e = MT(i = iN()).call(i, \"-\", \"\");\n      } catch (e) {\n        t = !0;\n      }\n      return !t && e && 32 === e.length || (e = SN(32, \"\")), e.toUpperCase();\n    }\n    const TN = () => {},\n      RN = new class {\n        constructor() {\n          dO(this, \"fnMap\", new Map());\n        }\n        throttleByKey(e, t, i, n) {\n          for (var r = arguments.length, o = new Array(r > 4 ? r - 4 : 0), s = 4; s < r; s++) o[s - 4] = arguments[s];\n          if (this.fnMap.has(t)) {\n            const r = this.fnMap.get(t);\n            if (r.threshold !== i) {\n              r.fn(...r.args), clearTimeout(r.timer);\n              const s = window.setTimeout(() => {\n                const e = this.fnMap.get(t);\n                e && e.fn(...e.args), this.fnMap.delete(t);\n              }, i);\n              this.fnMap.set(t, {\n                fn: e,\n                threshold: i,\n                timer: s,\n                args: o,\n                skipFn: n\n              });\n            } else r.skipFn && r.skipFn(...r.args), this.fnMap.set(t, uO(uO({}, r), {}, {\n              fn: e,\n              args: o,\n              skipFn: n\n            }));\n          } else {\n            const r = window.setTimeout(() => {\n              const e = this.fnMap.get(t);\n              e && e.fn(...e.args), this.fnMap.delete(t);\n            }, i);\n            this.fnMap.set(t, {\n              fn: e,\n              threshold: i,\n              timer: r,\n              args: o,\n              skipFn: n\n            });\n          }\n        }\n      }(),\n      CN = RN.throttleByKey.bind(RN);\n    function vN(e) {\n      return \"object\" == typeof e && null !== e && !(e instanceof RegExp);\n    }\n    function yN(e, t) {\n      if (!vN(e) || !vN(t)) return t;\n      if (Array.isArray(e) && !Array.isArray(t) || !Array.isArray(e) && Array.isArray(t)) return t;\n      if (Array.isArray(t) && Array.isArray(e)) {\n        const i = [...e];\n        for (let n = 0; n < t.length; n++) i[n] = yN(e[n], t[n]);\n        return i;\n      }\n      {\n        const i = uO({}, e);\n        for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (Object.prototype.hasOwnProperty.call(e, n) ? i[n] = yN(e[n], t[n]) : i[n] = t[n]);\n        return i;\n      }\n    }\n    function IN(e, t) {\n      let i = [0];\n      if (t && (i = new Array(t).fill(0)), 0 === e) return i;\n      let n = 0;\n      for (; e > 0 && (i[n] = 255 & e, e >>= 8, n++, !t || n !== t););\n      return i;\n    }\n    function AN(e) {\n      return \"number\" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;\n    }\n    function bN(e, t) {\n      try {\n        return \"object\" == typeof e && \"object\" == typeof t && JSON.stringify(e) === JSON.stringify(t);\n      } catch (e) {\n        return !1;\n      }\n    }\n    function wN(e) {\n      return nr(e).call(e, (e, t) => e + t, 0);\n    }\n    function ON(e) {\n      const t = \"0123456789abcdef\";\n      function i(e) {\n        let i,\n          n = \"\";\n        for (i = 0; i <= 3; i++) n += t.charAt(e >> 8 * i + 4 & 15) + t.charAt(e >> 8 * i & 15);\n        return n;\n      }\n      function n(e, t) {\n        const i = (65535 & e) + (65535 & t);\n        return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i;\n      }\n      function r(e, t, i, r, o, s) {\n        return n(function (e, t) {\n          return e << t | e >>> 32 - t;\n        }(n(n(t, e), n(r, s)), o), i);\n      }\n      function o(e, t, i, n, o, s, a) {\n        return r(t & i | ~t & n, e, t, o, s, a);\n      }\n      function s(e, t, i, n, o, s, a) {\n        return r(t & n | i & ~n, e, t, o, s, a);\n      }\n      function a(e, t, i, n, o, s, a) {\n        return r(t ^ i ^ n, e, t, o, s, a);\n      }\n      function c(e, t, i, n, o, s, a) {\n        return r(i ^ (t | ~n), e, t, o, s, a);\n      }\n      const d = function (e) {\n        let t;\n        const i = 1 + (e.length + 8 >> 6),\n          n = new Array(16 * i);\n        for (t = 0; t < 16 * i; t++) n[t] = 0;\n        for (t = 0; t < e.length; t++) n[t >> 2] |= e.charCodeAt(t) << t % 4 * 8;\n        return n[t >> 2] |= 128 << t % 4 * 8, n[16 * i - 2] = 8 * e.length, n;\n      }(e);\n      let l,\n        u,\n        h,\n        p,\n        _,\n        E = 1732584193,\n        m = -271733879,\n        f = -1732584194,\n        S = 271733878;\n      for (l = 0; l < d.length; l += 16) u = E, h = m, p = f, _ = S, E = o(E, m, f, S, d[l + 0], 7, -680876936), S = o(S, E, m, f, d[l + 1], 12, -389564586), f = o(f, S, E, m, d[l + 2], 17, 606105819), m = o(m, f, S, E, d[l + 3], 22, -1044525330), E = o(E, m, f, S, d[l + 4], 7, -176418897), S = o(S, E, m, f, d[l + 5], 12, 1200080426), f = o(f, S, E, m, d[l + 6], 17, -1473231341), m = o(m, f, S, E, d[l + 7], 22, -45705983), E = o(E, m, f, S, d[l + 8], 7, 1770035416), S = o(S, E, m, f, d[l + 9], 12, -1958414417), f = o(f, S, E, m, d[l + 10], 17, -42063), m = o(m, f, S, E, d[l + 11], 22, -1990404162), E = o(E, m, f, S, d[l + 12], 7, 1804603682), S = o(S, E, m, f, d[l + 13], 12, -40341101), f = o(f, S, E, m, d[l + 14], 17, -1502002290), m = o(m, f, S, E, d[l + 15], 22, 1236535329), E = s(E, m, f, S, d[l + 1], 5, -165796510), S = s(S, E, m, f, d[l + 6], 9, -1069501632), f = s(f, S, E, m, d[l + 11], 14, 643717713), m = s(m, f, S, E, d[l + 0], 20, -373897302), E = s(E, m, f, S, d[l + 5], 5, -701558691), S = s(S, E, m, f, d[l + 10], 9, 38016083), f = s(f, S, E, m, d[l + 15], 14, -660478335), m = s(m, f, S, E, d[l + 4], 20, -405537848), E = s(E, m, f, S, d[l + 9], 5, 568446438), S = s(S, E, m, f, d[l + 14], 9, -1019803690), f = s(f, S, E, m, d[l + 3], 14, -187363961), m = s(m, f, S, E, d[l + 8], 20, 1163531501), E = s(E, m, f, S, d[l + 13], 5, -1444681467), S = s(S, E, m, f, d[l + 2], 9, -51403784), f = s(f, S, E, m, d[l + 7], 14, 1735328473), m = s(m, f, S, E, d[l + 12], 20, -1926607734), E = a(E, m, f, S, d[l + 5], 4, -378558), S = a(S, E, m, f, d[l + 8], 11, -2022574463), f = a(f, S, E, m, d[l + 11], 16, 1839030562), m = a(m, f, S, E, d[l + 14], 23, -35309556), E = a(E, m, f, S, d[l + 1], 4, -1530992060), S = a(S, E, m, f, d[l + 4], 11, 1272893353), f = a(f, S, E, m, d[l + 7], 16, -155497632), m = a(m, f, S, E, d[l + 10], 23, -1094730640), E = a(E, m, f, S, d[l + 13], 4, 681279174), S = a(S, E, m, f, d[l + 0], 11, -358537222), f = a(f, S, E, m, d[l + 3], 16, -722521979), m = a(m, f, S, E, d[l + 6], 23, 76029189), E = a(E, m, f, S, d[l + 9], 4, -640364487), S = a(S, E, m, f, d[l + 12], 11, -421815835), f = a(f, S, E, m, d[l + 15], 16, 530742520), m = a(m, f, S, E, d[l + 2], 23, -995338651), E = c(E, m, f, S, d[l + 0], 6, -198630844), S = c(S, E, m, f, d[l + 7], 10, 1126891415), f = c(f, S, E, m, d[l + 14], 15, -1416354905), m = c(m, f, S, E, d[l + 5], 21, -57434055), E = c(E, m, f, S, d[l + 12], 6, 1700485571), S = c(S, E, m, f, d[l + 3], 10, -1894986606), f = c(f, S, E, m, d[l + 10], 15, -1051523), m = c(m, f, S, E, d[l + 1], 21, -2054922799), E = c(E, m, f, S, d[l + 8], 6, 1873313359), S = c(S, E, m, f, d[l + 15], 10, -30611744), f = c(f, S, E, m, d[l + 6], 15, -1560198380), m = c(m, f, S, E, d[l + 13], 21, 1309151649), E = c(E, m, f, S, d[l + 4], 6, -145523070), S = c(S, E, m, f, d[l + 11], 10, -1120210379), f = c(f, S, E, m, d[l + 2], 15, 718787259), m = c(m, f, S, E, d[l + 9], 21, -343485551), E = n(E, u), m = n(m, h), f = n(f, p), S = n(S, _);\n      return i(E) + i(m) + i(f) + i(S);\n    }\n    let NN = 1,\n      DN = console,\n      PN = class {\n        static setLogger(e) {\n          DN = e;\n        }\n        constructor(e, t) {\n          dO(this, \"id\", void 0), dO(this, \"lockingPromise\", rp.resolve()), dO(this, \"locks\", 0), dO(this, \"name\", \"\"), dO(this, \"lockId\", void 0), this.lockId = NN++, e && (this.name = e), t && (this.id = t), this.logger(\"created\");\n        }\n        logger(e, t) {\n          const i = (this.id ? \"[\".concat(this.id, \"]\") : \"\") + \"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"]\"),\n            n = \"created\" === e ? \"is \".concat(e, \".\") : \"is \".concat(e, \", current queue \").concat(this.locks, \". \").concat(null != t ? t : \"\");\n          DN.debug(\"\".concat(i, \" \").concat(n));\n        }\n        setId(e) {\n          this.id = e;\n        }\n        get isLocked() {\n          return this.locks > 0;\n        }\n        lock(e) {\n          let t;\n          this.locks += 1, this.logger(\"locked\", e);\n          const i = new rp(i => {\n              t = () => {\n                this.locks -= 1, this.logger(\"unlocked\", e), i();\n              };\n            }),\n            n = this.lockingPromise.then(() => t);\n          return this.lockingPromise = this.lockingPromise.then(() => i), n;\n        }\n      };\n    function LN(e, t) {\n      return function (i, n, r) {\n        const o = r.value;\n        if (\"function\" != typeof o) throw new Error(\"Cannot use mutex on object property.\");\n        return r.value = async function () {\n          const i = this[t];\n          if (!i) throw new Error(\"mutex property key \".concat(t, \" doesn't exist on \").concat(e));\n          const r = await i.lock(\"From \".concat(e, \".\").concat(n));\n          try {\n            for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];\n            return await o.apply(this, a);\n          } finally {\n            r();\n          }\n        }, r;\n      };\n    }\n    const kN = {\n      timeout: 500,\n      timeoutFactor: 1.5,\n      maxRetryCount: 1 / 0,\n      maxRetryTimeout: 1e4\n    };\n    function MN(e, t) {\n      const i = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e));\n      return Math.min(t.maxRetryTimeout, i);\n    }\n    function UN(e, t, i, n) {\n      const r = Object.assign({}, kN, n);\n      let o = r.timeout;\n      const s = async () => {\n        await function (e) {\n          return new rp(t => {\n            window.setTimeout(t, e);\n          });\n        }(o), o *= r.timeoutFactor, o = Math.min(r.maxRetryTimeout, o);\n      };\n      let a = !1;\n      const c = new rp(async (n, o) => {\n        t = t || (() => !1), i = i || (() => !0);\n        for (let c = 0; c < r.maxRetryCount; c += 1) {\n          if (a) return o(new pO(hO.OPERATION_ABORTED));\n          try {\n            const i = await e();\n            if (!t(i, c)) return n(i);\n            if (c + 1 === r.maxRetryCount) return n(i);\n            await s();\n          } catch (e) {\n            if (!i(e, c)) return o(e);\n            if (c + 1 === r.maxRetryCount) return o(e);\n            await s();\n          }\n        }\n      });\n      return c.cancel = () => a = !0, c;\n    }\n    let VN,\n      xN = class {\n        constructor(e) {\n          dO(this, \"input\", []), dO(this, \"size\", void 0), this.size = e;\n        }\n        add(e) {\n          this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n        }\n        mean() {\n          var e;\n          return 0 === this.input.length ? 0 : nr(e = this.input).call(e, (e, t) => e + t) / this.input.length;\n        }\n      },\n      FN = 0,\n      BN = 0;\n    function jN(e, t, i, n) {\n      return new rp((r, o) => {\n        t.responseType = t.responseType || \"json\", t.data && !i ? (t.data = JSON.stringify(t.data), FN += _N(t.data)) : i && (t.data.size ? FN += t.data.size : t.data instanceof FormData ? FN += EN(t.data) : FN += _N(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers[\"Content-Type\"] = t.headers[\"Content-Type\"] || \"application/json\", t.method = \"POST\", t.url = e, Tw.request(t).then(e => {\n          \"string\" == typeof e.data ? BN += _N(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? BN += e.data.byteLength : BN += _N(JSON.stringify(e.data)), n && r({\n            data: e.data,\n            headers: e.headers\n          }), r(e.data);\n        }).catch(e => {\n          Tw.isCancel(e) ? o(new pO(hO.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === e.code ? o(new pO(hO.NETWORK_TIMEOUT, e.message)) : e.response ? o(new pO(hO.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new pO(hO.NETWORK_ERROR, e.message));\n        });\n      });\n    }\n    async function GN(e, t) {\n      const i = new Blob([t.data], {\n        type: \"buffer\"\n      });\n      return await jN(e, uO(uO({}, t), {}, {\n        data: i,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        }\n      }), !0);\n    }\n    const WN = () => void 0 !== window.isSecureContext;\n    function HN(e) {\n      if (Array.isArray(e)) return e.map(e => e);\n      if (!KN(e)) return e;\n      const t = {};\n      for (const i in e) {\n        const n = e[i];\n        KN(n) || Array.isArray(n) ? t[i] = HN(n) : t[i] = n;\n      }\n      return t;\n    }\n    function KN(e) {\n      return !(\"object\" != typeof e || Array.isArray(e) || !e);\n    }\n    let YN = class {\n      constructor(e) {\n        dO(this, \"input\", []), dO(this, \"size\", void 0), this.size = e;\n      }\n      add(e) {\n        this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n      }\n      diffMean() {\n        return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;\n      }\n    };\n    const zN = {\n        address: \"unknown\",\n        candidateType: \"unknown\",\n        id: \"unknown\",\n        port: 0,\n        priority: 0,\n        protocol: \"unknown\",\n        type: \"unknown\"\n      },\n      qN = {\n        timestamp: 0,\n        bitrate: {\n          actualEncoded: 0,\n          transmit: 0\n        },\n        sendPacketLossRate: 0,\n        recvPacketLossRate: 0,\n        videoRecv: [],\n        videoSend: [],\n        audioRecv: [],\n        audioSend: [],\n        transport: {\n          bytesSent: 0,\n          bytesReceived: 0,\n          packetsSent: 0,\n          packetsReceived: 0\n        },\n        selectedCandidatePair: {\n          id: \"unknown\",\n          localCandidate: zN,\n          remoteCandidate: zN\n        },\n        updateInterval: 0\n      },\n      XN = {\n        firsCount: 0,\n        nacksCount: 0,\n        plisCount: 0,\n        framesDecodeCount: 0,\n        framesDecodeInterval: 0,\n        framesDecodeFreezeTime: 0,\n        decodeFrameRate: 0,\n        bytes: 0,\n        packetsLost: 0,\n        packetLostRate: 0,\n        packets: 0,\n        ssrc: 0,\n        qpSumPerFrame: 0,\n        framesDroppedCount: 0,\n        outputFrameRate: 0,\n        packetsDiscarded: 0,\n        framesAssembledFromMultiplePackets: 0,\n        totalProcessingDelay: 0,\n        avgDecodeMs: 0,\n        avgFramesAssembledFromMultiplePacketsMs: 0,\n        avgProcessingDelayMs: 0,\n        avgInterFrameDelayMs: 0,\n        totalAssemblyTime: 0\n      },\n      JN = {\n        firsCount: 0,\n        nacksCount: 0,\n        plisCount: 0,\n        frameCount: 0,\n        bytes: 0,\n        packets: 0,\n        packetsLost: 0,\n        packetLostRate: 0,\n        ssrc: 0,\n        rttMs: 0,\n        jitterMs: 0,\n        qpSumPerFrame: 0\n      },\n      QN = {\n        bytes: 0,\n        packets: 0,\n        packetsLost: 0,\n        packetLostRate: 0,\n        ssrc: 0,\n        rttMs: 0,\n        jitterMs: 0\n      },\n      ZN = {\n        jitterBufferMs: 0,\n        jitterMs: 0,\n        bytes: 0,\n        packetsLost: 0,\n        packetLostRate: 0,\n        packetsDiscarded: 0,\n        packets: 0,\n        ssrc: 0,\n        receivedFrames: 0,\n        droppedFrames: 0,\n        concealedSamples: 0,\n        totalSamplesReceived: 0,\n        silentConcealedSamples: 0,\n        concealmentEvents: 0,\n        freezeMs80: 0,\n        freezeMs200: 0,\n        freezeSamples80: 0,\n        freezeSamples200: 0\n      };\n    let $N = class {\n        constructor(e, t) {\n          dO(this, \"onFirstVideoReceived\", void 0), dO(this, \"onFirstVideoDecoded\", void 0), dO(this, \"onFirstAudioReceived\", void 0), dO(this, \"onFirstVideoDecodedTimeout\", void 0), dO(this, \"onFirstAudioDecoded\", void 0), dO(this, \"onSelectedLocalCandidateChanged\", void 0), dO(this, \"onSelectedRemoteCandidateChanged\", void 0), dO(this, \"videoIsReady\", !1), dO(this, \"videoIsReady2\", {}), dO(this, \"pc\", void 0), dO(this, \"options\", void 0), dO(this, \"intervalTimer\", void 0), dO(this, \"stats\", HN(qN)), dO(this, \"isFirstVideoReceived\", {}), dO(this, \"isFirstVideoDecoded\", {}), dO(this, \"isFirstAudioReceived\", {}), dO(this, \"isFirstAudioDecoded\", {}), dO(this, \"isFirstVideoDecodedTimeout\", {}), dO(this, \"lossRateWindowStats\", []), this.pc = e, this.options = t, this.intervalTimer = window.setInterval(async () => {\n            this.updateStats();\n          }, this.options.updateInterval);\n        }\n        getStats() {\n          return this.stats;\n        }\n        getSelectedCandidatePair() {\n          return new rp(e => {\n            e({\n              local: uO({}, zN),\n              remote: uO({}, zN)\n            });\n          });\n        }\n        setVideoIsReady(e) {\n          this.videoIsReady = e;\n        }\n        setVideoIsReady2(e, t) {\n          this.videoIsReady2[e] = t;\n        }\n        getVideoIsReady(e) {\n          return this.videoIsReady2[e] || !1;\n        }\n        setIsFirstAudioDecoded(e) {}\n        destroy() {\n          window.clearInterval(this.intervalTimer), this.pc = void 0;\n        }\n        calcLossRate(e) {\n          this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);\n          const t = this.lossRateWindowStats.length,\n            i = [\"videoSend\", \"audioSend\", \"videoRecv\", \"audioRecv\"];\n          let n = 0,\n            r = 0,\n            o = 0,\n            s = 0;\n          for (const a of i) e[a].forEach((e, i) => {\n            if (!this.lossRateWindowStats[t - 1][a][i] || !this.lossRateWindowStats[0][a][i]) return;\n            const c = this.lossRateWindowStats[t - 1][a][i].packets - this.lossRateWindowStats[0][a][i].packets,\n              d = this.lossRateWindowStats[t - 1][a][i].packetsLost - this.lossRateWindowStats[0][a][i].packetsLost;\n            \"videoSend\" === a || \"audioSend\" === a ? (n += c, o += d) : (r += c, s += d), Number.isNaN(c) || Number.isNaN(c) ? e.packetLostRate = 0 : e.packetLostRate = c <= 0 || d <= 0 ? 0 : d / (c + d);\n          });\n          e.sendPacketLossRate = n <= 0 || o <= 0 ? 0 : o / (n + o), e.recvPacketLossRate = r <= 0 || s <= 0 ? 0 : s / (r + s);\n        }\n      },\n      eD = class extends $N {\n        constructor() {\n          super(...arguments), dO(this, \"_stats\", qN), dO(this, \"lastDecodeVideoReceiverStats\", new Map());\n        }\n        async updateStats() {\n          const e = await this._getStats(),\n            t = this.statsResponsesToObjects(e);\n          this._stats = HN(qN);\n          const i = t.filter(e => \"ssrc\" === e.type);\n          this.processSSRCStats(i);\n          const n = t.find(e => \"VideoBwe\" === e.type);\n          n && this.processBandwidthStats(n), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;\n        }\n        processBandwidthStats(e) {\n          this._stats.bitrate = {\n            actualEncoded: Number(e.googActualEncBitrate),\n            targetEncoded: Number(e.googTargetEncBitrate),\n            retransmit: Number(e.googRetransmitBitrate),\n            transmit: Number(e.googTransmitBitrate)\n          }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth);\n        }\n        processSSRCStats(e) {\n          e.forEach(e => {\n            var t;\n            const i = Ln(t = e.id).call(t, \"send\");\n            switch (\"\".concat(e.mediaType, \"_\").concat(i ? \"send\" : \"recv\")) {\n              case \"video_send\":\n                {\n                  const t = HN(JN);\n                  t.codec = e.googCodecName, t.adaptionChangeReason = \"none\", e.googCpuLimitedResolution && (t.adaptionChangeReason = \"cpu\"), e.googBandwidthLimitedResolution && (t.adaptionChangeReason = \"bandwidth\"), t.avgEncodeMs = Number(e.googAvgEncodeMs), t.inputFrame = {\n                    width: Number(e.googFrameWidthInput) || Number(e.googFrameWidthSent),\n                    height: Number(e.googFrameHeightInput) || Number(e.googFrameHeightSent),\n                    frameRate: Number(e.googFrameRateInput)\n                  }, t.sentFrame = {\n                    width: Number(e.googFrameWidthSent),\n                    height: Number(e.googFrameHeightSent),\n                    frameRate: Number(e.googFrameRateInput)\n                  }, t.firsCount = Number(e.googFirReceived), t.nacksCount = Number(e.googNacksReceived), t.plisCount = Number(e.googPlisReceived), t.frameCount = Number(e.framesEncoded), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.videoSend.push(t), this._stats.rtt = t.rttMs;\n                  break;\n                }\n              case \"video_recv\":\n                {\n                  const t = HN(XN),\n                    i = this.lastDecodeVideoReceiverStats.get(Number(e.ssrc));\n                  if (t.codec = e.googCodecName, t.targetDelayMs = Number(e.googTargetDelayMs), t.renderDelayMs = Number(e.googRenderDelayMs), t.currentDelayMs = Number(e.googCurrentDelayMs), t.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs), t.decodeMs = Number(e.googDecodeMs), t.maxDecodeMs = Number(e.googMaxDecodeMs), t.receivedFrame = {\n                    width: Number(e.googFrameWidthReceived),\n                    height: Number(e.googFrameHeightReceived),\n                    frameRate: Number(e.googFrameRateReceived)\n                  }, t.decodedFrame = {\n                    width: Number(e.googFrameWidthReceived),\n                    height: Number(e.googFrameHeightReceived),\n                    frameRate: Number(e.googFrameRateDecoded)\n                  }, t.decodeFrameRate = Number(e.googFrameRateDecoded), t.outputFrame = {\n                    width: Number(e.googFrameWidthReceived),\n                    height: Number(e.googFrameHeightReceived),\n                    frameRate: Number(e.googFrameRateOutput)\n                  }, t.jitterBufferMs = Number(e.googJitterBufferMs), t.firsCount = Number(e.googFirsSent), t.nacksCount = Number(e.googNacksSent), t.plisCount = Number(e.googPlisSent), t.framesDecodeCount = Number(e.framesDecoded), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, t.decodedFrame.width, t.decodedFrame.height), this.isFirstVideoDecoded[t.ssrc] = !0), i) {\n                    const n = i.stats,\n                      r = Date.now() - i.lts;\n                    t.framesDecodeFreezeTime = n.framesDecodeFreezeTime, t.framesDecodeInterval = n.framesDecodeInterval, t.framesDecodeCount > n.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (i.lts = Date.now(), t.framesDecodeInterval = r, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc, 10)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < i.stats.framesDecodeCount && (t.framesDecodeInterval = 0);\n                  }\n                  this.lastDecodeVideoReceiverStats.set(t.ssrc, {\n                    stats: uO({}, t),\n                    lts: Date.now()\n                  }), this._stats.videoRecv.push(t);\n                  break;\n                }\n              case \"audio_recv\":\n                {\n                  const t = HN(ZN);\n                  t.codec = e.googCodecName, t.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767, t.decodingCNG = Number(e.googDecodingCNG), t.decodingCTN = Number(e.googDecodingCTN), t.decodingCTSG = Number(e.googDecodingCTSG), t.decodingNormal = Number(e.googDecodingNormal), t.decodingPLC = Number(e.googDecodingPLC), t.decodingPLCCNG = Number(e.googDecodingPLCCNG), t.expandRate = Number(e.googExpandRate), t.accelerateRate = Number(e.googAccelerateRate), t.preemptiveExpandRate = Number(e.googPreemptiveExpandRate), t.secondaryDecodedRate = Number(e.googSecondaryDecodedRate), t.speechExpandRate = Number(e.googSpeechExpandRate), t.preferredJitterBufferMs = Number(e.googPreferredJitterBufferMs), t.jitterBufferMs = Number(e.googJitterBufferMs), t.jitterMs = Number(e.googJitterReceived), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.receivedFrames = Number(e.googDecodingCTN) || Number(e.packetsReceived), t.droppedFrames = Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) || Number(e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.decodingNormal > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), this._stats.audioRecv.push(t);\n                  break;\n                }\n              case \"audio_send\":\n                {\n                  const t = HN(QN);\n                  t.codec = e.googCodecName, t.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767, t.aecReturnLoss = Number(e.googEchoCancellationReturnLoss || 0), t.aecReturnLossEnhancement = Number(e.googEchoCancellationReturnLossEnhancement || 0), t.residualEchoLikelihood = Number(e.googResidualEchoLikelihood || 0), t.residualEchoLikelihoodRecentMax = Number(e.googResidualEchoLikelihoodRecentMax || 0), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.rtt = t.rttMs, this._stats.audioSend.push(t);\n                  break;\n                }\n            }\n          });\n        }\n        _getStats() {\n          return new rp((e, t) => {\n            this.pc.getStats(e, t);\n          });\n        }\n        statsResponsesToObjects(e) {\n          const t = [];\n          return e.result().forEach(e => {\n            const i = {\n              id: e.id,\n              timestamp: e.timestamp.valueOf().toString(),\n              type: e.type\n            };\n            e.names().forEach(t => {\n              i[t] = e.stat(t);\n            }), t.push(i);\n          }), t;\n        }\n      },\n      tD = function (e) {\n        return e.BANDWIDTH = \"bandwidth\", e.CPU = \"cpu\", e.NONE = \"none\", e.OTHER = \"other\", e;\n      }({}),\n      iD = function (e) {\n        return e.L1T1 = \"L1T1\", e.L1T2 = \"L1T2\", e.L1T3 = \"L1T3\", e.L1T3_KEY = \"L1T3_KEY\", e.L2T1_KEY = \"L2T1_KEY\", e.L2T2_KEY = \"L2T2_KEY\", e.L2T3_KEY = \"L2T3_KEY\", e.L3T1_KEY = \"L3T1_KEY\", e.L3T2_KEY = \"L3T2_KEY\", e.L3T3_KEY = \"L3T3_KEY\", e;\n      }({}),\n      nD = function (e) {\n        return e[e.new = 0] = \"new\", e[e.connecting = 1] = \"connecting\", e[e.connected = 2] = \"connected\", e[e.disconnected = 3] = \"disconnected\", e[e.failed = 4] = \"failed\", e[e.closed = 5] = \"closed\", e;\n      }({}),\n      rD = function (e) {\n        return e.CERTIFICATE = \"certificate\", e.CODEC = \"codec\", e.CANDIDATE_PAIR = \"candidate-pair\", e.LOCAL_CANDIDATE = \"local-candidate\", e.REMOTE_CANDIDATE = \"remote-candidate\", e.INBOUND = \"inbound-rtp\", e.TRACK = \"track\", e.OUTBOUND = \"outbound-rtp\", e.PC = \"peer-connection\", e.REMOTE_INBOUND = \"remote-inbound-rtp\", e.REMOTE_OUTBOUND = \"remote-outbound-rtp\", e.TRANSPORT = \"transport\", e.CSRC = \"csrc\", e.DATA_CHANNEL = \"data-channel\", e.STREAM = \"stream\", e.SENDER = \"sender\", e.RECEIVER = \"receiver\", e;\n      }({});\n    var oD = function (e) {\n      return e[e.kNone = 1] = \"kNone\", e[e.kMillisecondsFromSeconds = 1e3] = \"kMillisecondsFromSeconds\", e[e.kBytesToBits = 8] = \"kBytesToBits\", e;\n    }(oD || {});\n    function sD(e, t, i, n) {\n      let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : oD.kNone;\n      if (!t) return;\n      const o = Number(t[i]);\n      if (\"number\" != typeof o) return;\n      const s = Number(t[n]);\n      if (\"number\" != typeof s) return;\n      if (!e) return s ? o / s * r : void 0;\n      const a = Number(e[i]);\n      if (\"number\" != typeof a) return;\n      const c = Number(e[n]);\n      if (\"number\" != typeof c) return;\n      const d = s - c;\n      return d ? (o - a) / d * r : void 0;\n    }\n    let aD = class extends $N {\n        constructor() {\n          super(...arguments), dO(this, \"_stats\", qN), dO(this, \"report\", void 0), dO(this, \"lastDecodeVideoReceiverStats\", new Map()), dO(this, \"lastVideoFramesRecv\", new Map()), dO(this, \"lastVideoFramesSent\", new Map()), dO(this, \"lastVideoFramesDecode\", new Map()), dO(this, \"lastVideoFramesOutput\", new Map()), dO(this, \"lastVideoJBDelay\", new Map()), dO(this, \"lastAudioJBDelay\", new Map()), dO(this, \"mediaBytesSent\", new Map()), dO(this, \"mediaBytesRetransmit\", new Map()), dO(this, \"mediaBytesTargetEncode\", new Map()), dO(this, \"lastDecodeAudioReceiverStats\", new Map()), dO(this, \"lastAudioConcealment\", new Map()), dO(this, \"lastEncoderMs\", new Map());\n        }\n        async updateStats() {\n          this.report = await this.pc.getStats(), this._stats = HN(qN), this.report.forEach(e => {\n            switch (e.type) {\n              case rD.OUTBOUND:\n              case rD.INBOUND:\n                {\n                  const t = e.mediaType || e.kind,\n                    i = !t && \"frameWidth\" in e,\n                    n = !t && !(\"frameWidth\" in e);\n                  e.type === rD.OUTBOUND ? \"audio\" === t || n ? this.processAudioOutboundStats(e) : (\"video\" === t || i) && this.processVideoOutboundStats(e) : e.type === rD.INBOUND && (\"audio\" === t || n ? this.processAudioInboundStats(e) : (\"video\" === t || i) && this.processVideoInboundStats(e));\n                  break;\n                }\n              case rD.TRANSPORT:\n                {\n                  this.processTransportStats(e);\n                  const t = this.report.get(e.selectedCandidatePairId);\n                  t && this.processCandidatePairStats(t);\n                  break;\n                }\n              case rD.CANDIDATE_PAIR:\n                e.selected && this.processCandidatePairStats(e);\n            }\n          }), this.updateSendBitrate(), this._stats.updateInterval = Date.now() - this.stats.timestamp, this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;\n        }\n        async getSelectedCandidatePair() {\n          const e = await this.pc.getStats(),\n            t = {\n              local: uO({}, zN),\n              remote: uO({}, zN)\n            };\n          return e.forEach(i => {\n            let n;\n            if (i.type === rD.TRANSPORT && (n = e.get(i.selectedCandidatePairId)), i.type === rD.CANDIDATE_PAIR && i.selected && (n = i), n) {\n              const i = (e, t) => {\n                e.type = t.type, e.id = t.id, t.address && (e.address = t.address), t.candidateType && (e.candidateType = t.candidateType), t.port && (e.port = t.port), t.priority && (e.priority = t.priority), t.protocol && (e.protocol = t.protocol), t.relayProtocol && (e.relayProtocol = t.relayProtocol);\n              };\n              if (n.localCandidateId) {\n                const r = e.get(n.localCandidateId);\n                r && i(t.local, r);\n              }\n              if (n.remoteCandidateId) {\n                const r = e.get(n.remoteCandidateId);\n                r && i(t.remote, r);\n              }\n            }\n          }), t;\n        }\n        processCandidatePairStats(e) {\n          if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach(t => {\n            e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n          }), this._stats.audioSend.forEach(t => {\n            e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n          }), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) {\n            const t = this.report.get(e.localCandidateId);\n            t && this.processCandidateStats(t);\n          }\n          if (e.remoteCandidateId) {\n            const t = this.report.get(e.remoteCandidateId);\n            t && this.processCandidateStats(t);\n          }\n        }\n        processCandidateStats(e) {\n          let t;\n          e.type === rD.LOCAL_CANDIDATE && (t = this._stats.selectedCandidatePair.localCandidate), e.type === rD.REMOTE_CANDIDATE && (t = this._stats.selectedCandidatePair.remoteCandidate), t && (t.type = e.type, t.id = e.id, e.address && (t.address = e.address), e.candidateType && (t.candidateType = e.candidateType), e.port && (t.port = e.port), e.priority && (t.priority = e.priority), e.protocol && (t.protocol = e.protocol), e.relayProtocol && (t.relayProtocol = e.relayProtocol), e.type === rD.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(uO({}, t), uO({}, this.stats.selectedCandidatePair.localCandidate)), e.type === rD.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(uO({}, t), uO({}, this.stats.selectedCandidatePair.remoteCandidate)));\n        }\n        processAudioInboundStats(e) {\n          let t = this._stats.audioRecv.find(t => t.ssrc === e.ssrc);\n          t || (t = HN(ZN), this._stats.audioRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.packetsDiscarded = e.packetsDiscarded, t.bytes = e.bytesReceived, t.jitterMs = 1e3 * e.jitter, t.retransmittedBytesReceived = e.retransmittedBytesReceived, t.retransmittedPacketsReceived = e.retransmittedPacketsReceived, t.totalProcessingDelay = e.totalProcessingDelay, t.jitterBufferEmittedCount = e.jitterBufferEmittedCount, t.estimatedPlayoutTimestamp = e.estimatedPlayoutTimestamp;\n          const i = this.lastDecodeAudioReceiverStats.get(t.ssrc);\n          t.avgProcessingDelayMs = sD(i, t, \"totalProcessingDelay\", \"jitterBufferEmittedCount\", oD.kMillisecondsFromSeconds), this.processAudioTrackReceiverStats(e, e.trackId, t), this.calculateAudioFreeze(t, i, e), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), t.receivedFrames || (t.receivedFrames = e.packetsReceived), t.droppedFrames || (t.droppedFrames = e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.outputLevel && t.outputLevel > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), \"number\" == typeof e.concealedSamples && (t.concealedSamples = e.concealedSamples), this.lastDecodeAudioReceiverStats.set(t.ssrc, uO({}, t));\n        }\n        calculateAudioFreeze(e, t, i) {\n          const n = this.lastAudioConcealment.get(e.ssrc);\n          if (null != t && null != n) {\n            const r = n.lts,\n              o = i.timestamp,\n              s = o - r;\n            if (s <= 0) return;\n            const a = e.concealedSamples - t.concealedSamples - 0,\n              c = n.nonSilent + a,\n              d = e.totalSamplesReceived - t.totalSamplesReceived;\n            if (d <= 0) return;\n            const l = 80 * d / s,\n              u = 200 * d / s,\n              h = s / d;\n            let p = 0;\n            e.freezeSamples80 = t.freezeSamples80, e.freezeMs80 = t.freezeMs80, c > l && (n.plc80 > 0 ? (e.freezeSamples80 += a, e.freezeMs80 += Math.round(a * h)) : (e.freezeSamples80 += c, e.freezeMs80 += Math.round(c * h)), p = n.plc80 + 1);\n            let _ = 0;\n            e.freezeSamples200 = t.freezeSamples200, e.freezeMs200 = t.freezeMs200, c > u && (n.plc200 > 0 ? (e.freezeSamples200 += a, e.freezeMs200 += Math.round(a * h)) : (e.freezeSamples200 += c, e.freezeMs200 += Math.round(c * h)), _ = n.plc200 + 1), this.lastAudioConcealment.set(e.ssrc, {\n              nonSilent: a,\n              lts: o,\n              plc80: p,\n              plc200: _\n            });\n          } else e.freezeSamples80 = 0, e.freezeSamples200 = 0, e.freezeMs80 = 0, e.freezeMs200 = 0, this.lastAudioConcealment.set(e.ssrc, {\n            nonSilent: 0,\n            lts: i.timestamp,\n            plc80: 0,\n            plc200: 0\n          });\n        }\n        processVideoInboundStats(e) {\n          let t = this._stats.videoRecv.find(t => t.ssrc === e.ssrc);\n          t || (t = HN(XN), this._stats.videoRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.framesDecodeCount = e.framesDecoded, t.framesDroppedCount = e.framesDropped, t.totalInterFrameDelay = e.totalInterFrameDelay, t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay, t.totalFreezesDuration = e.totalFreezesDuration, t.totalProcessingDelay = e.totalProcessingDelay, t.packetsDiscarded = e.packetsDiscarded, t.framesAssembledFromMultiplePackets = e.framesAssembledFromMultiplePackets, t.totalAssemblyTime = e.totalAssemblyTime, t.keyFramesDecoded = e.keyFramesDecoded, t.retransmittedBytesReceived = e.retransmittedBytesReceived, t.retransmittedPacketsReceived = e.retransmittedPacketsReceived, t.estimatedPlayoutTimestamp = e.estimatedPlayoutTimestamp;\n          const i = this.lastDecodeVideoReceiverStats.get(t.ssrc),\n            n = this.lastVideoFramesDecode.get(t.ssrc),\n            r = this.lastVideoFramesOutput.get(t.ssrc),\n            o = Date.now();\n          if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) {\n            const e = t.decodedFrame ? t.decodedFrame.width : 0,\n              i = t.decodedFrame ? t.decodedFrame.height : 0;\n            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, e, i), this.isFirstVideoDecoded[t.ssrc] = !0;\n          }\n          if (i) {\n            const n = i.stats,\n              r = o - i.lts;\n            t.framesDecodeFreezeTime = n.framesDecodeFreezeTime, t.framesDecodeInterval = n.framesDecodeInterval, !this.isFirstVideoDecoded[t.ssrc] && r > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t.ssrc), this.isFirstVideoDecodedTimeout[t.ssrc] = !0), t.framesDecodeCount > n.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (i.lts = Date.now(), t.framesDecodeInterval = r, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < n.framesDecodeCount && (t.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (i.stats.framesDecodeCount > e.framesDecoded ? t.qpSumPerFrame = e.qpSum / e.framesDecoded : t.qpSumPerFrame = (e.qpSum - i.qpSum) / (e.framesDecoded - i.stats.framesDecodeCount));\n          }\n          e.totalDecodeTime && (t.decodeMs = 1e3 * e.totalDecodeTime, t.avgDecodeMs = sD(null == i ? void 0 : i.stats, t, \"decodeMs\", \"framesDecodeCount\")), t.avgProcessingDelayMs = sD(null == i ? void 0 : i.stats, t, \"totalProcessingDelay\", \"framesDecodeCount\", oD.kMillisecondsFromSeconds), t.avgFramesAssembledFromMultiplePacketsMs = sD(null == i ? void 0 : i.stats, t, \"totalAssemblyTime\", \"framesAssembledFromMultiplePackets\", oD.kMillisecondsFromSeconds), t.avgInterFrameDelayMs = sD(null == i ? void 0 : i.stats, t, \"totalInterFrameDelay\", \"framesDecodeCount\", oD.kMillisecondsFromSeconds), n && o - n.lts >= 800 ? (t.decodeFrameRate = Math.round((t.framesDecodeCount - n.count) / ((o - n.lts) / 1e3)), this.lastVideoFramesDecode.set(t.ssrc, {\n            count: t.framesDecodeCount,\n            lts: o,\n            rate: t.decodeFrameRate\n          })) : n ? t.decodeFrameRate = n.rate : this.lastVideoFramesDecode.set(t.ssrc, {\n            count: t.framesDecodeCount,\n            lts: o,\n            rate: 0\n          }), t.framesDroppedCount && e.framesReceived && (r && o - r.lts >= 800 ? (t.outputFrameRate = Math.round((e.framesReceived - t.framesDroppedCount - r.count) / ((o - r.lts) / 1e3)), this.lastVideoFramesOutput.set(t.ssrc, {\n            count: e.framesReceived - t.framesDroppedCount,\n            lts: o,\n            rate: Math.max(t.outputFrameRate, 0)\n          })) : r ? t.outputFrameRate = r.rate : this.lastVideoFramesOutput.set(t.ssrc, {\n            count: e.framesReceived - t.framesDroppedCount,\n            lts: o,\n            rate: 0\n          })), this.processVideoTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (t.framesRateFirefox = e.framerateMean), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), this.lastDecodeVideoReceiverStats.set(t.ssrc, {\n            stats: uO({}, t),\n            lts: i ? i.lts : Date.now(),\n            qpSum: e.qpSum\n          });\n        }\n        processVideoOutboundStats(e) {\n          let t = this._stats.videoSend.find(t => t.ssrc === e.ssrc);\n          t || (t = HN(JN), this._stats.videoSend.push(t));\n          const i = this.mediaBytesSent.get(e.ssrc);\n          if (i) i.add(e.bytesSent);else {\n            const t = new YN(10);\n            t.add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, t);\n          }\n          if (void 0 !== e.retransmittedBytesSent) {\n            const t = this.mediaBytesRetransmit.get(e.ssrc);\n            if (t) t.add(e.retransmittedBytesSent);else {\n              const t = new YN(10);\n              t.add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, t);\n            }\n          }\n          if (e.totalEncodedBytesTarget) {\n            const t = this.mediaBytesTargetEncode.get(e.ssrc);\n            if (t) t.add(e.totalEncodedBytesTarget);else {\n              const t = new YN(10);\n              t.add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, t);\n            }\n          }\n          if (t.ssrc = e.ssrc, t.bytes = e.bytesSent, t.packets = e.packetsSent, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.frameCount = e.framesEncoded, t.adaptionChangeReason = e.qualityLimitationReason, t.scalabilityMode = e.scalabilityMode, t.retransmittedBytesSent = e.retransmittedBytesSent, t.retransmittedPacketsSent = e.retransmittedPacketsSent, t.hugeFramesSent = e.hugeFramesSent, t.keyFramesEncoded = e.keyFramesEncoded, t.targetBitrate = e.targetBitrate, e.totalEncodeTime && e.framesEncoded) {\n            const i = this.lastEncoderMs.get(e.ssrc);\n            if (!i || i.lastFrameCount > e.framesEncoded) t.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded;else {\n              const n = e.framesEncoded - i.lastFrameCount,\n                r = e.totalEncodeTime - i.lastEncoderTime;\n              t.avgEncodeMs = 1e3 * r / n;\n            }\n          }\n          if (e.framesEncoded && e.qpSum) {\n            const i = this.lastEncoderMs.get(e.ssrc);\n            !i || i.lastFrameCount > e.framesEncoded ? t.qpSumPerFrame = e.qpSum / e.framesEncoded : t.qpSumPerFrame = (e.qpSum - i.lastQpSum) / (e.framesEncoded - i.lastFrameCount);\n          }\n          if (this.lastEncoderMs.set(e.ssrc, {\n            lastFrameCount: e.framesEncoded,\n            lastEncoderTime: e.totalEncodeTime,\n            lastQpSum: e.qpSum,\n            lts: Date.now()\n          }), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t), this.processVideoTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n            const i = this.findRemoteStatsId(e.ssrc, rD.REMOTE_INBOUND);\n            i && this.processRemoteInboundStats(i, t);\n          }\n        }\n        processAudioOutboundStats(e) {\n          let t = this._stats.audioSend.find(t => t.ssrc === e.ssrc);\n          if (t || (t = HN(QN), this._stats.audioSend.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsSent, t.bytes = e.bytesSent, t.retransmittedBytesSent = e.retransmittedBytesSent, t.retransmittedPacketsSent = e.retransmittedPacketsSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n            const i = this.findRemoteStatsId(e.ssrc, rD.REMOTE_INBOUND);\n            i && this.processRemoteInboundStats(i, t);\n          }\n        }\n        processTransportStats(e) {\n          this._stats.transport.bytesReceived = e.bytesReceived || this._stats.transport.bytesReceived, this._stats.transport.bytesSent = e.bytesSent || this._stats.transport.bytesSent, this._stats.transport.packetsReceived = e.packetsReceived || this._stats.transport.packetsReceived, this._stats.transport.packetsSent = e.packetsSent || this._stats.transport.packetsSent;\n        }\n        findRemoteStatsId(e, t) {\n          var i;\n          const n = Array.from(pp(i = this.report).call(i)).find(i => i.type === t && i.ssrc === e);\n          return n ? n.id : null;\n        }\n        processVideoMediaSource(e, t) {\n          const i = this.report.get(e);\n          i && i.width && i.height && i.framesPerSecond && (t.inputFrame = {\n            width: i.width,\n            height: i.height,\n            frameRate: i.framesPerSecond\n          });\n        }\n        processAudioMediaSource(e, t) {\n          const i = this.report.get(e);\n          i && (t.inputLevel = i.audioLevel);\n        }\n        processVideoTrackSenderStats(e, t, i) {\n          var n, r, o, s;\n          const a = t ? this.report.get(t) : void 0,\n            c = null !== (n = null == a ? void 0 : a.framesSent) && void 0 !== n ? n : e.framesSent;\n          if (\"number\" != typeof c) return;\n          let d = null !== (r = null == a ? void 0 : a.frameWidth) && void 0 !== r ? r : e.frameWidth,\n            l = null !== (o = null == a ? void 0 : a.frameHeight) && void 0 !== o ? o : e.frameHeight,\n            u = null !== (s = null == a ? void 0 : a.framesPerSecond) && void 0 !== s ? s : e.framesPerSecond;\n          if (\"number\" == typeof d && \"number\" == typeof l || (d = 0, l = 0), null == u) {\n            const e = Date.now(),\n              t = this.lastVideoFramesSent.get(i.ssrc);\n            t && e - t.lts >= 800 ? (u = Math.round((c - t.count) / ((e - t.lts) / 1e3)), this.lastVideoFramesSent.set(i.ssrc, {\n              count: c,\n              lts: e,\n              rate: u\n            })) : t ? u = t.rate : this.lastVideoFramesSent.set(i.ssrc, {\n              count: c,\n              lts: e,\n              rate: 0\n            });\n          }\n          i.sentFrame = {\n            width: d,\n            height: l,\n            frameRate: Math.max(0, u)\n          };\n        }\n        processVideoTrackReceiverStats(e, t, i) {\n          var n, r, o, s, a;\n          const c = t ? this.report.get(t) : void 0,\n            d = null !== (n = null == c ? void 0 : c.framesReceived) && void 0 !== n ? n : e.framesReceived,\n            l = null !== (r = null == c ? void 0 : c.frameWidth) && void 0 !== r ? r : e.frameWidth,\n            u = null !== (o = null == c ? void 0 : c.frameHeight) && void 0 !== o ? o : e.frameHeight,\n            h = null !== (s = null == c ? void 0 : c.jitterBufferDelay) && void 0 !== s ? s : e.jitterBufferDelay,\n            p = null !== (a = null == c ? void 0 : c.jitterBufferEmittedCount) && void 0 !== a ? a : e.jitterBufferEmittedCount;\n          if (\"number\" == typeof d) {\n            const e = this.lastVideoFramesRecv.get(i.ssrc),\n              t = Date.now();\n            i.framesReceivedCount = d;\n            let n = 0;\n            e && t - e.lts >= 800 ? (n = Math.round((d - e.count) / ((t - e.lts) / 1e3)), this.lastVideoFramesRecv.set(i.ssrc, {\n              count: d,\n              lts: t,\n              rate: n\n            })) : e ? n = e.rate : this.lastVideoFramesRecv.set(i.ssrc, {\n              count: d,\n              lts: t,\n              rate: 0\n            }), i.receivedFrame = {\n              width: l || 0,\n              height: u || 0,\n              frameRate: n || 0\n            }, i.decodedFrame = {\n              width: l || 0,\n              height: u || 0,\n              frameRate: i.decodeFrameRate || 0\n            }, i.outputFrame = {\n              width: l || 0,\n              height: u || 0,\n              frameRate: i.outputFrameRate || i.decodeFrameRate || 0\n            };\n          }\n          if (h && p) {\n            const e = this.lastVideoJBDelay.get(i.ssrc) || {\n              jitterBufferDelay: 0,\n              jitterBufferEmittedCount: 0,\n              jitterBufferMs: 0\n            };\n            let t = e.jitterBufferMs;\n            const n = p - e.jitterBufferEmittedCount;\n            n > 0 && (t = 1e3 * (h - e.jitterBufferDelay) / n), i.jitterBufferMs = t, i.currentDelayMs = Math.round(t), this.lastVideoJBDelay.set(i.ssrc, {\n              jitterBufferDelay: h,\n              jitterBufferEmittedCount: p,\n              jitterBufferMs: i.currentDelayMs\n            });\n          }\n        }\n        processAudioTrackSenderStats(e, t, i) {\n          var n, r, o, s;\n          const a = t ? this.report.get(t) : void 0,\n            c = null !== (n = null !== (r = null == a ? void 0 : a.echoReturnLoss) && void 0 !== r ? r : e.echoReturnLoss) && void 0 !== n ? n : 0,\n            d = null !== (o = null !== (s = null == a ? void 0 : a.echoReturnLossEnhancement) && void 0 !== s ? s : e.echoReturnLossEnhancement) && void 0 !== o ? o : 0;\n          i.aecReturnLoss = c, i.aecReturnLossEnhancement = d;\n        }\n        processAudioTrackReceiverStats(e, t, i) {\n          var n, r, o, s, a, c, d, l, u;\n          const h = t ? this.report.get(t) : void 0,\n            p = null !== (n = null == h ? void 0 : h.removedSamplesForAcceleration) && void 0 !== n ? n : e.removedSamplesForAcceleration,\n            _ = null !== (r = null == h ? void 0 : h.totalSamplesReceived) && void 0 !== r ? r : e.totalSamplesReceived,\n            E = null !== (o = null == h ? void 0 : h.jitterBufferDelay) && void 0 !== o ? o : e.jitterBufferDelay,\n            m = null !== (s = null == h ? void 0 : h.jitterBufferEmittedCount) && void 0 !== s ? s : e.jitterBufferEmittedCount,\n            f = null !== (a = null == h ? void 0 : h.audioLevel) && void 0 !== a ? a : null == e ? void 0 : e.audioLevel,\n            S = null !== (c = null == h ? void 0 : h.totalSamplesDuration) && void 0 !== c ? c : null == e ? void 0 : e.totalSamplesDuration,\n            g = null !== (d = null == h ? void 0 : h.concealedSamples) && void 0 !== d ? d : e.concealedSamples,\n            T = null !== (l = null == h ? void 0 : h.silentConcealedSamples) && void 0 !== l ? l : e.silentConcealedSamples,\n            R = null !== (u = null == h ? void 0 : h.concealmentEvents) && void 0 !== u ? u : e.concealmentEvents;\n          if (\"number\" == typeof _ && (i.totalSamplesReceived = _), \"number\" == typeof T && (i.silentConcealedSamples = T), \"number\" == typeof R && (i.concealmentEvents = R), \"number\" == typeof g && (i.concealedSamples = g), p && _ && (i.accelerateRate = p / _), E && m) {\n            const e = this.lastAudioJBDelay.get(i.ssrc) || {\n              jitterBufferDelay: 0,\n              jitterBufferEmittedCount: 0,\n              jitterBufferMs: 0\n            };\n            let t = e.jitterBufferMs;\n            const n = m - e.jitterBufferEmittedCount;\n            n > 0 && (t = 1e3 * (E - e.jitterBufferDelay) / n), i.jitterBufferMs = Math.round(t), this.lastAudioJBDelay.set(i.ssrc, {\n              jitterBufferDelay: E,\n              jitterBufferEmittedCount: m,\n              jitterBufferMs: i.jitterBufferMs\n            });\n          }\n          i.outputLevel = f;\n          let C = 1920;\n          S && _ && (C = _ / S / 50, i.receivedFrames = Math.round(_ / C)), g && (i.droppedFrames = Math.round(g / C));\n        }\n        processRemoteInboundStats(e, t) {\n          const i = this.report.get(e);\n          i && (t.packetsLost = i.packetsLost, i.roundTripTime && (t.rttMs = 1e3 * i.roundTripTime), i.jitter && (t.jitterMs = 1e3 * i.jitter), i.timestamp && (t.timestamp = i.timestamp));\n        }\n        getCodecFromCodecStats(e) {\n          const t = this.report.get(e);\n          if (!t) return \"\";\n          const i = t.mimeType.match(/\\/(.*)$/);\n          return i && i[1] ? i[1] : \"\";\n        }\n        updateSendBitrate() {\n          let e = 0,\n            t = null,\n            i = null;\n          this.mediaBytesSent.forEach(t => {\n            e += t.diffMean();\n          }), this.mediaBytesRetransmit.forEach(e => {\n            t = null === t ? e.diffMean() : t + e.diffMean();\n          }), this.mediaBytesTargetEncode.forEach(e => {\n            i = null === i ? e.diffMean() : i + e.diffMean();\n          });\n          const n = null !== t ? e - t : e;\n          this._stats.bitrate = {\n            actualEncoded: 8 * n / (this.options.updateInterval / 1e3),\n            transmit: 8 * e / (this.options.updateInterval / 1e3)\n          }, null !== t && (this._stats.bitrate.retransmit = 8 * t / (this.options.updateInterval / 1e3)), null !== i && (this._stats.bitrate.targetEncoded = 8 * i / (this.options.updateInterval / 1e3));\n        }\n      },\n      cD = class extends $N {\n        updateStats() {\n          return rp.resolve();\n        }\n      };\n    function dD(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,\n        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500,\n        r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;\n      const o = function () {\n        const e = navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]*/i);\n        return e && e[0] ? Number(e[0].split(\"/\")[1]) : null;\n      }();\n      return o ? o < 76 ? new eD(e, {\n        updateInterval: t,\n        lossRateInterval: i,\n        freezeRateLimit: n,\n        firstVideoDecodedTimeout: r\n      }) : new aD(e, {\n        updateInterval: t,\n        lossRateInterval: i,\n        freezeRateLimit: n,\n        firstVideoDecodedTimeout: r\n      }) : function (e) {\n        if (!window.RTCStatsReport) return !1;\n        const t = e.getStats();\n        return !!(t instanceof rp || function (e) {\n          return !!e && (\"object\" == typeof e || \"function\" == typeof e) && \"function\" == typeof e.then;\n        }(t));\n      }(e) ? new aD(e, {\n        updateInterval: t,\n        lossRateInterval: i,\n        freezeRateLimit: n,\n        firstVideoDecodedTimeout: r\n      }) : new cD(e, {\n        updateInterval: t,\n        lossRateInterval: i,\n        freezeRateLimit: n,\n        firstVideoDecodedTimeout: r\n      });\n    }\n    const lD = \"websdk_ng_install_id\";\n    function uD() {\n      try {\n        if (CD(\"INSTALL_ID\")) return CD(\"INSTALL_ID\");\n        let e = window.localStorage.getItem(lD);\n        return e || (e = gN(), window.localStorage.setItem(lD, e)), RD(\"INSTALL_ID\", e), e;\n      } catch (e) {\n        return;\n      }\n    }\n    const hD = function (e) {\n        if (e.match(/[0-9]+\\.[0-9]+\\.[0-9]+$/)) return e;\n        const t = e.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-([0-9]+)/);\n        if (t && t[1] && t[2]) {\n          const e = t[1],\n            i = t[2];\n          return \"\".concat(e, \".\").concat(i);\n        }\n        return \"4.0.0.999\";\n      }(\"4.24.2\"),\n      pD = function () {\n        try {\n          return !0 === JSON.parse(\"true\");\n        } catch (e) {\n          return !0;\n        }\n      }();\n    let _D = function (e) {\n      return e.Default = \"default\", e.Auto = \"auto\", e.Relay = \"relay\", e.SdRtn = \"sd-rtn\", e;\n    }({});\n    const ED = function () {\n      const e = \"us\".concat(\"erna\", \"me\"),\n        t = \"pa\".concat(\"sswo\", \"rd\"),\n        i = [\"t\", \"s\", \"t\"];\n      i.splice(1, 0, \"e\");\n      const n = i.join(\"\"),\n        r = [];\n      for (let e = 0; e < 6; e++) r.push(\"1\");\n      const o = r.join(\"\"),\n        s = {};\n      return s[e] = n, s[t] = o, Object.assign(s, {\n        turnServerURL: \"\",\n        tcpport: 3433,\n        udpport: 3478,\n        forceturn: !1\n      });\n    }();\n    window.DEFAULT_TURN_CONFIG = ED;\n    const mD = {\n        ENABLE_PUBLISHED_USER_LIST: !0,\n        MAX_SUBSCRIPTION: 50,\n        SUBSCRIBE_AUDIO_FILTER_TOPN: void 0,\n        ENABLE_PUBLISH_AUDIO_FILTER: void 0,\n        ENABLE_USER_LICENSE_CHECK: !0,\n        DISABLE_FEC: void 0,\n        ENABLE_NTP_REPORT: !1,\n        ENABLE_INSTANT_VIDEO: !1,\n        ENABLE_USER_AUTO_REBALANCE_CHECK: !0,\n        ENABLE_LOSSBASED_BWE: !0,\n        ENABLE_AUT_CC: !0,\n        FORCE_ENABLE_AUT_CC: !1,\n        ENABLE_CC_FALLBACK: void 0,\n        SUBSCRIBE_TWCC: !0,\n        PUBLISH_TWCC: !1,\n        ENABLE_SVC_DEFAULT_CODECS: [\"H264\", \"VP8\", \"VP9\", \"AV1\"],\n        SVC: [],\n        ENABLE_FULL_LINK_AV_SYNC: !1,\n        SVC_MODE: null,\n        PRE_SUB_NUM: 1,\n        ENABLE_AUT_FEEDBACK: !0,\n        SVC_EXTENDED: [\"VP9\"]\n      },\n      fD = {\n        MIN_FRAME_RATE: 1,\n        MAX_FRAME_RATE: 30,\n        MAX_THRESHOLD_FRAMERATE: 30,\n        BITRATE_MIN_THRESHOLD: 100,\n        BITRATE_MAX_THRESHOLD: 100,\n        MAX_SCALE: 5,\n        BWE_SCALE_UP_THRESHOLD: .6,\n        BWE_SCALE_DOWN_THRESHOLD: .6,\n        PERF_SCALE_UP_THRESHOLD: .7,\n        PERF_SCALE_DOWN_THRESHOLD: .6,\n        MOTION_RESOLUTION_FACTOR: .8,\n        MOTION_BITRATE_FACTOR: .6,\n        DETAIL_FRAMERATE_FACTOR: .8,\n        DETAIL_BITRATE_FACTOR: .6,\n        BALANCE_RESOLUTION_FACTOR: .9,\n        BALANCE_FRAMERATE_FACTOR: .9,\n        BALANCE_BITRATE_FACTOR: .6,\n        OVERUSE_TIMES_THRESHOLD: 10,\n        UNDERUSE_TIMES_THRESHOLD: 40\n      },\n      SD = \"v4.24.2-0-g002485b1-dirty(12/12/2025, 5:26:54 PM)\",\n      gD = {\n        ENABLE_EVENT_REPORT: !0,\n        UPLOAD_LOG: !1,\n        ENABLE_AG_ADAPTATION: !0,\n        FORCE_AG_HIGH_FRAMERATE: !1,\n        FORCE_SUPPORT_AG_ADAPTATION: !1,\n        ENCODER_CONFIG_LIMIT: {},\n        CAMERA_CAPTURE_CONFIG: void 0,\n        ENABLE_PRELOAD: !0,\n        NEW_ICE_RESTART: !0,\n        ICE_RESTART_INTERVAL: 1e4,\n        RESTART_SEQUENCE: [\"udp_tcp_relay\", \"relay\"],\n        FIRST_TCP_CANDIDATE: !1,\n        FIRST_TCP_CANDIDATE_INTERVAL: 1e3,\n        TURN_DOMAIN: \"edge.agora.io\",\n        TURN_DOMAINS: [\"edge.agora.io\"],\n        USE_TURN_IP: !0,\n        NEW_TURN_MODE: 4,\n        NEW_FORCE_TURN: !1,\n        USE_NEW_RENDER_FREEZE_TIME: !1,\n        FLS_FALLBACK_TIMEOUT: 3e4,\n        RTE_DETAIL_REPORT_INTERVAL: 6e4,\n        ENCODE_EXCEPTION_TIMES: 5,\n        ENABLE_ENCODE_EXCEPTION: !0,\n        ENCODE_EXCEPTION_VALIDATE_CODEC: [\"h264\"],\n        VIDEO_ENCODER_CONFIG_LIST: [{\n          width: 240,\n          height: 180\n        }, {\n          width: 320,\n          height: 240\n        }, {\n          width: 400,\n          height: 300\n        }, {\n          width: 480,\n          height: 360\n        }, {\n          width: 560,\n          height: 420\n        }, {\n          width: 640,\n          height: 480\n        }],\n        DELETE_NEQ_AFTER_USER_LEAVE: !0,\n        UPDATE_RTP_CAP_IN_HOST: !1,\n        IOS_BG_TAG: !0,\n        IOS_AUTO_RESTART_BG_TAG: !0,\n        IGNORE_UID_CHECK: !1,\n        ENABLE_UP_SPS_PPS: !1,\n        ENABLE_DOWN_SPS_PPS: !1,\n        NO_EDGES_RETRY: !0,\n        BUFFER_READY_FRAMES: 3,\n        FLS_SYNC_AV_PLAY_LIMIT: 0,\n        FLS_BUFFER_WAIT_TIME: 1500,\n        VOS_CONFIGURE: void 0,\n        ENABLE_QUALITY_FALLBACK: !1,\n        QUALITY_FALLBACK_REHEARSAL: !0,\n        ENABLE_FLS_AV1_FIRST: !1,\n        ENABLE_AP_MULTI_IP: !0,\n        FLS_ENABLE_AV1_DETECT: !0,\n        FLS_ENABLE_AV1_DECODE_DETECT: !0\n      },\n      TD = uO(uO(uO(uO({}, gD), {}, {\n        PROCESS_ID: \"\",\n        ENCRYPT_AES: !0,\n        AREAS: [\"CHINA\", \"GLOBAL\"],\n        WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\", \"webrtc2-2.ap.sd-rtn.com\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\", \"webrtc2-4.ap.sd-rtn.com\"],\n        PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n        CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-web-2.ap.sd-rtn.com\", \"cds-ap-web-3.agora.io\", \"cds-web-4.ap.sd-rtn.com\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-web-2.ap.sd-rtn.com\", \"sua-ap-web-3.agora.io\", \"sua-web-4.ap.sd-rtn.com\"],\n        UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-web-2.ap.sd-rtn.com\", \"uap-ap-web-3.agora.io\", \"uap-web-4.ap.sd-rtn.com\"],\n        LOG_UPLOAD_SERVER: \"logservice.agora.io\",\n        EVENT_REPORT_DOMAIN: \"statscollector-1.agora.io\",\n        EVENT_REPORT_BACKUP_DOMAIN: \"web-2.statscollector.sd-rtn.com\",\n        GATEWAY_ADDRESS: [],\n        GATEWAY_WSS_ADDRESS: \"\",\n        LIVE_STREAMING_ADDRESS: \"\",\n        HTTP_CONNECT_TIMEOUT: 5e3,\n        SIGNAL_REQUEST_TIMEOUT: 1e4,\n        REPORT_STATS: !0,\n        NOT_REPORT_EVENT: [],\n        PING_PONG_TIME_OUT: 10,\n        WEBSOCKET_TIMEOUT_MIN: 1e4,\n        EVENT_REPORT_SEND_INTERVAL: 3e3,\n        CONFIG_DISTRIBUTE_INTERVAL: 3e5,\n        ENABLE_CONFIG_DISTRIBUTE: !0,\n        CANDIDATE_TIMEOUT: 5e3,\n        SHOW_REPORT_INVOKER_LOG: !1,\n        SHOW_REPORT_USER_INVOKER_LOG: !0,\n        JOIN_EXTEND: \"\",\n        PUB_EXTEND: \"\",\n        SUB_EXTEND: \"\",\n        FORCE_TURN: !1,\n        TURN_ENABLE_TCP: !0,\n        TURN_ENABLE_UDP: !0,\n        MAX_UPLOAD_CACHE: 50,\n        UPLOAD_CACHE_INTERVAL: 2e3,\n        AJAX_REQUEST_CONCURRENT: 3,\n        REPORT_APP_SCENARIO: void 0,\n        GATEWAY_DOMAINS: [\"edge.agora.io\", \"edge.sd-rtn.com\"],\n        CONNECT_GATEWAY_WITHOUT_DOMAIN: !1,\n        WORKER_DOMAIN: \"edge.agora.io\",\n        EVENT_REPORT_RETRY: !0,\n        CHROME_FORCE_PLAN_B: !1,\n        AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,\n        AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3,\n        AUDIO_VOLUME_INDICATION_INTERVAL: 2e3,\n        VOLUME_VOICE_WEIGHT: 10,\n        GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1,\n        STATS_UPDATE_INTERVAL: 250,\n        NORMAL_EVENT_QUEUE_CAPACITY: 100,\n        CUSTOM_REPORT: !0,\n        CUSTOM_REPORT_LIMIT: 20,\n        PROXY_SERVER_TYPE2: \"webnginx-proxy.agora.io\",\n        PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\", \"webrtc-cloud-proxy.agora.io\"],\n        CUSTOM_PUB_ANSWER_MODIFIER: null,\n        CUSTOM_SUB_ANSWER_MODIFIER: null,\n        CUSTOM_PUB_OFFER_MODIFIER: null,\n        CUSTOM_SUB_OFFER_MODIFIER: null,\n        DSCP_TYPE: \"high\",\n        REMOVE_NEW_CODECS: !0,\n        FRAGEMENT_LENGTH: 3,\n        WEBSOCKET_COMPRESS: !1,\n        SIMULCAST: !1,\n        CHECK_VIDEO_VISIBLE_INTERVAL: 3e4,\n        CHECK_LOCAL_STATS_INTERVAL: 250,\n        PROFILE_SWITCH_INTERVAL: 2e3,\n        UNSUPPORTED_VIDEO_CODEC: [],\n        ENUMERATE_DEVICES_INTERVAL: !1,\n        ENUMERATE_DEVICES_INTERVAL_TIME: 1e4,\n        USE_NEW_TOKEN: !1,\n        CLOSE_AFB_FOR_LOCAL_AP: !0,\n        JOIN_MAX_CONCURRENCY: 6,\n        JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0,\n        JOIN_WITH_FALLBACK_MEDIA_PROXY: !0,\n        JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1,\n        JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3,\n        JOIN_GATEWAY_USE_443PORT_ONLY: !1,\n        JOIN_GATEWAY_USE_DUAL_DOMAIN: !0,\n        JOIN_GATEWAY_FALLBACK_PORT: 443,\n        USE_TURN_SERVER_OF_GATEWAY: !1,\n        H264_PROFILE_LEVEL_ID: \"\",\n        USE_NEW_LOG: !1,\n        LOG_VERSION: 3,\n        MEDIA_DEVICE_CONSTRAINTS: null,\n        ENCRYPT_PROXY_USERNAME_AND_PSW: !0,\n        SDP_LOGGING: !1,\n        CSP_DETECTED_HOSTNAME_LIST: [\"agora.io\", \"sd-rtn.com\"],\n        REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1,\n        LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !1,\n        BITRATE_ADAPTER_TYPE: \"STANDARD_BITRATE\",\n        AI_DENOISER_PARAMETERS: {\n          excludedLinks: []\n        },\n        ADJUST_3A_FROM_PLUGINS: !0,\n        RAISE_H264_BASELINE_PRIORITY: !0,\n        FILTER_SEND_H264_BASELINE: !1,\n        FIRST_H264_PROFILE_LEVEL_ID: \"42001f\",\n        FIRST_PACKETIZATION_MODE: \"\",\n        X_GOOGLE_START_BITRATE: void 0,\n        NEW_REPORT_SERVER: !1,\n        NEW_REPORT_SERVER_DOMAINS: [\"data-reporting.agora.io\", \"data-reporting.agora.io\"],\n        VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,\n        VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3,\n        VIDEO_INSPECT_QUALITY_RATIO: .9,\n        VIDEO_INSPECT_WORKER_MANAGER_HOST: \"edge.agora.io\",\n        VIDEO_INSPECT_WORKER_MANAGER_PORT: \"\",\n        VIDEO_INSPECT_WORKER_MANAGER_WSS: \"\",\n        VIDEO_INSPECT_WORKER_PORT: \"\",\n        SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1,\n        STATS_COLLECTOR_PORT: 443,\n        FORCE_TURN_TCP: !1,\n        WEBAUDIO_INIT_OPTIONS: void 0,\n        FILTER_VIDEO_FEC: !0,\n        FILTER_AUDIO_FEC: !1,\n        CHROME_DUAL_STREAM_USE_ENCODING: !0,\n        DISABLE_DUAL_STREAM_USE_ENCODING: !1,\n        EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4,\n        ICE_RESTART: !0,\n        FINGERPRINT: null,\n        ENABLE_VIDEO_FRAME_CALLBACK: !0,\n        VIDEO_FREEZE_DURATION: 500,\n        SPATIALIZER_PARAMETERS: {},\n        UPLOAD_LOG_INTERVAL: 3e3,\n        UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3,\n        UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4,\n        UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3,\n        UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4,\n        UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200,\n        UPLOAD_LOG_LENGTH_EACH_TIME: 10,\n        APP_TYPE: 0,\n        DISABLE_WEBAUDIO: !1,\n        CHANNEL_MEDIA_RELAY_SERVERS: void 0,\n        KEEP_LAST_FRAME: !0,\n        FORWARD_P2P_CREATION: !0,\n        SYNC_GROUP: !0,\n        BLOCK_LOCAL_CLIENT: !1,\n        ENABLE_AUDIO_TOPN: !1,\n        ENABLE_AUDIO_METADATA: !1,\n        ENABLE_AUDIO_PTS: !1,\n        TOPN_SMOOTH_LEVEL: void 0,\n        TOPN_NEW_SPEAKER_DELAY: void 0,\n        TOPN_SWITCH_HOLD_MS: void 0,\n        TOPN_AUDIO_GAIN: void 0,\n        TOPN_SILENCE_THRESHOLD: 250,\n        AP_AREA: !0,\n        ENABLE_ENCODED_TRANSFORM: !1,\n        ENABLE_VIDEO_SEI: !1,\n        IMAGE_MODERATION_WORKER_HOST: \"edge.agora.io\",\n        IMAGE_MODERATION_WORKER_WSS: \"\",\n        IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,\n        IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3,\n        SHOW_IMAGE_MODERATION_WORKER_MESSAGE: !1,\n        IMAGE_MODERATION_QUALITY_RATIO: .9,\n        IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3,\n        SHOW_GLOBAL_CLIENT_LIST: !1,\n        DATASTREAM_MAX_RETRANSMITS: 10,\n        TCP_CANDIDATE_ONLY: !1,\n        EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3,\n        SHOW_P2P_LOG: !1,\n        MAX_P2P_TIMEOUT: 3e4,\n        P2P_TOKEN_INTERVAL: 1e3,\n        SHOW_DATASTREAM2_LOG: !1,\n        RESTRICTION_SET_PLAYBACK_DEVICE: !0,\n        USE_PURE_ENCRYPTION_MASTER_KEY: !1,\n        ENABLE_AUDIO_RED: !1,\n        OPUS_PTIME: void 0,\n        AUDIO_DUPLICATE_NUM: void 0,\n        ENABLE_ABSSENDTIME_AS_SENTTS: !0,\n        ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,\n        ACCOUNT_REGISTER_RETRY_RATIO: 2,\n        ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,\n        ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,\n        AUDIO_CONTEXT: null,\n        WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,\n        PLAYER_STATE_DEFER: 2e3,\n        SIGNAL_REQUEST_WATCH_INTERVAL: 1e3,\n        FILEPATH_LENMAX: 255,\n        DUALSTREAM_OPERATION_CHECK: !0,\n        MEDIA_ELEMENT_EXISTS_DEPTH: 3,\n        SHIM_CANDIDATE: !1,\n        LEAVE_MSG_TIMEOUT: 2e3,\n        STATS_FILTER: {\n          transportId: !0,\n          googTrackId: !0\n        },\n        FILTER_VIDEO_CODEC: [],\n        SIGNAL_CHANNEL: 0,\n        TRANSMITTER_INITIAL_RTT: 30,\n        TRANSMITTER_INITIAL_RTO: 30,\n        TRANSMITTER_MAX_BATCH_ACK_COUNT: 2,\n        TRANSMITTER_MAX_RTO: 500,\n        DATACHANNEL_COMPRESS: !1,\n        DC_JOIN_WITH_FAILBACK: 4e3,\n        DC_CONNECTION_TIMEOUT: 2e3,\n        DC_PINGPONG_INTERVAL: 2e3,\n        DC_DEBUG_LOG: !1,\n        UNSUPPORTED_VIDEO_UPLINK_CODEC: [],\n        UNSUPPORTED_VIDEO_DOWNLINK_CODEC: [],\n        USE_NEW_NETWORK_CONFIG: !1,\n        AUTO_RESET_AUDIO_ROUTE: !1,\n        PLUGIN_INFO: [],\n        OVERUSE_DETECTOR_PARAMS: fD,\n        CUSTOM_ADAPTATION_DEFAULT_MODE: \"\",\n        HIDE_NO_POSTER: !1,\n        AP_CACHE_NUM: 10,\n        AP_UPDATE_INTERVAL: 12e4,\n        AP_CACHE_LIFETIME: 12e4,\n        MAX_PRELOAD_ASYNC_LENGTH: 3,\n        DISABLE_SCREEN_SHARE_REMB: !1\n      }, mD), {}, {\n        USE_CANDIDATE_FROM_AP_DETAIL: !1,\n        AP_REQUEST_DETAIL: void 0,\n        ENABLE_ROLE_SELECT_EDGE: !1,\n        CLIENT_ROLE_OPTIONS: void 0,\n        REMOTE_VIDEO_STREAM_TYPE: void 0,\n        COMPATIBLE_SDP_EXTENSION: [\"gdpr_forbidden\"],\n        LIMIT_BITRATE: void 0,\n        EXPERIMENTS: {},\n        USE_PUB_RTX: !0,\n        USE_SUB_RTX: !0,\n        ENABLE_DATASTREAM_2: !1,\n        USE_XR: !0,\n        ENABLE_PREALLOC_PC: !1,\n        ENABLE_PRE_SUB: !1,\n        ENABLE_SVC: !1,\n        ENABLE_FORCE_HLS: !1,\n        MAX_WEBAUDIO_VOLUME: 300,\n        ENABLE_VOS_FALLBACK: !1,\n        ENABLE_FALLBACK_TO_HLS: !1,\n        ENABLE_PRE_RENDER: !1,\n        FORCE_DISABLE_AUTO_SUB: !1,\n        ENABLE_PRE_SUB_WITH_PRE_PC: !0,\n        PRE_USE_LOCAL_CODECS: !0\n      }, {\n        INSTALL_ID: \"\"\n      }), {}, {\n        K_MIN_RENDER_DELAY: 66,\n        USE_STANDARD_BITRATE_DEFAULT: !1,\n        VIDEO_NEW_BITRATE_RATIO: void 0,\n        VIDEO_STANDARD_BITRATE_VERSION: 2,\n        BASELINE_MORE_H264_BITRATE_RATIO: 1.1,\n        IGNORE_RTC_DEVICE_CHECK: !1,\n        FLS_AUTOPLAY_EMITS: !1,\n        ENABLE_DUAL_STREAM_FLAG: !1,\n        FORBID_MODIFY_LOCAL_OFFER_SDP: !1,\n        RESERVE_MID_1_MLINE: !1\n      });\n    function RD(e, t, i) {\n      var n, r, o;\n      Ln(n = Object.keys(TD)).call(n, e) && (!i && Ln(r = Object.keys(yD)).call(r, e) || (TD[e] = t, \"ENABLE_VIDEO_SEI\" !== e && \"ENABLE_AUDIO_TOPN\" !== e && \"ENABLE_AUDIO_METADATA\" !== e && \"ENABLE_AUDIO_PTS\" !== e || !0 !== t || (TD.ENABLE_ENCODED_TRANSFORM = !0), \"USE_NEW_NETWORK_CONFIG\" === e && t && (o = !!t, TD.USE_NEW_NETWORK_CONFIG = o, o && (TD.WEBCS_DOMAIN = [\"webrtc2-2.ap.sd-rtn.com\"], TD.WEBCS_DOMAIN_BACKUP_LIST = [\"webrtc2-4.ap.sd-rtn.com\"], TD.CDS_AP = [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"], TD.ACCOUNT_REGISTER = [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"], TD.EVENT_REPORT_DOMAIN = \"web-2.statscollector.sd-rtn.com\", TD.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-1.agora.io\", TD.GATEWAY_DOMAINS = [\"edge.sd-rtn.com\"])), \"ENABLE_PRE_SUB\" === e && t && (TD.ENABLE_INSTANT_VIDEO = !0, TD.ENABLE_PREALLOC_PC = !0), \"ENABLE_SVC\" === e && t && (TD.ENABLE_AUT_CC = !0), \"NEW_FORCE_TURN\" === e && t && (TD.NEW_TURN_MODE || (TD.NEW_TURN_MODE = 4))));\n    }\n    function CD(e) {\n      if (\"TURN_DOMAINS\" === e) {\n        const e = TD.TURN_DOMAINS;\n        return Ln(e).call(e, CD(\"TURN_DOMAIN\")) ? e : [CD(\"TURN_DOMAIN\")].concat(e);\n      }\n      return TD[e];\n    }\n    pD || (TD.WEBCS_DOMAIN = [\"ap-web-1-oversea.agora.io\", \"ap-web-1-north-america.agora.io\"], TD.WEBCS_DOMAIN_BACKUP_LIST = [\"ap-web-2-oversea.agora.io\", \"ap-web-2-north-america.agora.io\"], TD.PROXY_CS = [\"proxy-ap-web-oversea.agora.io\", \"proxy-ap-web-america.agora.io\"], TD.CDS_AP = [\"cds-ap-web-oversea.agora.io\", \"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"], TD.ACCOUNT_REGISTER = [\"sua-ap-web-oversea.agora.io\", \"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"], TD.UAP_AP = [\"uap-ap-web-oversea.agora.io\", \"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"], TD.LOG_UPLOAD_SERVER = \"logservice-oversea.agora.io\", TD.EVENT_REPORT_DOMAIN = \"statscollector-1-oversea.agora.io\", TD.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-2-oversea.agora.io\", TD.PROXY_SERVER_TYPE3 = \"webrtc-cloud-proxy.agora.io\", TD.AREAS = [\"NORTH_AMERICA\", \"OVERSEA\"]);\n    let vD = function (e) {\n      return e[e.REALTIME = 1] = \"REALTIME\", e;\n    }({});\n    const yD = {};\n    var ID = function (e) {\n      return e.SET_SESSION_ID = \"SET_SESSION_ID\", e.SET_RTE_URL = \"SET_RTE_URL\", e.SET_RTE_SID = \"SET_RTE_SID\", e.SET_P2P_ID = \"SET_P2P_id\", e.SET_DC_ID = \"SET_DC_id\", e.SET_UID = \"SET_UID\", e.SET_INT_UID = \"SET_INT_UID\", e.SET_PUB_ID = \"SET_PUB_ID\", e.SET_CLOUD_PROXY_SERVER_MODE = \"SET_CLOUD_PROXY_SERVER_MODE\", e.KEY_METRIC_CLIENT_CREATED = \"KEY_METRIC_CLIENT_CREATED\", e.KEY_METRIC_JOIN_START = \"KEY_METRIC_JOIN_START\", e.KEY_METRIC_PRELOAD_START = \"KEY_METRIC_PRELOAD_START\", e.KEY_METRIC_PRELOAD_END = \"KEY_METRIC_PRELOAD_END\", e.KEY_METRIC_JOIN_END = \"KEY_METRIC_JOIN_END\", e.KEY_METRIC_REQUEST_AP_START = \"KEY_METRIC_REQUEST_AP_START\", e.KEY_METRIC_REQUEST_AP_END = \"KEY_METRIC_REQUEST_AP_END\", e.KEY_METRIC_REQUEST_SUA_END = \"KEY_METRIC_REQUEST_SUA_END\", e.KEY_METRIC_BEFORE_CONNECT = \"KEY_METRIC_BEFORE_CONNECT\", e.KEY_METRIC_PEER_RECEIVER = \"KEY_METRIC_PEER_RECEIVER\", e.KEY_METRIC_SIGNAL_CONNECTED = \"KEY_METRIC_SIGNAL_CONNECTED\", e.KEY_METRIC_JOIN_REQ = \"KEY_METRIC_JOIN_REQ\", e.KEY_METRIC_JOIN_REP = \"KEY_METRIC_JOIN_REP\", e.KEY_METRIC_JOIN_GATEWAY_START = \"KEY_METRIC_JOIN_GATEWAY_START\", e.KEY_METRIC_JOIN_GATEWAY_END = \"KEY_METRIC_JOIN_GATEWAY_END\", e.KEY_METRIC_PEER_CONNECTION_START = \"KEY_METRIC_PEER_CONNECTION_START\", e.KEY_METRIC_PEER_CONNECTION_END = \"KEY_METRIC_PEER_CONNECTION_END\", e.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED = \"KEY_METRIC_FIRST_VIDEO_FRAME_DECODED\", e.KEY_METRIC_DESCRIPTION_START = \"KEY_METRIC_DESCRIPTION_START\", e.KEY_METRIC_ICE_CONNECTION_END = \"KEY_METRIC_ICE_CONNECTION_END\", e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = \"KEY_METRIC_SIGNAL_CHANNEL_OPEN\", e.KEY_METRIC_PUBLISH = \"KEY_METRIC_PUBLISH\", e.KEY_METRIC_SUBSCRIBE = \"KEY_METRIC_SUBSCRIBE\", e.RECORD_JOIN_CHANNEL_SERVICE = \"RECORD_JOIN_CHANNEL_SERVICE\", e.RESET_JOIN_CHANNEL_SERVICE_RECORDS = \"RESET_JOIN_CHANNEL_SERVICE_RECORDS\", e.RESET_KEY_METRICS = \"RESET_KEY_METRICS\", e.RESET_FIRST_VIDEO_FRAME_DECODED = \"RESET_FIRST_VIDEO_FRAME_DECODED\", e.SET_USE_P2P = \"SET_USE_P2P\", e.SET_TRANSPORT_TYPE = \"SET_TRANSPORT_TYPE\", e;\n    }(ID || {});\n    let AD = function (e) {\n      return e.h264 = \"h264\", e.h265 = \"h265\", e.vp8 = \"vp8\", e.vp9 = \"vp9\", e.av1 = \"av1\", e;\n    }({});\n    !function (e) {\n      e.opus = \"opus\", e.pcma = \"pcma\", e.pcmu = \"pcmu\", e.g722 = \"g722\";\n    }({});\n    const bD = 128,\n      wD = 96,\n      OD = 1e3,\n      ND = 10;\n    let DD = 0;\n    var PD = (() => {\n      var e = {\n          8: (e, t, i) => {\n            i.r(t), i.d(t, {\n              Parser: () => C,\n              Printer: () => b,\n              parse: () => D,\n              print: () => P\n            });\n            const n = \"\\n\",\n              r = \"\".concat(\"\\r\").concat(n),\n              o = \" \";\n            let s;\n            function a(e) {\n              return e >= \"0\" && e <= \"9\";\n            }\n            function c(e) {\n              return e >= \"!\" && e <= \"~\";\n            }\n            function d(e) {\n              return c(e) || e >= \"Â\" && e <= \"Ã¿\";\n            }\n            function l(e) {\n              return \"!\" === e || e >= \"#\" && e <= \"'\" || e >= \"*\" && e <= \"+\" || e >= \"-\" && e <= \".\" || e >= \"0\" && e <= \"9\" || e >= \"A\" && e <= \"Z\" || e >= \"^\" && e <= \"~\";\n            }\n            function u(e) {\n              return e >= \"1\" && e <= \"9\";\n            }\n            function h(e) {\n              return e >= \"A\" && e <= \"Z\" || e >= \"a\" && e <= \"z\";\n            }\n            function p(e) {\n              return \"d\" === e || \"h\" === e || \"m\" === e || \"s\" === e;\n            }\n            function _(e) {\n              return e > \"\u0001\" && e < \"\\t\" || e > \"\\v\" && e < \"\\f\" || e > \"\u000e\" && e < \"Ã¿\";\n            }\n            function E(e) {\n              return h(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function m(e) {\n              return a(e) || h(e) || \"+\" === e || \"/\" === e || \"-\" === e || \"_\" === e;\n            }\n            function f(e) {\n              return h(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function S(e, t) {\n              var i = Object.keys(e);\n              if (Object.getOwnPropertySymbols) {\n                var n = Object.getOwnPropertySymbols(e);\n                t && (n = n.filter(function (t) {\n                  return Object.getOwnPropertyDescriptor(e, t).enumerable;\n                })), i.push.apply(i, n);\n              }\n              return i;\n            }\n            function g(e) {\n              for (var t = 1; t < arguments.length; t++) {\n                var i = null != arguments[t] ? arguments[t] : {};\n                t % 2 ? S(Object(i), !0).forEach(function (t) {\n                  T(e, t, i[t]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : S(Object(i)).forEach(function (t) {\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n                });\n              }\n              return e;\n            }\n            function T(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            !function (e) {\n              e.VERSION = \"v\", e.ORIGIN = \"o\", e.SESSION_NAME = \"s\", e.INFORMATION = \"i\", e.URI = \"u\", e.EMAIL = \"e\", e.PHONE = \"p\", e.CONNECTION = \"c\", e.BANDWIDTH = \"b\", e.TIME = \"t\", e.REPEAT = \"r\", e.ZONE_ADJUSTMENTS = \"z\", e.KEY = \"k\", e.ATTRIBUTE = \"a\", e.MEDIA = \"m\";\n            }(s || (s = {}));\n            class R {\n              consumeText(e, t) {\n                let i = t;\n                for (; i < e.length;) {\n                  const t = e[i];\n                  if (\"\\0\" === t || \"\\r\" === t || t === n) break;\n                  i += 1;\n                }\n                if (i - t == 0) throw new Error(\"Invalid text, at \".concat(e));\n                return i;\n              }\n              consumeUnicastAddress(e, t, i) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeOneOrMore(e, t, i) {\n                let n = t;\n                for (; i(e[n]);) n++;\n                if (n - t == 0) throw new Error(\"Invalid rule at \".concat(t, \".\"));\n                return n;\n              }\n              consumeSpace(e, t) {\n                if (e[t] === o) return t + 1;\n                throw new Error(\"Invalid space at \".concat(t, \".\"));\n              }\n              consumeIP4Address(e, t) {\n                let i = t;\n                for (let t = 0; t < 4; t++) if (i = this.consumeDecimalUChar(e, i), 3 !== t) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 address.\");\n                  i++;\n                }\n                return i;\n              }\n              consumeDecimalUChar(e, t) {\n                let i = t;\n                for (let t = 0; t < 3 && a(e[i]); t++, i++);\n                if (i - t == 0) throw new Error(\"Invalid decimal uchar.\");\n                const n = parseInt(e.slice(t, i));\n                if (n >= 0 && n <= 255) return i;\n                throw new Error(\"Invalid decimal uchar\");\n              }\n              consumeIP6Address(e, t) {\n                let i = this.consumeHexpart(e, t);\n                return \":\" === e[i] ? (i += 1, i = this.consumeIP4Address(e, i), i) : i;\n              }\n              consumeHexpart(e, t) {\n                let i = t;\n                if (\":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                if (i = this.consumeHexseq(e, i), \":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                return i;\n              }\n              consumeHexseq(e, t) {\n                let i = t;\n                for (; i = this.consumeHex4(e, i), \":\" === e[i] && \":\" !== e[i + 1];) i += 1;\n                return i;\n              }\n              consumeHex4(e, t) {\n                let i = 0;\n                for (; i < 4; i++) if (!((n = e[t + i]) >= \"0\" && n <= \"9\" || n >= \"a\" && n <= \"f\" || n >= \"A\" && n <= \"F\")) {\n                  if (0 === i) throw new Error(\"Invalid hex 4\");\n                  break;\n                }\n                var n;\n                return t + i;\n              }\n              consumeFQDN(e, t) {\n                let i = t;\n                for (; a(e[i]) || h(e[i]) || \"-\" === e[i] || \".\" === e[i];) i += 1;\n                if (i - t < 4) throw new Error(\"Invalid FQDN\");\n                return i;\n              }\n              consumeExtnAddr(e, t) {\n                return this.consumeOneOrMore(e, t, d);\n              }\n              consumeMulticastAddress(e, t, i) {\n                switch (i) {\n                  case \"IP4\":\n                  case \"ip4\":\n                    return this.consumeIP4MulticastAddress(e, t);\n                  case \"IP6\":\n                  case \"ip6\":\n                    return this.consumeIP6MulticastAddress(e, t);\n                  default:\n                    try {\n                      return this.consumeFQDN(e, t);\n                    } catch (i) {\n                      return this.consumeExtnAddr(e, t);\n                    }\n                }\n              }\n              consumeIP6MulticastAddress(e, t) {\n                const i = this.consumeHexpart(e, t);\n                return \"/\" === e[i] ? this.consumeInteger(e, i + 1) : i;\n              }\n              consumeIP4MulticastAddress(e, t) {\n                let i = t + 3;\n                const n = e.slice(t, i),\n                  r = parseInt(n);\n                if (r < 224 || r > 239) throw new Error(\"Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.\");\n                for (let t = 0; t < 3; t++) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 multicast address.\");\n                  i += 1, i = this.consumeDecimalUChar(e, i);\n                }\n                return \"/\" === e[i] && (i += 1), i = this.consumeTTL(e, i), \"/\" === e[i] && (i = this.consumeInteger(e, i)), i;\n              }\n              consumeInteger(e, t) {\n                if (!u(e[t])) throw new Error(\"Invalid integer.\");\n                for (t += 1; a(e[t]);) t += 1;\n                return t;\n              }\n              consumeTTL(e, t) {\n                if (\"0\" === e[t]) return t + 1;\n                if (!u(e[t])) throw new Error(\"Invalid TTL.\");\n                t += 1;\n                for (let i = 0; i < 2 && a(e[t]); i++) t += 1;\n                return t;\n              }\n              consumeToken(e, t) {\n                return this.consumeOneOrMore(e, t, l);\n              }\n              consumeTime(e, t) {\n                let i = t;\n                if (\"0\" === e[i]) return i + 1;\n                for (u(e[i]) && (i += 1); a(e[i]);) i++;\n                if (i - t < 10) throw new Error(\"Invalid time\");\n                return i;\n              }\n              consumeAddress(e, t) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeTypedTime(e, t) {\n                let i = t;\n                return i = this.consumeOneOrMore(e, i, a), p(e[i]) ? i + 1 : i;\n              }\n              consumeRepeatInterval(e, t) {\n                if (!u(e[t])) throw new Error(\"Invalid repeat interval\");\n                for (t += 1; a(e[t]);) t += 1;\n                return p(e[t]) && (t += 1), t;\n              }\n              consumePort(e, t) {\n                return this.consumeOneOrMore(e, t, a);\n              }\n              consume(e, t, i) {\n                for (let n = 0; n < i.length; n++) {\n                  if (t + n >= e.length) throw new Error(\"consume exceeding value length\");\n                  if (e[t + n] !== i[n]) throw new Error(\"consume \".concat(i, \" failed at \").concat(n));\n                }\n                return t + i.length;\n              }\n              consumeTill(e, t, i) {\n                let n = t;\n                for (; n < e.length && (\"string\" != typeof i || e[n] !== i) && (\"function\" != typeof i || !i(e[n]));) n++;\n                return n;\n              }\n            }\n            class C extends R {\n              constructor() {\n                super(), T(this, \"records\", []), T(this, \"currentLine\", 0);\n              }\n              parse(e) {\n                const t = this.probeEOL(e);\n                this.records = e.split(t).filter(e => !!kg(e).call(e)).map(this.parseLine), this.currentLine = 0;\n                const i = this.parseVersion(),\n                  n = this.parseOrigin(),\n                  r = this.parseSessionName(),\n                  o = this.parseInformation(),\n                  s = this.parseUri(),\n                  a = this.parseEmail(),\n                  c = this.parsePhone(),\n                  d = this.parseConnection(),\n                  l = this.parseBandWidth(),\n                  u = this.parseTimeFields(),\n                  h = this.parseKey(),\n                  p = this.parseSessionAttribute(),\n                  _ = this.parseMediaDescription();\n                if (this.currentLine !== this.records.length) throw new Error(\"parsing failed, non exhaustive sdp lines.\");\n                return {\n                  version: i,\n                  origin: n,\n                  sessionName: r,\n                  information: o,\n                  uri: s,\n                  emails: a,\n                  phones: c,\n                  connection: d,\n                  bandwidths: l,\n                  timeFields: u,\n                  key: h,\n                  attributes: p,\n                  mediaDescriptions: _\n                };\n              }\n              getCurrentRecord() {\n                const e = this.records[this.currentLine];\n                if (!e) throw new Error(\"Record doesn't exit.\");\n                return e;\n              }\n              probeEOL(e) {\n                for (let t = 0; t < e.length; t++) if (e[t] === n) return \"\\r\" === e[t - 1] ? r : n;\n                throw new Error(\"Invalid newline character.\");\n              }\n              parseLine(e, t) {\n                if (e.length < 2) throw new Error(\"Invalid sdp line, sdp line should be of form <type>=<value>.\");\n                const i = e[0];\n                if (\"=\" !== e[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an \"=\" sign.');\n                return {\n                  type: i,\n                  value: e.slice(2),\n                  line: t,\n                  cur: 0\n                };\n              }\n              parseSessionAttribute() {\n                const e = new y();\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(t, e => l(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === t.value[t.cur] && (t.cur += 1, i.attValue = this.extractOneOrMore(t, _)), e.parse(i), this.currentLine++;\n                }\n                return e.digest();\n              }\n              parseMediaAttributes(e) {\n                const t = new I(e);\n                for (; this.currentLine < this.records.length;) {\n                  const e = this.getCurrentRecord();\n                  if (e.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(e, e => l(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === e.value[e.cur] && (e.cur += 1, i.attValue = this.extractOneOrMore(e, _)), t.parse(i), this.currentLine++;\n                }\n                return t.digest();\n              }\n              parseKey() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.KEY) {\n                  if (\"prompt\" === e.value || \"clear:\" === e.value || \"base64:\" === e.value || \"uri:\" === e.value) return e.value;\n                  throw this.currentLine++, new Error(\"Invalid key.\");\n                }\n              }\n              parseZone() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.ZONE_ADJUSTMENTS) {\n                  const t = [];\n                  for (;;) try {\n                    const i = this.extract(e, this.consumeTime);\n                    this.consumeSpaceForRecord(e);\n                    let n = !1;\n                    \"-\" === e.value[e.cur] && (n = !0, e.cur += 1);\n                    const r = this.extract(e, this.consumeTypedTime);\n                    t.push({\n                      time: i,\n                      typedTime: r,\n                      back: n\n                    });\n                  } catch (e) {\n                    break;\n                  }\n                  if (0 === t.length) throw new Error(\"Invalid zone adjustments\");\n                  return this.currentLine++, t;\n                }\n                return [];\n              }\n              parseRepeat() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.REPEAT) break;\n                  {\n                    const i = this.extract(t, this.consumeRepeatInterval),\n                      n = this.parseTypedTime(t);\n                    e.push({\n                      repeatInterval: i,\n                      typedTimes: n\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseTypedTime(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeTypedTime));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid typed time.\");\n                return t;\n              }\n              parseTime() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeTime);\n                this.consumeSpaceForRecord(e);\n                const i = this.extract(e, this.consumeTime);\n                return this.currentLine++, {\n                  startTime: t,\n                  stopTime: i\n                };\n              }\n              parseBandWidth() {\n                const e = [];\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.BANDWIDTH) break;\n                  {\n                    const i = this.extractOneOrMore(t, l);\n                    if (\":\" !== t.value[t.cur]) throw new Error(\"Invalid bandwidth field.\");\n                    t.cur++;\n                    const n = this.extractOneOrMore(t, a);\n                    e.push({\n                      bwtype: i,\n                      bandwidth: n\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseVersion() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.VERSION) throw new Error(\"first sdp record must be version\");\n                const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, a));\n                if (t.length !== e.value.length) throw new Error('invalid proto version, \"v='.concat(e.value, '\"'));\n                return this.currentLine++, t;\n              }\n              parseOrigin() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.ORIGIN) throw new Error(\"second line of sdp must be origin\");\n                const t = this.extractOneOrMore(e, d);\n                this.consumeSpaceForRecord(e);\n                const i = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const n = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const r = this.extractOneOrMore(e, l);\n                this.consumeSpaceForRecord(e);\n                const o = this.extractOneOrMore(e, l);\n                this.consumeSpaceForRecord(e);\n                const c = this.extract(e, this.consumeUnicastAddress);\n                return this.currentLine++, {\n                  username: t,\n                  sessId: i,\n                  sessVersion: n,\n                  nettype: r,\n                  addrtype: o,\n                  unicastAddress: c\n                };\n              }\n              parseSessionName() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.SESSION_NAME) {\n                  const t = this.extract(e, this.consumeText);\n                  return this.currentLine++, t;\n                }\n              }\n              parseInformation() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.INFORMATION) return;\n                const t = this.extract(e, this.consumeText);\n                return this.currentLine++, t;\n              }\n              parseUri() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.URI) return this.currentLine++, e.value;\n              }\n              parseEmail() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.EMAIL) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parsePhone() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.PHONE) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parseConnection() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.CONNECTION) {\n                  const t = this.extractOneOrMore(e, l);\n                  this.consumeSpaceForRecord(e);\n                  const i = this.extractOneOrMore(e, l);\n                  this.consumeSpaceForRecord(e);\n                  const n = this.extract(e, this.consumeAddress);\n                  return this.currentLine++, {\n                    nettype: t,\n                    addrtype: i,\n                    address: n\n                  };\n                }\n              }\n              parseMedia() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeToken);\n                this.consumeSpaceForRecord(e);\n                let i = this.extract(e, this.consumePort);\n                \"/\" === e.value[e.cur] && (e.cur += 1, i += this.extract(e, this.consumeInteger)), this.consumeSpaceForRecord(e);\n                const n = [];\n                for (n.push(this.extract(e, this.consumeToken)); \"/\" === e.value[e.cur];) e.cur += 1, n.push(this.extract(e, this.consumeToken));\n                if (0 === n.length) throw new Error(\"Invalid proto\");\n                const r = this.parseFmt(e);\n                return this.currentLine++, {\n                  mediaType: t,\n                  port: i,\n                  protos: n,\n                  fmts: r\n                };\n              }\n              parseTimeFields() {\n                const e = [];\n                for (; this.getCurrentRecord().type === s.TIME;) {\n                  const t = this.parseTime(),\n                    i = this.parseRepeat(),\n                    n = this.parseZone();\n                  e.push({\n                    time: t,\n                    repeats: i,\n                    zones: n\n                  });\n                }\n                return e;\n              }\n              parseMediaDescription() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.MEDIA;) {\n                  const t = this.parseMedia(),\n                    i = this.parseInformation(),\n                    n = this.parseConnections(),\n                    r = this.parseBandWidth(),\n                    o = this.parseKey(),\n                    s = this.parseMediaAttributes(t);\n                  e.push({\n                    media: t,\n                    information: i,\n                    connections: n,\n                    bandwidths: r,\n                    key: o,\n                    attributes: s\n                  });\n                }\n                return e;\n              }\n              parseConnections() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.CONNECTION;) e.push(this.parseConnection());\n                return e;\n              }\n              parseFmt(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeToken));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid fmts\");\n                return t;\n              }\n              extract(e, t) {\n                for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n                const o = t.call(this, e.value, e.cur, ...n),\n                  s = e.value.slice(e.cur, o);\n                return e.cur = o, s;\n              }\n              extractOneOrMore(e, t) {\n                const i = this.consumeOneOrMore(e.value, e.cur, t),\n                  n = e.value.slice(e.cur, i);\n                return e.cur = i, n;\n              }\n              consumeSpaceForRecord(e) {\n                if (e.value[e.cur] !== o) throw new Error(\"Invalid space at \".concat(e.cur, \".\"));\n                e.cur += 1;\n              }\n            }\n            class v extends R {\n              constructor() {\n                super(...arguments), T(this, \"attributes\", void 0), T(this, \"digested\", !1);\n              }\n              extractOneOrMore(e, t, i) {\n                const n = this.consumeOneOrMore(e.attValue, e._cur, t),\n                  r = e.attValue.slice(e._cur, n),\n                  [o, s] = i || [];\n                if (\"number\" == typeof o && r.length < o) throw new Error(\"error in length, should be more or equal than \".concat(o, \" characters.\"));\n                if (\"number\" == typeof s && r.length > s) throw new Error(\"error in length, should be less or equal than \".concat(s, \" characters.\"));\n                return e._cur = n, r;\n              }\n              consumeAttributeSpace(e) {\n                if (e.attValue[e._cur] !== o) throw new Error(\"Invalid space at \".concat(e._cur, \".\"));\n                e._cur += 1;\n              }\n              extract(e, t) {\n                if (!e.attValue) throw new Error(\"Nothing to extract from attValue.\");\n                for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n                const o = t.call(this, e.attValue, e._cur, ...n),\n                  s = e.attValue.slice(e._cur, o);\n                return e._cur = o, s;\n              }\n              atEnd(e) {\n                if (!e.attValue) throw new Error();\n                return e._cur >= e.attValue.length;\n              }\n              peekChar(e) {\n                if (!e.attValue) throw new Error();\n                return e.attValue[e._cur];\n              }\n              peek(e, t) {\n                if (!e.attValue) throw new Error();\n                for (let i = 0; i < t.length; i++) if (t[i] !== e.attValue[e._cur + i]) return !1;\n                return !0;\n              }\n              parseIceUfrag(e) {\n                if (this.attributes.iceUfrag) throw new Error(\"Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'\");\n                this.attributes.iceUfrag = this.extractOneOrMore(e, E, [4, 256]);\n              }\n              parseIcePwd(e) {\n                if (this.attributes.icePwd) throw new Error(\"Invalid ice-pwd, should be only a single line if 'a=ice-pwd'\");\n                this.attributes.icePwd = this.extractOneOrMore(e, E, [22, 256]);\n              }\n              parseIceOptions(e) {\n                if (this.attributes.iceOptions) throw new Error(\"Invalid ice-options, should be only one 'ice-options' line\");\n                const t = [];\n                for (; !this.atEnd(e);) {\n                  t.push(this.extractOneOrMore(e, E));\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (t) {\n                    if (this.atEnd(e)) break;\n                    throw t;\n                  }\n                }\n                this.attributes.iceOptions = t;\n              }\n              parseFingerprint(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill);\n                this.attributes.fingerprints.push({\n                  hashFunction: t,\n                  fingerprint: i\n                });\n              }\n              parseExtmap(e) {\n                const t = this.extractOneOrMore(e, a);\n                let i;\n                \"/\" === this.peekChar(e) && (this.extract(e, this.consume, \"/\"), i = this.extract(e, this.consumeToken)), this.consumeAttributeSpace(e);\n                const n = this.extract(e, this.consumeTill, o),\n                  r = g(g({\n                    entry: parseInt(t, 10)\n                  }, i && {\n                    direction: i\n                  }), {}, {\n                    extensionName: n\n                  });\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), r.extensionAttributes = this.extract(e, this.consumeTill)), this.attributes.extmaps.push(r);\n              }\n              parseSetup(e) {\n                if (this.attributes.setup) throw new Error(\"must only be one single 'a=setup' line.\");\n                const t = this.extract(e, this.consumeTill);\n                if (\"active\" !== t && \"passive\" !== t && \"actpass\" !== t && \"holdconn\" !== t) throw new Error(\"role must be one of 'active', 'passive', 'actpass', 'holdconn'.\");\n                this.attributes.setup = t;\n              }\n            }\n            class y extends v {\n              constructor() {\n                super(...arguments), T(this, \"attributes\", {\n                  unrecognized: [],\n                  groups: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  identities: []\n                });\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"group\":\n                      this.parseGroup(e);\n                      break;\n                    case \"ice-lite\":\n                      this.parseIceLite();\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"tls-id\":\n                      this.parseTlsId(e);\n                      break;\n                    case \"identity\":\n                      this.parseIdentity(e);\n                      break;\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"msid-semantic\":\n                      this.parseMsidSemantic(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing session attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) this.consumeAttributeSpace(e), i.push(this.extract(e, this.consumeToken));\n                this.attributes.groups.push({\n                  semantic: t,\n                  identificationTag: i\n                });\n              }\n              parseIceLite() {\n                if (this.attributes.iceLite) throw new Error(\"Invalid ice-lite, should be only a single line of 'a=ice-lite'\");\n                this.attributes.iceLite = !0;\n              }\n              parseTlsId(e) {\n                if (this.attributes.tlsId) throw new Error(\"must be only one tld-id line\");\n                this.attributes.tlsId = this.extractOneOrMore(e, m);\n              }\n              parseIdentity(e) {\n                const t = this.extractOneOrMore(e, f),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.extract(e, this.consume, \"=\");\n                  const n = this.extractOneOrMore(e, e => e !== o && _(e));\n                  i.push({\n                    name: t,\n                    value: n\n                  });\n                }\n                this.attributes.identities.push({\n                  assertionValue: t,\n                  extensions: i\n                });\n              }\n              parseMsidSemantic(e) {\n                this.peekChar(e) === o && this.consumeAttributeSpace(e);\n                const t = {\n                  semantic: this.extract(e, this.consumeToken),\n                  identifierList: []\n                };\n                for (;;) {\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                  if (\"*\" === this.peekChar(e)) {\n                    this.extract(e, this.consume, \"*\"), t.applyForAll = !0;\n                    break;\n                  }\n                  {\n                    const i = this.extract(e, this.consumeTill, o);\n                    t.identifierList.push(i);\n                  }\n                }\n                this.attributes.msidSemantic = t;\n              }\n            }\n            class I extends v {\n              constructor(e) {\n                super(), T(this, \"attributes\", void 0), -1 !== e.protos.indexOf(\"RTP\") || e.protos.indexOf(\"rtp\"), this.attributes = {\n                  unrecognized: [],\n                  candidates: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: [],\n                  ssrcGroups: [],\n                  rtcpFeedbackWildcards: [],\n                  payloads: []\n                };\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"candidate\":\n                      this.parseCandidate(e);\n                      break;\n                    case \"remote-candidate\":\n                      this.parseRemoteCandidate(e);\n                      break;\n                    case \"end-of-candidates\":\n                      this.parseEndOfCandidates();\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"rtpmap\":\n                      this.parseRtpmap(e);\n                      break;\n                    case \"ptime\":\n                      this.parsePtime(e);\n                      break;\n                    case \"maxptime\":\n                      this.parseMaxPtime(e);\n                      break;\n                    case \"sendrecv\":\n                    case \"recvonly\":\n                    case \"sendonly\":\n                    case \"inactive\":\n                      this.parseDirection(e);\n                      break;\n                    case \"ssrc\":\n                      this.parseSSRC(e);\n                      break;\n                    case \"fmtp\":\n                      this.parseFmtp(e);\n                      break;\n                    case \"rtcp-fb\":\n                      this.parseRtcpFb(e);\n                      break;\n                    case \"rtcp-mux\":\n                      this.parseRTCPMux();\n                      break;\n                    case \"rtcp-mux-only\":\n                      this.parseRTCPMuxOnly();\n                      break;\n                    case \"rtcp-rsize\":\n                      this.parseRTCPRsize();\n                      break;\n                    case \"rtcp\":\n                      this.parseRTCP(e);\n                      break;\n                    case \"mid\":\n                      this.parseMid(e);\n                      break;\n                    case \"msid\":\n                      this.parseMsid(e);\n                      break;\n                    case \"imageattr\":\n                      this.parseImageAttr(e);\n                      break;\n                    case \"rid\":\n                      this.parseRid(e);\n                      break;\n                    case \"simulcast\":\n                      this.parseSimulcast(e);\n                      break;\n                    case \"sctp-port\":\n                      this.parseSctpPort(e);\n                      break;\n                    case \"max-message-size\":\n                      this.parseMaxMessageSize(e);\n                      break;\n                    case \"ssrc-group\":\n                      this.parseSSRCGroup(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing media attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              parseCandidate(e) {\n                const t = this.extractOneOrMore(e, E, [1, 32]);\n                this.consumeAttributeSpace(e);\n                const i = this.extractOneOrMore(e, a, [1, 5]);\n                this.consumeAttributeSpace(e);\n                const n = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const r = this.extractOneOrMore(e, a, [1, 10]);\n                this.consumeAttributeSpace(e);\n                const s = this.extract(e, this.consumeAddress);\n                this.consumeAttributeSpace(e);\n                const d = this.extract(e, this.consumePort);\n                this.consumeAttributeSpace(e), this.extract(e, this.consume, \"typ\"), this.consumeAttributeSpace(e);\n                const l = {\n                  foundation: t,\n                  componentId: i,\n                  transport: n,\n                  priority: r,\n                  connectionAddress: s,\n                  port: d,\n                  type: this.extract(e, this.consumeToken),\n                  extension: {}\n                };\n                for (this.peek(e, \" raddr\") && (this.extract(e, this.consume, \" raddr\"), this.consumeAttributeSpace(e), l.relAddr = this.extract(e, this.consumeAddress)), this.peek(e, \" rport\") && (this.extract(e, this.consume, \" rport\"), this.consumeAttributeSpace(e), l.relPort = this.extract(e, this.consumePort)); this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.consumeAttributeSpace(e), l.extension[t] = this.extractOneOrMore(e, c);\n                }\n                this.attributes.candidates.push(l);\n              }\n              parseRemoteCandidate(e) {\n                const t = [];\n                for (;;) {\n                  const i = this.extractOneOrMore(e, a, [1, 5]);\n                  this.consumeAttributeSpace(e);\n                  const n = this.extract(e, this.consumeAddress);\n                  this.consumeAttributeSpace(e);\n                  const r = this.extract(e, this.consumePort);\n                  t.push({\n                    componentId: i,\n                    connectionAddress: n,\n                    port: r\n                  });\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                }\n                this.attributes.remoteCandidatesList.push(t);\n              }\n              parseEndOfCandidates() {\n                if (this.attributes.endOfCandidates) throw new Error(\"must be only one line of end-of-candidates\");\n                this.attributes.endOfCandidates = !0;\n              }\n              parseRtpmap(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \"/\");\n                this.extract(e, this.consume, \"/\");\n                const n = {\n                  encodingName: i,\n                  clockRate: this.extractOneOrMore(e, a)\n                };\n                this.atEnd(e) || \"/\" !== this.peekChar(e) || (this.extract(e, this.consume, \"/\"), n.encodingParameters = parseInt(this.extract(e, this.consumeTill), 10));\n                const r = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                r ? r.rtpMap = n : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtpMap: n,\n                  rtcpFeedbacks: []\n                });\n              }\n              parsePtime(e) {\n                if (this.attributes.ptime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.ptime = this.extract(e, this.consumeTill);\n              }\n              parseMaxPtime(e) {\n                if (this.attributes.maxPtime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.maxPtime = this.extract(e, this.consumeTill);\n              }\n              parseDirection(e) {\n                if (this.attributes.direction) throw new Error(\"must be only one line of direction info\");\n                this.attributes.direction = e.attField;\n              }\n              parseSSRC(e) {\n                const t = this.extractOneOrMore(e, a);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \":\");\n                let n;\n                \":\" === this.peekChar(e) && (this.extract(e, this.consume, \":\"), n = this.extract(e, this.consumeTill));\n                const r = this.attributes.ssrcs.find(e => e.ssrcId === parseInt(t, 10));\n                r ? r.attributes[i] = n : this.attributes.ssrcs.push({\n                  ssrcId: parseInt(t, 10),\n                  attributes: {\n                    [i]: n\n                  }\n                });\n              }\n              parseFmtp(e) {\n                const t = this.extract(e, this.consumeTill, o);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill),\n                  n = {};\n                i.split(\";\").forEach(e => {\n                  let [t, i] = e.split(\"=\");\n                  t = kg(t).call(t);\n                  const r = \"string\" == typeof i ? kg(i).call(i) : null;\n                  \"string\" == typeof t && t.length > 0 && (n[t] = r);\n                });\n                const r = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                r ? r.fmtp = {\n                  parameters: n\n                } : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtcpFeedbacks: [],\n                  fmtp: {\n                    parameters: n\n                  }\n                });\n              }\n              parseFmtParameters(e) {\n                const t = {},\n                  i = this.extract(e, this.consumeTill, \"=\");\n                e._cur++;\n                const n = this.extract(e, this.consumeTill, \";\");\n                for (t[i] = n; \";\" === e.attValue[e._cur];) {\n                  const i = this.extract(e, this.consumeTill, \"=\");\n                  e._cur++;\n                  const n = this.extract(e, this.consumeTill, \";\");\n                  t[i] = n;\n                }\n                return t;\n              }\n              parseRtcpFb(e) {\n                let t = \"\";\n                t = \"*\" === this.peekChar(e) ? this.extract(e, this.consume, \"*\") : this.extract(e, this.consumeTill, o), this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, o);\n                let n;\n                if (\"trr-int\" === i) n = {\n                  type: i,\n                  interval: this.extract(e, this.consumeTill)\n                };else {\n                  const t = {\n                    type: i\n                  };\n                  this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.parameter = this.extract(e, this.consumeToken), this.peekChar(e) === o && (t.additional = this.extract(e, this.consumeTill))), n = t;\n                }\n                if (\"*\" === t) this.attributes.rtcpFeedbackWildcards.push(n);else {\n                  const e = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                  e ? e.rtcpFeedbacks.push(n) : this.attributes.payloads.push({\n                    payloadType: parseInt(t, 10),\n                    rtcpFeedbacks: [n]\n                  });\n                }\n              }\n              parseRTCPMux() {\n                if (this.attributes.rtcpMux) throw new Error(\"must be single line of rtcp-mux\");\n                this.attributes.rtcpMux = !0;\n              }\n              parseRTCPMuxOnly() {\n                if (this.attributes.rtcpMuxOnly) throw new Error(\"must be single line of rtcp-only\");\n                this.attributes.rtcpMuxOnly = !0;\n              }\n              parseRTCPRsize() {\n                if (this.attributes.rtcpRsize) throw new Error(\"must be single line of rtcp-rsize\");\n                this.attributes.rtcpRsize = !0;\n              }\n              parseRTCP(e) {\n                if (this.attributes.rtcp) throw new Error(\"must be single line of rtcp\");\n                const t = {\n                  port: this.extract(e, this.consumePort)\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.netType = this.extractOneOrMore(e, l), this.consumeAttributeSpace(e), t.addressType = this.extractOneOrMore(e, l), this.consumeAttributeSpace(e), t.address = this.extract(e, this.consumeAddress)), this.attributes.rtcp = t;\n              }\n              parseMsid(e) {\n                const t = {\n                  id: this.extractOneOrMore(e, l, [1, 64])\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.appdata = this.extractOneOrMore(e, l, [1, 64])), this.attributes.msids.push(t);\n              }\n              parseImageAttr(e) {\n                this.attributes.imageattr.push(e.attValue);\n              }\n              parseRid(e) {\n                const t = this.extractOneOrMore(e, e => h(e) || a(e) || \"_\" === e || \"-\" === e);\n                this.consumeAttributeSpace(e);\n                const i = {\n                  id: t,\n                  direction: this.extract(e, this.consumeToken),\n                  params: []\n                };\n                if (this.peekChar(e) === o) {\n                  if (this.consumeAttributeSpace(e), this.peek(e, \"pt=\")) {\n                    this.extract(e, this.consume, \"pt=\");\n                    const t = [];\n                    for (;;) {\n                      const i = this.extract(e, this.consumeToken);\n                      t.push(i);\n                      try {\n                        this.extract(e, this.consume, \",\");\n                      } catch (e) {\n                        break;\n                      }\n                    }\n                    i.payloads = t, this.peekChar(e) === o && this.extract(e, this.consume, o);\n                  }\n                  for (;;) {\n                    const t = this.extract(e, this.consumeToken);\n                    switch (t) {\n                      case \"depend\":\n                        {\n                          const n = {\n                            type: t,\n                            rids: this.extract(e, this.consume, \"=\").split(\",\")\n                          };\n                          i.params.push(n);\n                          break;\n                        }\n                      default:\n                        {\n                          const n = {\n                            type: t\n                          };\n                          \"=\" === this.peekChar(e) && (this.extract(e, this.consume, \"=\"), n.val = this.extract(e, this.consumeTill, \";\")), i.params.push(n);\n                        }\n                    }\n                    try {\n                      this.extract(e, this.consume, \";\");\n                    } catch (e) {\n                      break;\n                    }\n                  }\n                }\n                this.attributes.rids.push(i);\n              }\n              parseSimulcast(e) {\n                if (this.attributes.simulcast) throw new Error(\"must be single line of simulcast\");\n                this.attributes.simulcast = e.attValue, this.extract(e, this.consumeTill);\n              }\n              parseSctpPort(e) {\n                this.attributes.sctpPort = this.extractOneOrMore(e, a, [1, 5]);\n              }\n              parseMaxMessageSize(e) {\n                this.attributes.maxMessageSize = this.extractOneOrMore(e, a, [1, void 0]);\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseMid(e) {\n                this.attributes.mid = this.extract(e, this.consumeToken);\n              }\n              parseSSRCGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (;;) try {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeInteger);\n                  i.push(parseInt(t, 10));\n                } catch (e) {\n                  break;\n                }\n                this.attributes.ssrcGroups.push({\n                  semantic: t,\n                  ssrcIds: i\n                });\n              }\n            }\n            function A(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            class b {\n              constructor() {\n                A(this, \"eol\", r);\n              }\n              print(e, t) {\n                let i = \"\";\n                return t && (this.eol = t), i += this.printVersion(e.version), i += this.printOrigin(e.origin), i += this.printSessionName(e.sessionName), i += this.printInformation(e.information), i += this.printUri(e.uri), i += this.printEmail(e.emails), i += this.printPhone(e.phones), i += this.printConnection(e.connection), i += this.printBandwidth(e.bandwidths), i += this.printTimeFields(e.timeFields), i += this.printKey(e.key), i += this.printSessionAttributes(e.attributes), i += this.printMediaDescription(e.mediaDescriptions), i;\n              }\n              printVersion(e) {\n                return \"v=\".concat(e).concat(this.eol);\n              }\n              printOrigin(e) {\n                return \"o=\".concat(e.username, \" \").concat(e.sessId, \" \").concat(e.sessVersion, \" \").concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.unicastAddress).concat(this.eol);\n              }\n              printSessionName(e) {\n                return e ? \"s=\".concat(e).concat(this.eol) : \"\";\n              }\n              printInformation(e) {\n                return e ? \"i=\".concat(e).concat(this.eol) : \"\";\n              }\n              printUri(e) {\n                return e ? \"u=\".concat(e).concat(this.eol) : \"\";\n              }\n              printEmail(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printPhone(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printConnection(e) {\n                return e ? \"c=\".concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.address).concat(this.eol) : \"\";\n              }\n              printBandwidth(e) {\n                let t = \"\";\n                for (const i of e) t += \"b=\".concat(i.bwtype, \":\").concat(i.bandwidth).concat(this.eol);\n                return t;\n              }\n              printTimeFields(e) {\n                let t = \"\";\n                for (const i of e) {\n                  t += \"t=\".concat(i.time.startTime, \" \").concat(i.time.startTime).concat(this.eol);\n                  for (const e of i.repeats) t += \"r=\".concat(e.repeatInterval, \" \").concat(e.typedTimes.join(\" \")).concat(this.eol);\n                  i.zoneAdjustments && (t += \"z=\", t += \"z=\".concat(i.zoneAdjustments.map(e => \"\".concat(e.time, \" \").concat(e.back ? \"-\" : \"\", \" \").concat(e.typedTime)).join(\" \")).concat(this.eol), t += this.eol);\n                }\n                return t;\n              }\n              printKey(e) {\n                return e ? \"k=\".concat(e).concat(this.eol) : \"\";\n              }\n              printAttributes(e) {\n                let t = \"\";\n                for (const i of e) t += \"a=\".concat(i.attField).concat(i.attValue ? \":\".concat(i.attValue) : \"\").concat(this.eol);\n                return t;\n              }\n              printMediaDescription(e) {\n                let t = \"\";\n                for (const i of e) t += this.printMedia(i.media), t += this.printInformation(i.information), t += this.printConnections(i.connections), t += this.printBandwidth(i.bandwidths), t += this.printKey(i.key), t += this.printMediaAttributes(i);\n                return t;\n              }\n              printConnections(e) {\n                let t = \"\";\n                for (const i of e) t += this.printConnection(i);\n                return t;\n              }\n              printMedia(e) {\n                return \"m=\".concat(e.mediaType, \" \").concat(e.port, \" \").concat(e.protos.join(\"/\"), \" \").concat(e.fmts.join(\" \")).concat(this.eol);\n              }\n              printSessionAttributes(e) {\n                return new O(this.eol).print(e);\n              }\n              printMediaAttributes(e) {\n                return new N(this.eol).print(e);\n              }\n            }\n            class w {\n              constructor(e) {\n                A(this, \"eol\", void 0), this.eol = e;\n              }\n              printIceUfrag(e) {\n                return void 0 === e ? \"\" : \"a=ice-ufrag:\".concat(e).concat(this.eol);\n              }\n              printIcePwd(e) {\n                return void 0 === e ? \"\" : \"a=ice-pwd:\".concat(e).concat(this.eol);\n              }\n              printIceOptions(e) {\n                return void 0 === e ? \"\" : \"a=ice-options:\".concat(e.join(o)).concat(this.eol);\n              }\n              printFingerprints(e) {\n                return e.length > 0 ? e.map(e => \"a=fingerprint:\".concat(e.hashFunction).concat(o).concat(e.fingerprint)).join(this.eol) + this.eol : \"\";\n              }\n              printExtmap(e) {\n                return e.map(e => \"a=extmap:\".concat(e.entry).concat(e.direction ? \"/\".concat(e.direction) : \"\").concat(o).concat(e.extensionName).concat(e.extensionAttributes ? \"\".concat(o).concat(e.extensionAttributes) : \"\").concat(this.eol)).join(\"\");\n              }\n              printSetup(e) {\n                return void 0 === e ? \"\" : \"a=setup:\".concat(e).concat(this.eol);\n              }\n              printUnrecognized(e) {\n                return e.map(e => \"a=\".concat(e.attField).concat(e.attValue ? \":\".concat(e.attValue) : \"\").concat(this.eol)).join(\"\");\n              }\n            }\n            class O extends w {\n              print(e) {\n                let t = \"\";\n                return t += this.printGroups(e.groups), t += this.printMsidSemantic(e.msidSemantic), t += this.printIceLite(e.iceLite), t += this.printIceUfrag(e.iceUfrag), t += this.printIcePwd(e.icePwd), t += this.printIceOptions(e.iceOptions), t += this.printFingerprints(e.fingerprints), t += this.printSetup(e.setup), t += this.printTlsId(e.tlsId), t += this.printIdentity(e.identities), t += this.printExtmap(e.extmaps), t += this.printUnrecognized(e.unrecognized), t;\n              }\n              printGroups(e) {\n                let t = \"\";\n                return e.length > 0 && (t += e.map(e => \"a=group:\".concat(e.semantic).concat(e.identificationTag.map(e => \"\".concat(o).concat(e)).join(\"\")).concat(this.eol)).join(\"\")), t;\n              }\n              printIceLite(e) {\n                return void 0 === e ? \"\" : \"a=ice-lite\" + this.eol;\n              }\n              printTlsId(e) {\n                return e ? \"a=tls-id:\".concat(e).concat(this.eol) : \"\";\n              }\n              printIdentity(e) {\n                return 0 === e.length ? \"\" : e.map(e => \"a=identity:\".concat(e.assertionValue).concat(e.extensions.map(e => \"\".concat(o).concat(e.name).concat(e.value ? \"=\".concat(e.value) : \"\")))).join(this.eol) + this.eol;\n              }\n              printMsidSemantic(e) {\n                if (!e) return \"\";\n                let t = \"a=msid-semantic:\".concat(e.semantic);\n                return e.applyForAll ? t += \"\".concat(o, \"*\") : e.identifierList.length > 0 && (t += e.identifierList.map(e => \"\".concat(o).concat(e))), t + this.eol;\n              }\n            }\n            class N extends w {\n              print(e) {\n                const t = e.attributes;\n                let i = \"\";\n                return i += this.printRTCP(t.rtcp), i += this.printIceUfrag(t.iceUfrag), i += this.printIcePwd(t.icePwd), i += this.printIceOptions(t.iceOptions), i += this.printCandidates(t.candidates), i += this.printRemoteCandidatesList(t.remoteCandidatesList), i += this.printEndOfCandidates(t.endOfCandidates), i += this.printFingerprints(t.fingerprints), i += this.printSetup(t.setup), i += this.printMid(t.mid), i += this.printExtmap(t.extmaps), i += this.printRTPRelated(t), i += this.printPtime(t.ptime), i += this.printMaxPtime(t.maxPtime), i += this.printDirection(t.direction), i += this.printSSRCGroups(t.ssrcGroups), i += this.printSSRC(t.ssrcs), i += this.printRTCPMux(t.rtcpMux), i += this.printRTCPMuxOnly(t.rtcpMuxOnly), i += this.printRTCPRsize(t.rtcpRsize), i += this.printMSId(t.msids), i += this.printImageattr(t.imageattr), i += this.printRid(t.rids), i += this.printSimulcast(t.simulcast), i += this.printSCTPPort(t.sctpPort), i += this.printMaxMessageSize(t.maxMessageSize), i += this.printUnrecognized(t.unrecognized), i;\n              }\n              printCandidates(e) {\n                return e.map(e => \"a=candidate:\".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o, \"typ\").concat(o).concat(e.type).concat(e.relAddr ? \"\".concat(o, \"raddr\").concat(o).concat(e.relAddr) : \"\").concat(e.relPort ? \"\".concat(o, \"rport\").concat(o).concat(e.relPort) : \"\").concat(Object.keys(e.extension).map(t => \"\".concat(o).concat(t).concat(o).concat(e.extension[t])).join(\"\")).concat(this.eol)).join(\"\");\n              }\n              printRemoteCandidatesList(e) {\n                return e.map(e => \"a=remote-candidates:\".concat(e.join(o)).concat(this.eol)).join(\"\");\n              }\n              printEndOfCandidates(e) {\n                return void 0 === e ? \"\" : \"a=end-of-candidates\" + this.eol;\n              }\n              printRTPRelated(e) {\n                if (!e.payloads) return \"\";\n                const t = e.payloads;\n                let i = \"\";\n                i += e.rtcpFeedbackWildcards.map(e => this.printRTCPFeedback(\"*\", e)).join(\"\");\n                for (const e of t) i += this.printRtpMap(e.payloadType, e.rtpMap), i += this.printFmtp(e.payloadType, e.fmtp), i += e.rtcpFeedbacks.map(t => this.printRTCPFeedback(e.payloadType, t)).join(\"\");\n                return i;\n              }\n              printFmtp(e, t) {\n                if (!t) return \"\";\n                const i = Object.keys(t.parameters);\n                return 1 === i.length && null === t.parameters[i[0]] ? \"a=fmtp:\".concat(e).concat(o).concat(i[0]).concat(this.eol) : \"a=fmtp:\".concat(e).concat(o).concat(Object.keys(t.parameters).map(e => \"\".concat(e, \"=\").concat(t.parameters[e])).join(\";\")).concat(this.eol);\n              }\n              printRtpMap(e, t) {\n                return t ? \"a=rtpmap:\".concat(e).concat(o).concat(t.encodingName, \"/\").concat(t.clockRate).concat(t.encodingParameters ? \"/\".concat(t.encodingParameters) : \"\").concat(this.eol) : \"\";\n              }\n              printRTCPFeedback(e, t) {\n                let i = \"a=rtcp-fb:\".concat(e).concat(o),\n                  n = t;\n                return \"trr-int\" === n.type ? i += \"ttr-int\".concat(o).concat(n.interval) : (i += \"\".concat(n.type), n.parameter && (i += \"\".concat(o).concat(n.parameter), n.additional && (i += \"\".concat(o).concat(n.additional)))), i + this.eol;\n              }\n              printPtime(e) {\n                return void 0 === e ? \"\" : \"a=ptime:\".concat(e).concat(this.eol);\n              }\n              printMaxPtime(e) {\n                return void 0 === e ? \"\" : \"a=maxptime:\".concat(e).concat(this.eol);\n              }\n              printDirection(e) {\n                return void 0 === e ? \"\" : \"a=\".concat(e).concat(this.eol);\n              }\n              printSSRC(e) {\n                return e.map(e => Object.keys(e.attributes).map(t => \"a=ssrc:\".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t] ? \":\".concat(e.attributes[t]) : \"\").concat(this.eol)).join(\"\")).join(\"\");\n              }\n              printRTCPMux(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux\".concat(this.eol);\n              }\n              printRTCPMuxOnly(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux-only\".concat(this.eol);\n              }\n              printRTCPRsize(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-rsize\".concat(this.eol);\n              }\n              printRTCP(e) {\n                if (void 0 === e) return \"\";\n                let t = \"a=rtcp:\".concat(e.port);\n                return e.netType && (t += \"\".concat(o).concat(e.netType)), e.addressType && (t += \"\".concat(o).concat(e.addressType)), e.address && (t += \"\".concat(o).concat(e.address)), t + this.eol;\n              }\n              printMSId(e) {\n                return e.map(e => \"a=msid:\".concat(e.id).concat(e.appdata ? \"\".concat(o).concat(e.appdata) : \"\").concat(this.eol)).join(\"\");\n              }\n              printImageattr(e) {\n                return e.map(e => \"a=imageattr:\".concat(e).concat(this.eol)).join(\"\");\n              }\n              printRid(e) {\n                return e.map(e => {\n                  let t = \"a=rid:\".concat(e.id).concat(o).concat(e.direction);\n                  return e.payloads && (t += \"\".concat(o, \"pt=\").concat(e.payloads.join(\",\"))), e.params.length > 0 && (t += \"\".concat(o).concat(e.params.map(e => \"depend\" === e.type ? \"depend=\".concat(e.rids.join(\",\")) : \"\".concat(e.type, \"=\").concat(e.val)).join(\";\"))), t + this.eol;\n                }).join(\"\");\n              }\n              printSimulcast(e) {\n                return void 0 === e ? \"\" : \"a=simulcast:\".concat(e).concat(this.eol);\n              }\n              printSCTPPort(e) {\n                return void 0 === e ? \"\" : \"a=sctp-port:\".concat(e).concat(this.eol);\n              }\n              printMaxMessageSize(e) {\n                return void 0 === e ? \"\" : \"a=max-message-size:\".concat(e).concat(this.eol);\n              }\n              printMid(e) {\n                return void 0 === e ? \"\" : \"a=mid:\".concat(e).concat(this.eol);\n              }\n              printSSRCGroups(e) {\n                return e.map(e => \"a=ssrc-group:\".concat(e.semantic).concat(e.ssrcIds.map(e => \"\".concat(o).concat(e.toString(10))).join(\"\")).concat(this.eol)).join(\"\");\n              }\n            }\n            function D(e) {\n              return new C().parse(e);\n            }\n            function P(e, t) {\n              return new b().print(e, t);\n            }\n          }\n        },\n        t = {};\n      function i(n) {\n        if (t[n]) return t[n].exports;\n        var r = t[n] = {\n          exports: {}\n        };\n        return e[n](r, r.exports, i), r.exports;\n      }\n      return i.d = (e, t) => {\n        for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, {\n          enumerable: !0,\n          get: t[n]\n        });\n      }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n      }, i(8);\n    })();\n    function LD(e) {\n      return PD.parse(e);\n    }\n    function kD(e, t) {\n      return PD.print(e, t);\n    }\n    var MD = Zi(\"Array\", \"keys\"),\n      UD = En,\n      VD = $e,\n      xD = l,\n      FD = MD,\n      BD = Array.prototype,\n      jD = {\n        DOMTokenList: !0,\n        NodeList: !0\n      },\n      GD = function (e) {\n        var t = e.keys;\n        return e === BD || xD(BD, e) && t === BD.keys || VD(jD, UD(e)) ? FD : t;\n      },\n      WD = i(GD);\n    function HD(e, t, i) {\n      return (t = function (e) {\n        var t = function (e, t) {\n          if (\"object\" != typeof e || !e) return e;\n          var i = e[Symbol.toPrimitive];\n          if (void 0 !== i) {\n            var n = i.call(e, \"string\");\n            if (\"object\" != typeof n) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return String(e);\n        }(e);\n        return \"symbol\" == typeof t ? t : t + \"\";\n      }(t)) in e ? Object.defineProperty(e, t, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = i, e;\n    }\n    function KD(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function YD(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? KD(Object(i), !0).forEach(function (t) {\n          HD(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : KD(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    function zD(e, t) {\n      return zD = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {\n        return e.__proto__ = t, e;\n      }, zD(e, t);\n    }\n    function qD() {\n      qD = function (e, t) {\n        return new i(e, void 0, t);\n      };\n      var e = RegExp.prototype,\n        t = new WeakMap();\n      function i(e, n, r) {\n        var o = RegExp(e, n);\n        return t.set(o, r || t.get(e)), zD(o, i.prototype);\n      }\n      function n(e, i) {\n        var n,\n          r = t.get(i);\n        return nr(n = Object.keys(r)).call(n, function (t, i) {\n          var n = r[i];\n          if (\"number\" == typeof n) t[i] = e[n];else {\n            for (var o = 0; void 0 === e[n[o]] && o + 1 < n.length;) o++;\n            t[i] = e[n[o]];\n          }\n          return t;\n        }, Object.create(null));\n      }\n      return function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), t && zD(e, t);\n      }(i, RegExp), i.prototype.exec = function (t) {\n        var i = e.exec.call(this, t);\n        if (i) {\n          i.groups = n(i, this);\n          var r = i.indices;\n          r && (r.groups = n(r, this));\n        }\n        return i;\n      }, i.prototype[Symbol.replace] = function (i, r) {\n        if (\"string\" == typeof r) {\n          var o = t.get(this);\n          return e[Symbol.replace].call(this, i, r.replace(/\\$<([^>]+)(>|$)/g, function (e, t, i) {\n            if (\"\" === i) return e;\n            var n = o[t];\n            return Array.isArray(n) ? \"$\" + n.join(\"$\") : \"number\" == typeof n ? \"$\" + n : \"\";\n          }));\n        }\n        if (\"function\" == typeof r) {\n          var s = this;\n          return e[Symbol.replace].call(this, i, function () {\n            var e = arguments;\n            return \"object\" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(n(e, s)), r.apply(this, e);\n          });\n        }\n        return e[Symbol.replace].call(this, i, r);\n      }, qD.apply(this, arguments);\n    }\n    const XD = new class extends NO {\n      constructor() {\n        super(...arguments), HD(this, \"currentUploadLogID\", 0);\n      }\n      reportLogUploadError(e) {\n        const {\n          errorRange: t\n        } = e;\n        t[t.length - 1] && t[t.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t[t.length - 1], this.emit(\"REPORT_LOG_UPLOAD\", e));\n      }\n    }();\n    class JD {\n      constructor(e) {\n        HD(this, \"logger\", void 0), HD(this, \"prefixLists\", []), this.logger = e;\n      }\n      debug() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        this.logger.debug(...this.prefixLists, ...t);\n      }\n      info() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        this.logger.info(...this.prefixLists, ...t);\n      }\n      warning() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        this.logger.warning(...this.prefixLists, ...t);\n      }\n      error() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        this.logger.error(...this.prefixLists, ...t);\n      }\n      prefix(e) {\n        return this.prefixLists.push(e), this;\n      }\n      popPrefix() {\n        return this.prefixLists.pop(), this;\n      }\n    }\n    function QD() {\n      const e = new Date();\n      return e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n    }\n    function ZD() {\n      const e = new Date(),\n        t = /((\\d+:){2}\\d+)/.exec(new Date().toUTCString());\n      return t ? (null == t ? void 0 : t[0]) + \":\" + e.getUTCMilliseconds() : e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n    }\n    const $D = {\n        DEBUG: 0,\n        INFO: 1,\n        WARNING: 2,\n        ERROR: 3,\n        NONE: 4\n      },\n      eP = Date.now(),\n      tP = e => {\n        for (const t in $D) if (Object.prototype.hasOwnProperty.call($D, t) && $D[t] === e) return t;\n        return \"DEFAULT\";\n      };\n    const iP = new class {\n      constructor() {\n        HD(this, \"proxyServerURL\", void 0), HD(this, \"logLevel\", $D.DEBUG), HD(this, \"uploadState\", \"collecting\"), HD(this, \"uploadLogWaitingList\", []), HD(this, \"uploadLogUploadingList\", []), HD(this, \"uploadErrorCount\", 0), HD(this, \"currentLogID\", 0), HD(this, \"url\", void 0), HD(this, \"extLog\", (e, t) => {\n          this.appendLogToWaitingList(e, ...t);\n        });\n      }\n      debug() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = [$D.DEBUG].concat(t);\n        this.log.apply(this, n);\n      }\n      info() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = [$D.INFO].concat(t);\n        this.log.apply(this, n);\n      }\n      warning() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = [$D.WARNING].concat(t);\n        this.log.apply(this, n);\n      }\n      warn() {\n        this.warning(...arguments);\n      }\n      error() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = [$D.ERROR].concat(t);\n        this.log.apply(this, n);\n      }\n      upload() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = [$D.DEBUG].concat(t);\n        this.uploadLog.apply(this, n);\n      }\n      setLogLevel(e) {\n        e = Math.min(Math.max(0, e), 4), this.logLevel = e;\n      }\n      enableLogUpload() {\n        RD(\"UPLOAD_LOG\", !0);\n      }\n      disableLogUpload() {\n        RD(\"UPLOAD_LOG\", !1), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];\n      }\n      setProxyServer(e) {\n        this.proxyServerURL = e;\n      }\n      prefix(e) {\n        return new JD(this).prefix(e);\n      }\n      log() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        if (Date.now() - eP < 100) return void setTimeout(() => {\n          this.log(...t);\n        }, Date.now() - eP);\n        const n = Math.max(0, Math.min(4, t[0]));\n        if (t[0] = QD() + \" Agora-SDK [\".concat(tP(n), \"]:\"), this.appendLogToWaitingList(n, ...t), n < this.logLevel) return;\n        const r = QD() + \" %cAgora-SDK [\".concat(tP(n), \"]:\");\n        let o = [];\n        if (!CD(\"USE_NEW_LOG\")) switch (n) {\n          case $D.DEBUG:\n            o = [r, \"color: #64B5F6;\"].concat(t.slice(1)), console.log.apply(console, o);\n            break;\n          case $D.INFO:\n            o = [r, \"color: #1E88E5; font-weight: bold;\"].concat(t.slice(1)), console.log.apply(console, o);\n            break;\n          case $D.WARNING:\n            o = [r, \"color: #FB8C00; font-weight: bold;\"].concat(t.slice(1)), console.warn.apply(console, o);\n            break;\n          case $D.ERROR:\n            o = [r, \"color: #B00020; font-weight: bold;\"].concat(t.slice(1)), console.error.apply(console, o);\n        }\n      }\n      uploadLog() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        if (Date.now() - eP < 100) return void setTimeout(() => {\n          this.uploadLog(...t);\n        }, Date.now() - eP);\n        const n = Math.max(0, Math.min(4, t[0]));\n        t[0] = QD() + \" Agora-SDK [\".concat(tP(n), \"]:\"), this.appendLogToWaitingList(n, ...t);\n      }\n      appendLogToWaitingList(e) {\n        if (!CD(\"UPLOAD_LOG\")) return;\n        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];\n        Array.isArray(i[0]) ? i[0][0] = ZD() + \" Agora-SDK [\".concat(tP(e), \"]:\") : i[0] = ZD() + \" Agora-SDK [\".concat(tP(e), \"]:\");\n        let r = \"\";\n        i.forEach(e => {\n          \"object\" == typeof e && (e = JSON.stringify(e)), r += \"\".concat(e, \" \");\n        }), this.uploadLogWaitingList.push({\n          payload_str: r,\n          log_level: e,\n          log_item_id: this.currentLogID++\n        }), \"uploading\" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n      }\n      startUpload() {\n        this.uploadState = \"uploading\", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n      }\n      async uploadLogs() {\n        const e = this.uploadLogUploadingList,\n          t = {\n            sdk_version: hD,\n            process_id: CD(\"PROCESS_ID\"),\n            payload: JSON.stringify(e)\n          };\n        return UN(async () => {\n          const e = await Tw.post(this.url || (this.proxyServerURL ? \"https://\".concat(this.proxyServerURL, \"/ls/?h=\").concat(CD(\"LOG_UPLOAD_SERVER\"), \"&p=443&d=upload/v1\") : \"https://\".concat(CD(\"LOG_UPLOAD_SERVER\"), \"/upload/v1\")), t, {\n            responseType: \"text\"\n          });\n          if (\"OK\" !== e.data) {\n            const t = new Error(\"unexpected upload log response\");\n            throw t.response = e, t;\n          }\n        }, () => (this.uploadLogUploadingList = [], !1), t => {\n          const i = {\n            status: -1,\n            message: t.message,\n            errorRange: e.map(e => e.log_item_id)\n          };\n          return t.response ? (i.status = t.response.status, i.data = t.response.data, i.headers = t.response.headers) : t.request && (i.status = t.request.status), XD.reportLogUploadError(i), !0;\n        }, {\n          timeout: CD(\"UPLOAD_LOG_REQUEST_RETRY_INTERVAL\"),\n          maxRetryTimeout: CD(\"UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL\")\n        });\n      }\n      uploadLogInterval() {\n        0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, CD(\"UPLOAD_LOG_LENGTH_EACH_TIME\"))), this.uploadLogs().then(() => {\n          this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), CD(\"UPLOAD_LOG_INTERVAL\"));\n        }).catch(e => {\n          this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), CD(\"UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1\")) : window.setTimeout(() => this.uploadLogInterval(), CD(\"UPLOAD_LOG_RETRY_INTERVAL_V1\"));\n        }));\n      }\n    }();\n    var nP;\n    function rP(e) {\n      return SO(e.reportId, \"params.reportId\", 0, 100, !1), SO(e.category, \"params.category\", 0, 100, !1), SO(e.event, \"params.event\", 0, 100, !1), SO(e.label, \"params.label\", 0, 100, !1), mO(e.value, \"params.value\", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, !1), !0;\n    }\n    (nP = {}).FREE = \"free\", nP.UPLOADING = \"uploading\", function (e) {\n      e[e.MISC = 0] = \"MISC\", e[e.INTERNAL_EVENT = 1] = \"INTERNAL_EVENT\", e[e.PUBLIC_EVENT = 2] = \"PUBLIC_EVENT\", e[e.WEB_EVENT = 3] = \"WEB_EVENT\", e[e.INTERNAL_API = 4] = \"INTERNAL_API\", e[e.WEB_API = 5] = \"WEB_API\", e[e.PUBLIC_API = 6] = \"PUBLIC_API\";\n    }({});\n    const oP = {\n      sid: \"\",\n      lts: 0,\n      success: null,\n      cname: null,\n      uid: null,\n      peer: null,\n      cid: null,\n      elapse: null,\n      extend: null,\n      vid: 0\n    };\n    let sP = function (e) {\n        return e.PUBLISH = \"publish\", e.SUBSCRIBE = \"subscribe\", e.WS_COMPRESSOR_INIT = \"ws_compressor_init\", e.SESSION_INIT = \"session_init\", e.JOIN_CHOOSE_SERVER = \"join_choose_server\", e.RTE_DETAIL = \"rte_detail_stats\", e.REQ_USER_ACCOUNT = \"req_user_account\", e.JOIN_GATEWAY = \"join_gateway\", e.REJOIN_GATEWAY = \"rejoin_gateway\", e.STREAM_SWITCH = \"stream_switch\", e.REQUEST_PROXY_WORKER_MANAGER = \"request_proxy_worker_manager\", e.REQUEST_PROXY_APPCENTER = \"request_proxy_appcenter\", e.FIRST_VIDEO_RECEIVED = \"first_video_received\", e.FIRST_AUDIO_RECEIVED = \"first_audio_received\", e.FIRST_VIDEO_DECODE = \"first_video_decode\", e.FIRST_AUDIO_DECODE = \"first_audio_decode\", e.XLA_PEER_FIRST_VIDEO_FRAME = \"xla_peer_first_video_frame\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_UPDATE_STREAM = \"on_update_stream\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.USER_ANALYTICS = \"req_user_analytics\", e.PC_STATS = \"pc_stats\", e.UPDATE_REMOTE_RTPCAPABILITIES = \"update_remote_rtpCapabilities\", e.AB_TEST = \"ab_test\", e;\n      }({}),\n      aP = function (e) {\n        return e.SESSION = \"io.agora.pb.Wrtc.Session\", e.JOIN_CHOOSE_SERVER = \"io.agora.pb.Wrtc.JoinChooseServer\", e.RTE_DETAIL = \"io.agora.pb.Wrtc.RteDetailStats\", e.REQ_USER_ACCOUNT = \"io.agora.pb.Wrtc.ReqUserAccount\", e.JOIN_GATEWAY = \"io.agora.pb.Wrtc.JoinGateway\", e.RE_JOIN_GATEWAY = \"io.agora.pb.Wrtc.ReJoinGateway\", e.PUBLISH = \"io.agora.pb.Wrtc.Publish\", e.SUBSCRIBE = \"io.agora.pb.Wrtc.Subscribe\", e.WS_COMPRESSOR_INIT = \"io.agora.pb.Wrtc.WsCompressorInit\", e.STREAM_SWITCH = \"io.agora.pb.Wrtc.StreamSwitch\", e.AUDIO_SENDING_STOPPED = \"io.agora.pb.Wrtc.AudioSendingStopped\", e.VIDEO_SENDING_STOPPED = \"io.agora.pb.Wrtc.VideoSendingStopped\", e.REQUEST_PROXY_APPCENTER = \"io.agora.pb.Wrtc.RequestProxyAppCenter\", e.REQUEST_PROXY_WORKER_MANAGER = \"io.agora.pb.Wrtc.RequestProxyWorkerManager\", e.API_INVOKE = \"io.agora.pb.Wrtc.ApiInvoke\", e.FIRST_VIDEO_RECEIVED = \"io.agora.pb.Wrtc.FirstVideoReceived\", e.FIRST_AUDIO_RECEIVED = \"io.agora.pb.Wrtc.FirstAudioReceived\", e.FIRST_VIDEO_DECODE = \"io.agora.pb.Wrtc.FirstVideoDecode\", e.FIRST_AUDIO_DECODE = \"io.agora.pb.Wrtc.FirstAudioDecode\", e.XLA_PEER_FIRST_VIDEO_FRAME = \"io.agora.pb.Wrtc.XLAPeerFirstVideoFrame\", e.ON_ADD_AUDIO_STREAM = \"io.agora.pb.Wrtc.OnAddAudioStream\", e.ON_ADD_VIDEO_STREAM = \"io.agora.pb.Wrtc.OnAddVideoStream\", e.ON_UPDATE_STREAM = \"io.agora.pb.Wrtc.OnUpdateStream\", e.ON_REMOVE_STREAM = \"io.agora.pb.Wrtc.OnRemoveStream\", e.JOIN_CHANNEL_TIMEOUT = \"io.agora.pb.Wrtc.JoinChannelTimeout\", e.PEER_PUBLISH_STATUS = \"io.agora.pb.Wrtc.PeerPublishStatus\", e.WORKER_EVENT = \"io.agora.pb.Wrtc.WorkerEvent\", e.AP_WORKER_EVENT = \"io.agora.pb.Wrtc.APWorkerEvent\", e.JOIN_WEB_PROXY_AP = \"io.agora.pb.Wrtc.JoinWebProxyAP\", e.WEBSOCKET_QUIT = \"io.agora.pb.Wrtc.WebSocketQuit\", e.USER_ANALYTICS = \"io.agora.pb.Wrtc.UserAnalytics\", e.AUTOPLAY_FAILED = \"io.agora.pb.Wrtc.AutoplayFailed\", e.PC_STATS = \"io.agora.pb.Wrtc.PCStats\", e.UPDATE_REMOTE_RTPCAPABILITIES = \"io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities\", e.AB_TEST = \"io.agora.pb.Wrtc.ABTest\", e;\n      }({});\n    !function (e) {\n      e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\";\n    }({});\n    let cP = function (e) {\n      return e[e.SESSION = 26] = \"SESSION\", e[e.JOIN_CHOOSE_SERVER = 27] = \"JOIN_CHOOSE_SERVER\", e[e.REQ_USER_ACCOUNT = 196] = \"REQ_USER_ACCOUNT\", e[e.JOIN_GATEWAY = 28] = \"JOIN_GATEWAY\", e[e.PUBLISH = 30] = \"PUBLISH\", e[e.SUBSCRIBE = 29] = \"SUBSCRIBE\", e[e.WS_COMPRESSOR_INIT = 9430] = \"WS_COMPRESSOR_INIT\", e[e.STREAM_SWITCH = 32] = \"STREAM_SWITCH\", e[e.AUDIO_SENDING_STOPPED = 33] = \"AUDIO_SENDING_STOPPED\", e[e.VIDEO_SENDING_STOPPED = 34] = \"VIDEO_SENDING_STOPPED\", e[e.REQUEST_PROXY_APPCENTER = 35] = \"REQUEST_PROXY_APPCENTER\", e[e.REQUEST_PROXY_WORKER_MANAGER = 36] = \"REQUEST_PROXY_WORKER_MANAGER\", e[e.API_INVOKE = 41] = \"API_INVOKE\", e[e.FIRST_VIDEO_RECEIVED = 348] = \"FIRST_VIDEO_RECEIVED\", e[e.FIRST_AUDIO_RECEIVED = 349] = \"FIRST_AUDIO_RECEIVED\", e[e.FIRST_VIDEO_DECODE = 350] = \"FIRST_VIDEO_DECODE\", e[e.FIRST_AUDIO_DECODE = 351] = \"FIRST_AUDIO_DECODE\", e[e.ON_ADD_AUDIO_STREAM = 352] = \"ON_ADD_AUDIO_STREAM\", e[e.ON_ADD_VIDEO_STREAM = 353] = \"ON_ADD_VIDEO_STREAM\", e[e.ON_UPDATE_STREAM = 356] = \"ON_UPDATE_STREAM\", e[e.ON_REMOVE_STREAM = 355] = \"ON_REMOVE_STREAM\", e[e.JOIN_CHANNEL_TIMEOUT = 407] = \"JOIN_CHANNEL_TIMEOUT\", e[e.PEER_PUBLISH_STATUS = 408] = \"PEER_PUBLISH_STATUS\", e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\", e[e.JOIN_WEB_PROXY_AP = 700] = \"JOIN_WEB_PROXY_AP\", e[e.WEBSOCKET_QUIT = 671] = \"WEBSOCKET_QUIT\", e[e.USER_ANALYTICS = 1e4] = \"USER_ANALYTICS\", e[e.AUTOPLAY_FAILED = 9178] = \"AUTOPLAY_FAILED\", e;\n    }({});\n    function dP() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      return function (t, i, n) {\n        const r = n.value;\n        if (\"function\" == typeof r) {\n          const o = e.className || t.__className__ || (\"AgoraRTCClient\" === t.constructor.name ? \"Client\" : t.constructor.name);\n          n.value = function () {\n            for (var t, n = arguments.length, s = new Array(n), a = 0; a < n; a++) s[a] = arguments[a];\n            let c = s;\n            if (e.argsMap) try {\n              c = e.argsMap(this, ...s);\n            } catch (e) {\n              iP.warning(e), c = [];\n            }\n            try {\n              JSON.stringify(c);\n            } catch (e) {\n              iP.warning(\"arguments for method \".concat(o, \".\").concat(String(i), \" not serializable for apiInvoke.\")), c = [];\n            }\n            const d = (e.report || lP).reportApiInvoke(this._sessionId || null, {\n              id: this._clientId || (null === (t = this.store) || void 0 === t ? void 0 : t.clientId) || this._ID,\n              name: \"\".concat(o, \".\").concat(String(i)),\n              options: c,\n              tag: kO.TRACER,\n              reportResult: e.reportResult\n            }, e.throttleTime);\n            try {\n              const t = r.apply(this, s);\n              return t instanceof rp ? t.then(t => (d.onSuccess(e.reportResult && t), t)).catch(e => {\n                throw d.onError(e), e;\n              }) : (d.onSuccess(e.reportResult && t), t);\n            } catch (e) {\n              throw d.onError(e), e;\n            }\n          };\n        }\n        return n;\n      };\n    }\n    const lP = new class {\n      constructor() {\n        HD(this, \"baseInfoMap\", new Map()), HD(this, \"proxyServer\", void 0), HD(this, \"eventUploadTimer\", void 0), HD(this, \"setSessionIdTimer\", void 0), HD(this, \"url\", void 0), HD(this, \"sids\", new Set()), HD(this, \"backupUrl\", void 0), HD(this, \"_appId\", void 0), HD(this, \"_aid\", 0), HD(this, \"keyEventUploadPendingItems\", []), HD(this, \"normalEventUploadPendingItems\", []), HD(this, \"apiInvokeUploadPendingItems\", []), HD(this, \"apiInvokeCount\", 0), HD(this, \"apiInvokeLoggedCount\", 0), HD(this, \"ltsList\", []), HD(this, \"lastSendNormalEventTime\", Date.now()), HD(this, \"customReportCounterTimer\", void 0), HD(this, \"customReportCount\", 0), HD(this, \"extApiInvoke\", async e => {\n          for (const t of e) {\n            const e = YD(YD({}, t), {}, {\n              sid: null,\n              invokeId: ++this.apiInvokeCount,\n              tag: kO.TRACER\n            });\n            this.sendApiInvoke(e);\n          }\n        }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), CD(\"EVENT_REPORT_SEND_INTERVAL\")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), CD(\"EVENT_REPORT_SEND_INTERVAL\"));\n      }\n      getBaseInfoBySessionId(e) {\n        return this.baseInfoMap.get(e);\n      }\n      setAppId(e) {\n        this._appId = e, this._aid = parseInt(e.replace(/[a-fA-F0-9]{8}/g, e => {\n          let [t, i] = e;\n          return t + i;\n        }), 16) || 0;\n      }\n      reportApiInvoke(e, t, i) {\n        t.timeout = t.timeout || 6e4, t.reportResult = void 0 === t.reportResult || t.reportResult;\n        const n = Date.now();\n        this.apiInvokeCount += 1;\n        const r = this.apiInvokeCount,\n          o = !!CD(\"SHOW_REPORT_INVOKER_LOG\"),\n          s = !!CD(\"SHOW_REPORT_USER_INVOKER_LOG\"),\n          a = o || s && t.id;\n        a && (this.apiInvokeLoggedCount += 1);\n        const c = this.apiInvokeLoggedCount;\n        function d(e, i) {\n          if (a) {\n            let n = \"[apiInvoke-\".concat(c, \"]\");\n            if (t.id && (n += \"[\".concat(t.id, \"]\")), t.name && (n += \"[\".concat(t.name, \"]\"), t.name === LO.JOIN)) return iP.info(\"\".concat(n, \" \").concat(e));\n            iP.info(\"\".concat(n, \" \").concat(e), \"start\" === e ? t.options : i || \"\");\n          }\n        }\n        const l = () => ({\n          tag: t.tag,\n          invokeId: r,\n          sid: e,\n          name: t.name,\n          apiInvokeTime: n,\n          options: t.options,\n          states: t.states || null\n        });\n        d(\"start\");\n        let u = !1;\n        fN(t.timeout).then(() => {\n          u || (this.sendApiInvoke(YD(YD({}, l()), {}, {\n            error: hO.API_INVOKE_TIMEOUT,\n            success: !1\n          })), d(\"timeout\"));\n        });\n        const h = new pO(hO.UNEXPECTED_ERROR, \"\".concat(t.name, \": this api invoke is end\"));\n        return {\n          onSuccess: e => {\n            const n = () => {\n              if (u) throw h;\n              return u = !0, this.sendApiInvoke(YD(YD({}, l()), {}, {\n                success: !0\n              }, t.reportResult && {\n                result: e\n              })), d(\"onSuccess\"), e;\n            };\n            return i ? CN(n, t.name + \"Success\", i, () => u = !0) : n();\n          },\n          onError: e => {\n            const n = () => {\n              if (u) throw e;\n              u = !0, this.sendApiInvoke(YD(YD({}, l()), {}, {\n                success: !1,\n                error: e\n              })), d(\"onFailure\", e.toString());\n            };\n            return i ? CN(n, t.name + \"Error\", i, () => u = !0) : n();\n          }\n        };\n      }\n      _send(e, t, i) {\n        this.send({\n          type: e,\n          data: t\n        }, i);\n      }\n      _sendApiInvoke(e) {\n        return this.sendApiInvoke(e);\n      }\n      sessionInit(e, t) {\n        if (this.baseInfoMap.has(e)) return;\n        const i = Date.now(),\n          n = this.createBaseInfo(e, i);\n        n.cname = t.cname, n.rteUrl = t.rteUrl;\n        const r = Object.assign({}, {\n            willUploadConsoleLog: CD(\"UPLOAD_LOG\"),\n            maxTouchPoints: navigator.maxTouchPoints,\n            areaVersion: pD ? \"global\" : \"oversea\",\n            areas: CD(\"AREAS\") && CD(\"AREAS\").join(\",\")\n          }, t.extend),\n          {\n            stringUid: o,\n            channelProfile: s,\n            channelMode: a,\n            isABTestSuccess: c,\n            lsid: d,\n            clientRole: l\n          } = t,\n          u = Date.now(),\n          h = YD(YD({}, n), {}, {\n            eventType: sP.SESSION_INIT,\n            appid: t.appid,\n            browser: navigator.userAgent,\n            buildFormat: t.buildFormat,\n            build: SD,\n            lts: u,\n            elapse: u - i,\n            extend: JSON.stringify(r),\n            mode: t.mode,\n            process: CD(\"PROCESS_ID\"),\n            appType: CD(\"APP_TYPE\"),\n            success: !0,\n            version: hD,\n            stringUid: o,\n            channelProfile: s,\n            channelMode: a,\n            isABTestSuccess: c,\n            lsid: d,\n            clientType: Ln(p = window.navigator.userAgent).call(p, \"AgoraWebView\") ? 42 : 20,\n            clientRole: l,\n            serviceId: CD(\"PROCESS_ID\"),\n            extensionID: CD(\"PLUGIN_INFO\").join(\",\") || \"\",\n            rteUrl: t.rteUrl,\n            rteSid: t.rteSid\n          });\n        var p;\n        this.send({\n          type: aP.SESSION,\n          data: h\n        }, !0);\n      }\n      reportRteDetail(e) {\n        const t = this.baseInfoMap.get(e);\n        if (!t) return;\n        const i = t.info,\n          n = Date.now(),\n          r = YD(YD({}, i), {}, {\n            eventType: sP.RTE_DETAIL,\n            lts: n,\n            success: !0,\n            elapse: n - t.startTime,\n            vid: void 0 === i.vid ? 0 : Number(i.vid),\n            ua: navigator.userAgent\n          });\n        this.send({\n          type: aP.RTE_DETAIL,\n          data: r\n        }, !0);\n      }\n      joinChooseServer(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info;\n        t.vid && (n.vid = t.vid);\n        const r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            role: t.role,\n            eventType: sP.JOIN_CHOOSE_SERVER,\n            lts: r,\n            eventElapse: t.elapse || r - t.lts,\n            chooseServerAddr: t.csAddr,\n            errorCode: t.ec,\n            elapse: r - i.startTime,\n            success: t.succ,\n            chooseServerAddrList: JSON.stringify(t.serverList),\n            uid: t.uid ? parseInt(t.uid) : null,\n            cid: t.cid ? parseInt(t.cid) : null,\n            chooseServerIp: t.csIp || \"\",\n            opid: t.opid,\n            unilbsServerIds: t.unilbsServerIds,\n            extend: t.extend || void 0,\n            isHttp3: t.isHttp3,\n            corssRegionTagReq: t.corssRegionTagReq || void 0,\n            corssRegionTagRes: t.corssRegionTagRes || void 0,\n            ua: navigator.userAgent,\n            resourceTimingInfo: t.resourceTimingInfo || void 0\n          });\n        this.send({\n          type: aP.JOIN_CHOOSE_SERVER,\n          data: o\n        }, !0);\n      }\n      reqUserAccount(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            eventType: sP.REQ_USER_ACCOUNT,\n            lts: r,\n            success: t.success,\n            serverAddress: t.serverAddr,\n            stringUid: t.stringUid,\n            uid: t.uid,\n            errorCode: t.errorCode,\n            elapse: t.elapse || r - i.startTime,\n            eventElapse: r - t.lts,\n            extend: JSON.stringify(t.extend)\n          });\n        this.send({\n          type: aP.REQ_USER_ACCOUNT,\n          data: o\n        }, !0);\n      }\n      joinGateway(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info;\n        t.vid && (n.vid = t.vid), n.uid = t.uid, n.cid = t.cid;\n        const r = Date.now(),\n          {\n            firstSuccess: o,\n            addr: s,\n            isProxy: a\n          } = t,\n          c = r - i.startTime,\n          d = YD(YD({}, n), {}, {\n            eventType: sP.JOIN_GATEWAY,\n            lts: r,\n            gatewayAddr: t.addr,\n            success: t.succ,\n            errorCode: t.ec,\n            errorMsg: t.errorMsg || \"\",\n            elapse: c,\n            eventElapse: r - t.lts,\n            firstSuccess: o,\n            signalChannel: t.signalChannel,\n            preload: t.preload ? 1 : 0,\n            installId: uD(),\n            isABTestSuccess: t.isABTestSuccess ? 1 : 0,\n            gatewayIp: null,\n            gatewayPort: null,\n            isProxy: a ? 1 : 0\n          }),\n          l = d.success ? 1 : 0;\n        if (t.succ && (i.lastJoinSuccessTime = r), s) if (\"1\" === d.signalChannel) {\n          const e = qD(/(\\d+\\.\\d+\\.\\d+\\.\\d+):(\\d+)/, {\n              ip: 1,\n              port: 2\n            }),\n            t = s.match(e);\n          d.gatewayIp = t && t.groups ? t.groups.ip : \"\", d.gatewayPort = t && t.groups ? t.groups.port : \"\";\n        } else if (a) {\n          const e = s.match(/h=(\\d{1,3}-){3}\\d{1,3}/g),\n            t = s.match(/p=[0-9]{1,6}/g);\n          d.gatewayIp = e && e.length ? e[0].split(\"=\")[1].replace(/-/g, \".\") : \"\", d.gatewayPort = t && t.length ? t[0].split(\"=\")[1] : \"\";\n        } else {\n          const e = s.match(/wss:\\/\\/(\\d{1,3}-){3}\\d{1,3}/g),\n            t = s.match(/(:|p=)[0-9]{1,6}/g);\n          d.gatewayIp = e && e.length ? e[0].split(\"//\")[1].replace(/-/g, \".\") : \"\", d.gatewayPort = t && t.length ? t[0].split(/:|p=/g)[1] : \"\";\n        }\n        if (o) this.send({\n          type: aP.JOIN_GATEWAY,\n          data: d\n        }, !0);else {\n          let e = {\n            isSuccess: l,\n            port: d.gatewayPort\n          };\n          delete d.success, delete d.eventType, delete d.firstSuccess, delete d.gatewayPort, d.vid = Number(d.vid);\n          const t = Object.assign({}, d, e, {\n            eventType: sP.REJOIN_GATEWAY\n          });\n          this.send({\n            type: aP.RE_JOIN_GATEWAY,\n            data: t\n          }, !0);\n        }\n      }\n      joinChannelTimeout(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = Date.now(),\n          r = YD(YD({}, i.info), {}, {\n            lts: n,\n            timeout: t,\n            elapse: n - i.startTime\n          });\n        this.send({\n          type: aP.JOIN_CHANNEL_TIMEOUT,\n          data: r\n        }, !0);\n      }\n      publish(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            eventType: sP.PUBLISH,\n            lts: r,\n            eventElapse: t.eventElapse,\n            elapse: r - i.startTime,\n            success: t.succ,\n            errorCode: t.ec,\n            videoName: t.videoName,\n            audioName: t.audioName,\n            screenName: t.screenName,\n            screenshare: t.screenshare,\n            audio: t.audio,\n            video: t.video,\n            p2pid: t.p2pid,\n            publishRequestid: t.publishRequestid\n          });\n        this.send({\n          type: aP.PUBLISH,\n          data: o\n        }, !0);\n      }\n      subscribe(e, t, i) {\n        const n = this.baseInfoMap.get(e);\n        if (!n) return;\n        const r = n.info,\n          o = Date.now(),\n          s = YD(YD({}, r), {}, {\n            eventType: sP.SUBSCRIBE,\n            lts: o,\n            eventElapse: t.eventElapse,\n            elapse: o - n.startTime,\n            success: t.succ,\n            errorCode: t.ec,\n            video: t.video,\n            audio: t.audio,\n            subscribeRequestid: t.subscribeRequestid,\n            p2pid: t.p2pid,\n            preSsrc: t.preSsrc ? 1 : 0\n          }, i && {\n            extend: JSON.stringify({\n              isMassSubscribe: !0\n            })\n          });\n        \"string\" == typeof t.peerid ? s.peerSuid = t.peerid : s.peer = t.peerid, this.send({\n          type: aP.SUBSCRIBE,\n          data: s\n        }, !0);\n      }\n      wsCompressorInit(e) {\n        var t;\n        const i = [...WD(t = this.baseInfoMap).call(t)],\n          n = i.length ? i[0] : \"UnableToGetSid\",\n          r = this.baseInfoMap.get(n);\n        if (!r) return;\n        const o = r.info,\n          s = Date.now(),\n          a = YD(YD({}, o), {}, {\n            eventType: sP.WS_COMPRESSOR_INIT,\n            lts: s,\n            eventElapse: e.eventElapse,\n            elapse: s - r.startTime,\n            status: e.status ? 1 : 2\n          });\n        this.send({\n          type: aP.WS_COMPRESSOR_INIT,\n          data: a\n        }, !0);\n      }\n      firstXLAPeerFirstVideoFrame(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = t.peerPubStatusMs - (i.lastJoinSuccessTime || r),\n          s = YD(YD({}, n), {}, {\n            elapse: r - i.startTime,\n            eventType: sP.XLA_PEER_FIRST_VIDEO_FRAME,\n            lts: r,\n            peer: t.peer,\n            width: t.width,\n            height: t.height,\n            ssrc: t.ssrc,\n            p2pid: t.p2pid,\n            peerPublishDuration: t.peerPublishDuration,\n            joinChannelSuccessElapse: o,\n            peerPubStatusMs: t.peerPubStatusMs - t.joinChannelStart,\n            availablePublish: t.peerPublishDuration > o ? 1 : 0,\n            preloadStart: Math.max(t.preloadStart - t.joinChannelStart, 0),\n            preloadEnd: Math.max(t.preloadEnd - t.joinChannelStart, 0),\n            encrypt: Math.max(t.apStart - t.joinChannelStart, 0),\n            ap: Math.max(t.apEnd - t.joinChannelStart, 0),\n            sua: Math.max(t.suaEnd - t.joinChannelStart, 0),\n            beforeConnect: Math.max(t.beforeConnect - t.joinChannelStart, 0),\n            peerRecevier: Math.max(t.peerReceiver - t.joinChannelStart, 0),\n            ice: Math.max(t.ice - t.joinChannelStart, 0),\n            pc: Math.max(t.pc - t.joinChannelStart, 0),\n            signalConnected: Math.max(t.signalConnected - t.joinChannelStart, 0),\n            joinReq: Math.max(t.joinReq - t.joinChannelStart, 0),\n            joinRes: Math.max(t.joinRes - t.joinChannelStart, 0),\n            userJoinNotify: Math.max(t.userJoinNotify - t.joinChannelStart, 0),\n            videoSsrcNotify: Math.max(t.videoAddNotify - t.joinChannelStart, 0),\n            subscribeDelayMs: Math.max(t.subscribeStart - t.videoAddNotify, 0),\n            subscribeStart: Math.max(t.subscribeStart - t.joinChannelStart, 0),\n            subscribeEnd: Math.max(t.subscribeEnd - t.joinChannelStart, 0),\n            firstReceived: Math.max(t.firstReceived - t.joinChannelStart, 0),\n            firstDecoded: Math.max(t.firstDecoded - t.joinChannelStart, 0),\n            firstPreRender: Math.max(t.firstPreRender - t.joinChannelStart, 0),\n            firstRender: Math.max(t.firstRender - t.joinChannelStart, 0),\n            playDelayMs: Math.max(t.playStart - t.subscribeEnd, 0),\n            playStart: Math.max(t.playStart - t.joinChannelStart, 0),\n            playEnd: Math.max(t.playEnd - t.joinChannelStart, 0),\n            isPreSub: t.isPreSub ? 1 : 0,\n            isPrePc: t.isPrePc ? 1 : 0,\n            isPreInstantVideo: t.isPreInstantVideo ? 1 : 0,\n            firstReceivedEncodedFrame: t.firstReceivedEncodedFrame ? Math.max(t.firstReceivedEncodedFrame - t.joinChannelStart, 0) : void 0,\n            frameType: t.frameType || \"\",\n            rtpTimestamp: t.rtpTimestamp || 0,\n            framePayloadType: t.framePayloadType || 0,\n            frameDataLength: t.frameDataLength || 0,\n            mimeType: t.mimeType || \"\"\n          });\n        this.send({\n          type: aP.XLA_PEER_FIRST_VIDEO_FRAME,\n          data: s\n        }, !0);\n      }\n      firstRemoteVideoDecode(e, t, i, n) {\n        const r = this.baseInfoMap.get(e);\n        if (!r) return;\n        const o = r.info,\n          s = Date.now(),\n          a = YD(YD(YD({}, o), n), {}, {\n            elapse: s - r.startTime,\n            eventType: t,\n            lts: s,\n            firstDecodeFrame: Math.max((n.firstFrame || s) - r.startTime, 0),\n            apEnd: Math.max(n.apEnd - r.startTime, 0),\n            apStart: Math.max(n.apStart - r.startTime, 0),\n            joinGwEnd: Math.max(n.joinGwEnd - r.startTime, 0),\n            joinGwStart: Math.max(n.joinGwStart - r.startTime, 0),\n            pcEnd: Math.max(n.pcEnd - r.startTime, 0),\n            pcStart: Math.max(n.pcStart - r.startTime, 0),\n            subscriberEnd: Math.max(n.subscriberEnd - r.startTime, 0),\n            subscriberStart: Math.max(n.subscriberStart - r.startTime, 0),\n            videoAddNotify: Math.max(n.videoAddNotify - r.startTime, 0)\n          });\n        this.send({\n          type: i,\n          data: a\n        }, !0);\n      }\n      firstRemoteFrame(e, t, i, n) {\n        const r = this.baseInfoMap.get(e);\n        if (!r) return;\n        const o = r.info,\n          s = Date.now(),\n          a = YD(YD(YD({}, o), n), {}, {\n            elapse: s - r.startTime,\n            eventType: t,\n            lts: s\n          });\n        this.send({\n          type: i,\n          data: a\n        }, !0);\n      }\n      abTest(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD(YD({}, n), t), {}, {\n            vid: void 0 === n.vid ? 0 : Number(n.vid),\n            elapse: r - i.startTime,\n            eventType: sP.AB_TEST,\n            lts: r\n          });\n        this.send({\n          type: aP.AB_TEST,\n          data: o\n        }, !0);\n      }\n      pcStats(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD(YD({}, n), t), {}, {\n            vid: void 0 === n.vid ? 0 : Number(n.vid),\n            elapse: r - i.startTime,\n            eventType: sP.PC_STATS,\n            lts: r,\n            preallocation: t.preallocation ? 1 : 0\n          });\n        this.send({\n          type: aP.PC_STATS,\n          data: o\n        }, !0);\n      }\n      updateRemoteRTPCapabilities(e, t) {\n        if (e) {\n          const i = this.baseInfoMap.get(e);\n          if (!i) return;\n          const n = i.info,\n            r = Date.now(),\n            o = YD(YD(YD({}, n), t), {}, {\n              vid: void 0 === n.vid ? 0 : Number(n.vid),\n              eventType: sP.UPDATE_REMOTE_RTPCAPABILITIES,\n              lts: r\n            });\n          this.send({\n            type: aP.UPDATE_REMOTE_RTPCAPABILITIES,\n            data: o\n          }, !0);\n        }\n      }\n      onGatewayStream(e, t, i, n) {\n        const r = this.baseInfoMap.get(e);\n        if (!r) return;\n        const o = r.info,\n          s = Date.now(),\n          a = YD(YD(YD({}, o), n), {}, {\n            eventType: t,\n            lts: s\n          });\n        this.send({\n          type: i,\n          data: a\n        }, !0);\n      }\n      streamSwitch(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            eventType: sP.STREAM_SWITCH,\n            lts: r,\n            isDual: t.isdual,\n            elapse: r - i.startTime,\n            success: t.succ\n          });\n        this.send({\n          type: aP.STREAM_SWITCH,\n          data: o\n        }, !0);\n      }\n      requestProxyAppCenter(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            eventType: sP.REQUEST_PROXY_APPCENTER,\n            lts: r,\n            eventElapse: r - t.lts,\n            elapse: r - i.startTime,\n            APAddr: t.APAddr,\n            workerManagerList: t.workerManagerList,\n            response: t.response,\n            errorCode: t.ec,\n            success: t.succ\n          });\n        this.send({\n          type: aP.REQUEST_PROXY_APPCENTER,\n          data: o\n        }, !0);\n      }\n      requestProxyWorkerManager(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            eventType: sP.REQUEST_PROXY_WORKER_MANAGER,\n            lts: r,\n            eventElapse: r - t.lts,\n            elapse: r - i.startTime,\n            workerManagerAddr: t.workerManagerAddr,\n            response: t.response,\n            errorCode: t.ec,\n            success: t.succ\n          });\n        this.send({\n          type: aP.REQUEST_PROXY_WORKER_MANAGER,\n          data: o\n        }, !0);\n      }\n      setProxyServer(e) {\n        this.proxyServer = e, e ? iP.debug(\"reportProxyServerurl: \".concat(e)) : iP.debug(\"disable reportProxyServerurl: \".concat(e));\n      }\n      peerPublishStatus(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD({}, n), {}, {\n            subscribeElapse: t.subscribeElapse,\n            peer: t.peer,\n            peerPublishDuration: Math.max(t.audioPublishDuration, t.videoPublishDuration),\n            audiotag: t.audioPublishDuration > 0 ? 1 : -1,\n            videotag: t.videoPublishDuration > 0 ? 1 : -1,\n            lts: r,\n            elapse: r - i.startTime,\n            joinChannelSuccessElapse: r - (i.lastJoinSuccessTime || r),\n            peerPublishDurationVideo: t.videoPublishDuration,\n            peerPublishDurationAudio: t.audioPublishDuration\n          });\n        this.send({\n          type: aP.PEER_PUBLISH_STATUS,\n          data: o\n        }, !0);\n      }\n      workerEvent(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now();\n        (function (e, t, i) {\n          const n = e[t];\n          if (!n || \"string\" != typeof n) return [e];\n          e[t] = \"\";\n          const r = _N(JSON.stringify(e));\n          let o = 0;\n          const s = [];\n          let a = 0;\n          for (let c = 0; c < n.length; c++) a += n.charCodeAt(c) <= 127 ? 1 : 3, a <= i - r || (s[s.length] = uO(uO({}, e), {}, {\n            [t]: n.substring(o, c)\n          }), o = c, a = n.charCodeAt(c) <= 127 ? 1 : 3);\n          return o !== n.length - 1 && (s[s.length] = uO(uO({}, e), {}, {\n            [t]: n.substring(o)\n          })), s;\n        })(YD(YD(YD({}, n), t), {}, {\n          elapse: r - i.startTime,\n          lts: r,\n          productType: \"WebRTC\"\n        }), \"payload\", 1300).forEach(e => this.send({\n          type: aP.WORKER_EVENT,\n          data: e\n        }, !0));\n      }\n      apworkerEvent(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD(YD({}, n), t), {}, {\n            elapse: r - i.startTime,\n            lts: r\n          });\n        this.send({\n          type: aP.AP_WORKER_EVENT,\n          data: o\n        }, !0);\n      }\n      joinWebProxyAP(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD(YD({}, n), t), {}, {\n            elapse: r - i.startTime,\n            lts: r,\n            extend: t.extend || void 0\n          });\n        this.send({\n          type: aP.JOIN_WEB_PROXY_AP,\n          data: o\n        }, !0);\n      }\n      WebSocketQuit(e, t) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = YD(YD(YD({}, n), t), {}, {\n            elapse: r - i.startTime,\n            lts: r\n          });\n        this.send({\n          type: aP.WEBSOCKET_QUIT,\n          data: o\n        }, !0);\n      }\n      async sendCustomReportMessage(e, t) {\n        if (this.customReportCount += t.length, this.customReportCount > CD(\"CUSTOM_REPORT_LIMIT\")) throw new pO(hO.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);\n        this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {\n          this.customReportCount = 0;\n        }, 5e3));\n        const i = Date.now(),\n          n = t.map(t => ({\n            type: aP.USER_ANALYTICS,\n            data: YD(YD({\n              sid: e\n            }, t), {}, {\n              lts: i\n            })\n          }));\n        try {\n          CD(\"NEW_REPORT_SERVER\") ? await this.postDataToStatsCollector2(n) : await this.postDataToStatsCollector(n);\n        } catch (e) {\n          throw iP.error(\"send custom report message failed\", e.toString()), new pO(hO.CUSTOM_REPORT_SEND_FAILED, e.message);\n        }\n      }\n      sendApiInvoke(e) {\n        const t = CD(\"NOT_REPORT_EVENT\");\n        if (e.tag && Ln(t) && Ln(t).call(t, e.tag)) return !1;\n        if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1;\n        const i = this.baseInfoMap.get(e.sid);\n        if (!i) return this.apiInvokeUploadPendingItems.push(e), !1;\n        const {\n          cname: n,\n          uid: r,\n          cid: o\n        } = i.info;\n        let s;\n        if (e.lts = e.lts || Date.now(), e.error) if (e.error instanceof pO) {\n          const {\n            code: t,\n            message: i\n          } = e.error;\n          s = t || i || e.error.toString();\n        } else s = e.error.toString();\n        const a = {\n          invokeId: e.invokeId,\n          sid: e.sid,\n          cname: n,\n          cid: o,\n          uid: r,\n          lts: e.lts,\n          success: e.success,\n          elapse: e.lts - i.startTime,\n          execElapse: e.lts - e.apiInvokeTime,\n          apiName: e.name,\n          options: e.options ? JSON.stringify(e.options) : void 0,\n          execStates: e.states ? JSON.stringify(e.states) : void 0,\n          execResult: e.result ? JSON.stringify(e.result) : void 0,\n          errorCode: e.error ? s : void 0,\n          errorMsg: e.error ? JSON.stringify(e.error) : void 0\n        };\n        return this.send({\n          type: aP.API_INVOKE,\n          data: a\n        }, !1), !0;\n      }\n      addSid(e) {\n        this.sids.add(e);\n      }\n      removeSid(e) {\n        this.sids.delete(e);\n      }\n      appendSessionId() {\n        const e = this.apiInvokeUploadPendingItems;\n        if (0 === e.length) return;\n        const t = Array.from(this.sids).find(e => null !== e);\n        t && e.forEach(e => {\n          e && (e.sid = t, this.sendApiInvoke(Object.assign({}, e)));\n        }), e.length = 0;\n      }\n      send(e, t) {\n        if (t) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, !0);\n        this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > CD(\"NORMAL_EVENT_QUEUE_CAPACITY\") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, !1);\n      }\n      doSend() {\n        this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, !0), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, !1);\n      }\n      sendItems(e, t) {\n        const i = [],\n          n = [];\n        for (; e.length;) {\n          const t = e.shift();\n          i.length < 20 ? i.push(t) : n.push(t);\n        }\n        e.push(...n);\n        for (const e of [...i]) {\n          var r;\n          -1 !== this.ltsList.indexOf(e.data.lts) ? (e.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e.data.lts)) : (this.ltsList.push(e.data.lts), Qp(r = this.ltsList).call(r, (e, t) => e - t));\n        }\n        return t || (this.lastSendNormalEventTime = Date.now()), CD(\"ENABLE_EVENT_REPORT\") ? (i.length && (CD(\"NEW_REPORT_SERVER\") ? this.postDataToStatsCollector2(i) : this.postDataToStatsCollector(i)).catch((e => i => {\n          CD(\"EVENT_REPORT_RETRY\") && (t ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e), this.normalEventUploadPendingItems.length > CD(\"NORMAL_EVENT_QUEUE_CAPACITY\") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - CD(\"NORMAL_EVENT_QUEUE_CAPACITY\")), iP.warning(\"report: drop normal events\"))));\n        })(i)), e) : e;\n      }\n      async postDataToStatsCollector2(e) {\n        QO.networkState === KO.OFFLINE && (await rp.race([QO.onlineWaiter, fN(2 * kN.maxRetryTimeout)]));\n        const t = e => {\n            let t = new Uint8Array();\n            return e.forEach(e => {\n              const i = bO(JSON.stringify(e.data)),\n                n = new ArrayBuffer(5),\n                r = (e => {\n                  let t = 0;\n                  return Object.entries(aP).forEach(i => {\n                    let [n, r] = i;\n                    r === e.type && (t = cP[n]);\n                  }), t;\n                })(e),\n                o = new DataView(n);\n              o.setUint16(0, i.byteLength, !0), o.setUint8(2, 255 & r), o.setUint8(3, r >>> 8 & 255), o.setUint8(4, r >>> 16 & 255), t = wO(t, new Uint8Array(n)), t = wO(t, i);\n            }), t;\n          },\n          i = \"event\";\n        let n = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(CD(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"&p=443&d=\").concat(i) : \"https://\".concat(CD(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"/\").concat(i);\n        for (let r = 0; r < 2; r += 1) {\n          1 === r && (n = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(CD(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"&p=443&d=\").concat(i) : \"https://\".concat(CD(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"/\").concat(i));\n          try {\n            await jN(n, {\n              timeout: 1e4,\n              data: t(e),\n              headers: YD(YD({\n                biz: \"webrtc\",\n                sendts: Math.round(Date.now() / 1e3),\n                debug: \"false\"\n              }, this._appId && {\n                appid: this._appId\n              }), {}, {\n                \"Content-Type\": \"application/octet-stream\"\n              })\n            }, !0);\n          } catch (e) {\n            if (1 === r) throw e;\n            continue;\n          }\n          return;\n        }\n      }\n      async postDataToStatsCollector(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        const i = (e => {\n            const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid);\n            return t && t.info.vid && +t.info.vid || 0;\n          })(e[0]),\n          n = i ? void 0 : this._aid,\n          r = {\n            msgType: \"EventMessages\",\n            sentTs: Math.round(Date.now() / 1e3),\n            payloads: e.map(e => JSON.stringify(e)),\n            vid: i,\n            aid: n\n          };\n        QO.networkState === KO.OFFLINE && (await rp.race([QO.onlineWaiter, fN(2 * kN.maxRetryTimeout)]));\n        const o = t ? \"/events/proto-raws\" : \"/events/messages\";\n        let s = this.url || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(CD(\"EVENT_REPORT_DOMAIN\"), \"&p=\").concat(CD(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(o) : \"https://\".concat(CD(\"EVENT_REPORT_DOMAIN\"), \":\").concat(CD(\"STATS_COLLECTOR_PORT\")).concat(o));\n        for (let e = 0; e < 2; e += 1) {\n          1 === e && (s = this.backupUrl || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(CD(\"EVENT_REPORT_BACKUP_DOMAIN\"), \"&p=\").concat(CD(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(o) : \"https://\".concat(CD(\"EVENT_REPORT_BACKUP_DOMAIN\"), \":\").concat(CD(\"STATS_COLLECTOR_PORT\")).concat(o)));\n          try {\n            t ? await GN(s, {\n              timeout: 1e4,\n              data: r\n            }) : await jN(s, {\n              timeout: 1e4,\n              data: r\n            });\n          } catch (t) {\n            if (1 === e) throw t;\n            continue;\n          }\n          return;\n        }\n      }\n      createBaseInfo(e, t) {\n        const i = Object.assign({}, oP);\n        return i.sid = e, this.baseInfoMap.set(e, {\n          info: i,\n          startTime: t\n        }), i;\n      }\n      reportResourceTiming(e, t) {\n        const i = performance.getEntriesByName(e),\n          n = i[i.length - 1];\n        n && this.reportApiInvoke(t, {\n          name: \"Client.resourceTiming\",\n          options: n,\n          tag: kO.TRACER\n        }).onSuccess();\n      }\n    }();\n    XD.on(\"REPORT_LOG_UPLOAD\", e => {\n      e.networkState = QO.networkState, lP.reportApiInvoke(null, {\n        name: \"logUploadError\",\n        options: e,\n        tag: kO.TRACER\n      }).onSuccess(\"logUploadError\");\n    });\n    let uP = class extends pO {\n      constructor(e) {\n        super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\", arguments.length > 2 ? arguments[2] : void 0), HD(this, \"name\", \"AgoraRTCException\");\n      }\n      print() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"error\";\n        return super.print(e, iP);\n      }\n      throw() {\n        super.throw(iP);\n      }\n    };\n    const hP = {\n      getDisplayMedia: !1,\n      getStreamFromExtension: !1,\n      supportUnifiedPlan: !1,\n      supportMinBitrate: !1,\n      supportSetRtpSenderParameters: !1,\n      supportDualStream: !0,\n      webAudioMediaStreamDest: !1,\n      supportReplaceTrack: !1,\n      supportWebGL: !1,\n      webAudioWithAEC: !1,\n      supportRequestFrame: !1,\n      supportShareAudio: !1,\n      supportDualStreamEncoding: !1,\n      supportDataChannel: !1,\n      supportPCSetConfiguration: !1,\n      supportWebRTCEncodedTransform: !1,\n      supportWebRTCInsertableStream: !1,\n      supportRequestVideoFrameCallback: !1,\n      supportWebCrypto: !1,\n      supportSuppressLocalAudioPlayback: !1,\n      supportRestrictOwnAudio: !1\n    };\n    function pP() {\n      return hP;\n    }\n    function _P() {\n      return \"setSinkId\" in HTMLAudioElement.prototype && (!CD(\"RESTRICTION_SET_PLAYBACK_DEVICE\") || (Uw() || Fw()) && !oO());\n    }\n    function EP() {\n      return !hP.supportUnifiedPlan || CD(\"CHROME_FORCE_PLAN_B\") && sO();\n    }\n    function mP(e) {\n      return !(Bw() || Ww(87) || EP() || !CD(\"ENABLE_PRE_SUB\") && (null == e || !e.autoSubscribe || CD(\"FORCE_DISABLE_AUTO_SUB\")));\n    }\n    function fP(e) {\n      return CD(\"ENABLE_INSTANT_VIDEO\") ? CD(\"ENABLE_INSTANT_VIDEO\") : !(null == e || !e.autoSubscribe || CD(\"FORCE_DISABLE_AUTO_SUB\"));\n    }\n    function SP() {\n      return navigator.mediaDevices && \"getSupportedConstraints\" in navigator.mediaDevices;\n    }\n    function gP() {\n      if (SP()) {\n        const e = navigator.mediaDevices.getSupportedConstraints();\n        return !(!(\"suppressLocalAudioPlayback\" in e) || !e.suppressLocalAudioPlayback);\n      }\n      return Gw(141) || Kw(141) || Qw(141);\n    }\n    function TP() {\n      if (SP()) {\n        const e = navigator.mediaDevices.getSupportedConstraints();\n        return !(!(\"restrictOwnAudio\" in e) || !e.restrictOwnAudio);\n      }\n      return Gw(141) || Kw(141) || Qw(125);\n    }\n    let RP = function (e) {\n      return e.IOS_15_16_INTERRUPTION_START = \"ios15_16-interruption-start\", e.IOS_15_16_INTERRUPTION_END = \"ios15_16-interruption-end\", e.IOS_INTERRUPTION_START = \"ios-interruption-start\", e.IOS_INTERRUPTION_END = \"ios-interruption-end\", e.STATE_CHANGE = \"state-change\", e;\n    }({});\n    function CP(e, t, i) {\n      return {\n        sampleRate: e,\n        stereo: t,\n        bitrate: i\n      };\n    }\n    function vP(e, t, i, n, r) {\n      return {\n        width: e,\n        height: t,\n        frameRate: i,\n        bitrateMin: n,\n        bitrateMax: r\n      };\n    }\n    function yP(e, t, i, n, r) {\n      return {\n        width: {\n          max: e\n        },\n        height: {\n          max: t\n        },\n        frameRate: i,\n        bitrateMin: n,\n        bitrateMax: r\n      };\n    }\n    function IP(e, t) {\n      return {\n        numSpatialLayers: e,\n        numTemporalLayers: t\n      };\n    }\n    const AP = {\n        \"90p\": vP(160, 90),\n        \"90p_1\": vP(160, 90),\n        \"120p\": vP(160, 120, 15, 30, 65),\n        \"120p_1\": vP(160, 120, 15, 30, 65),\n        \"120p_3\": vP(120, 120, 15, 30, 50),\n        \"120p_4\": vP(212, 120),\n        \"180p\": vP(320, 180, 15, 30, 140),\n        \"180p_1\": vP(320, 180, 15, 30, 140),\n        \"180p_3\": vP(180, 180, 15, 30, 100),\n        \"180p_4\": vP(240, 180, 15, 30, 120),\n        \"240p\": vP(320, 240, 15, 40, 200),\n        \"240p_1\": vP(320, 240, 15, 40, 200),\n        \"240p_3\": vP(240, 240, 15, 40, 140),\n        \"240p_4\": vP(424, 240, 15, 40, 220),\n        \"360p\": vP(640, 360, 15, 80, 400),\n        \"360p_1\": vP(640, 360, 15, 80, 400),\n        \"360p_3\": vP(360, 360, 15, 80, 260),\n        \"360p_4\": vP(640, 360, 30, 80, 600),\n        \"360p_6\": vP(360, 360, 30, 80, 400),\n        \"360p_7\": vP(480, 360, 15, 80, 320),\n        \"360p_8\": vP(480, 360, 30, 80, 490),\n        \"360p_9\": vP(640, 360, 15, 80, 800),\n        \"360p_10\": vP(640, 360, 24, 80, 800),\n        \"360p_11\": vP(640, 360, 24, 80, 1e3),\n        \"480p\": vP(640, 480, 15, 100, 500),\n        \"480p_1\": vP(640, 480, 15, 100, 500),\n        \"480p_2\": vP(640, 480, 30, 100, 1e3),\n        \"480p_3\": vP(480, 480, 15, 100, 400),\n        \"480p_4\": vP(640, 480, 30, 100, 750),\n        \"480p_6\": vP(480, 480, 30, 100, 600),\n        \"480p_8\": vP(848, 480, 15, 100, 610),\n        \"480p_9\": vP(848, 480, 30, 100, 930),\n        \"480p_10\": vP(640, 480, 10, 100, 400),\n        \"720p\": vP(1280, 720, 15, 120, 1130),\n        \"720p_auto\": vP(1280, 720, 30, 900, 3e3),\n        \"720p_1\": vP(1280, 720, 15, 120, 1130),\n        \"720p_2\": vP(1280, 720, 30, 120, 2e3),\n        \"720p_3\": vP(1280, 720, 30, 120, 1710),\n        \"720p_5\": vP(960, 720, 15, 120, 910),\n        \"720p_6\": vP(960, 720, 30, 120, 1380),\n        \"1080p\": vP(1920, 1080, 15, 120, 2080),\n        \"1080p_1\": vP(1920, 1080, 15, 120, 2080),\n        \"1080p_2\": vP(1920, 1080, 30, 120, 3e3),\n        \"1080p_3\": vP(1920, 1080, 30, 120, 3150),\n        \"1080p_5\": vP(1920, 1080, 60, 120, 4780),\n        \"1440p\": vP(2560, 1440, 30, 120, 4850),\n        \"1440p_1\": vP(2560, 1440, 30, 120, 4850),\n        \"1440p_2\": vP(2560, 1440, 60, 120, 7350),\n        \"4k\": vP(3840, 2160, 30, 120, 8910),\n        \"4k_1\": vP(3840, 2160, 30, 120, 8910),\n        \"4k_3\": vP(3840, 2160, 60, 120, 13500)\n      },\n      bP = {\n        \"480p\": yP(640, 480, 5),\n        \"480p_1\": yP(640, 480, 5),\n        \"480p_2\": yP(640, 480, 30),\n        \"480p_3\": yP(640, 480, 15),\n        \"720p\": yP(1280, 720, 5),\n        \"720p_auto\": vP(1280, 720, 30, 900, 3e3),\n        \"720p_1\": yP(1280, 720, 5),\n        \"720p_2\": yP(1280, 720, 30),\n        \"720p_3\": yP(1280, 720, 15),\n        \"1080p\": yP(1920, 1080, 5),\n        \"1080p_1\": yP(1920, 1080, 5),\n        \"1080p_2\": yP(1920, 1080, 30),\n        \"1080p_3\": yP(1920, 1080, 15)\n      },\n      wP = {\n        \"1SL1TL\": IP(1, 1),\n        \"3SL3TL\": IP(3, 3),\n        \"2SL3TL\": IP(2, 3)\n      };\n    function OP(e) {\n      return e || (e = \"480p_1\"), \"string\" == typeof e ? Object.assign({}, AP[e]) : e;\n    }\n    function NP(e) {\n      return \"string\" == typeof e ? Object.assign({}, bP[e]) : e;\n    }\n    function DP(e) {\n      return \"string\" == typeof e ? Object.assign({}, wP[e]) : e;\n    }\n    const PP = {\n      speech_low_quality: CP(16e3, !1),\n      speech_standard: CP(32e3, !1, 18),\n      music_standard: CP(48e3, !1),\n      standard_stereo: CP(48e3, !0, 56),\n      high_quality: CP(48e3, !1, 128),\n      high_quality_stereo: CP(48e3, !0, 192)\n    };\n    function LP(e) {\n      return \"string\" == typeof e ? Object.assign({}, PP[e]) : e;\n    }\n    const kP = [];\n    function MP(e) {\n      return EO(e, \"mediaSource\", [\"screen\", \"window\", \"application\"]), !0;\n    }\n    let UP = function (e) {\n        return e.NEED_RENEGOTIATE = \"@need_renegotiate\", e.NEED_REPLACE_TRACK = \"@need_replace_track\", e.NEED_REPLACE_MIXING_TRACK = \"@need_replace_mixing_track\", e.NEED_CLOSE = \"@need_close\", e.NEED_ENABLE_TRACK = \"@need_enable_track\", e.NEED_DISABLE_TRACK = \"@need_disable_track\", e.NEED_SESSION_ID = \"@need_sid\", e.SET_OPTIMIZATION_MODE = \"@set_optimization_mode\", e.GET_STATS = \"@get_stats\", e.GET_RTC_STATS = \"@get_rtc_stats\", e.GET_LOW_VIDEO_TRACK = \"@get_low_video_track\", e.NEED_RESET_REMOTE_SDP = \"@need_reset_remote_sdp\", e.NEED_UPDATE_VIDEO_ENCODER = \"@need_update_video_encoder\", e.NEED_UPDATE_VIDEO_SEND_PARAMETERS = \"@need_update_video_send_parameters\", e.NEED_MUTE_TRACK = \"@need_mute_track\", e.NEED_UNMUTE_TRACK = \"@need_unmute_track\", e;\n      }({}),\n      VP = function (e) {\n        return e.SCREEN_TRACK = \"screen_track\", e.CUSTOM_TRACK = \"custome_track\", e.LOW_STREAM = \"low_stream\", e.SCREEN_LOW_TRACK = \"screen_low_track\", e;\n      }({});\n    let xP = function (e) {\n        return e[e.HIGH_STREAM = 0] = \"HIGH_STREAM\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e;\n      }({}),\n      FP = function (e) {\n        return e[e.HIGH_STREAM = 0] = \"HIGH_STREAM\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e[e.HIGH_STREAM_LAYER1 = 4] = \"HIGH_STREAM_LAYER1\", e[e.HIGH_STREAM_LAYER2 = 5] = \"HIGH_STREAM_LAYER2\", e[e.HIGH_STREAM_LAYER3 = 6] = \"HIGH_STREAM_LAYER3\", e[e.HIGH_STREAM_LAYER4 = 7] = \"HIGH_STREAM_LAYER4\", e[e.HIGH_STREAM_LAYER5 = 8] = \"HIGH_STREAM_LAYER5\", e[e.HIGH_STREAM_LAYER6 = 9] = \"HIGH_STREAM_LAYER6\", e;\n      }({}),\n      BP = function (e) {\n        return e[e.DISABLE = 0] = \"DISABLE\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e[e.AUDIO_ONLY = 2] = \"AUDIO_ONLY\", e[e.HIGH_STREAM_LAYER1 = 3] = \"HIGH_STREAM_LAYER1\", e[e.HIGH_STREAM_LAYER2 = 4] = \"HIGH_STREAM_LAYER2\", e[e.HIGH_STREAM_LAYER3 = 5] = \"HIGH_STREAM_LAYER3\", e[e.HIGH_STREAM_LAYER4 = 6] = \"HIGH_STREAM_LAYER4\", e[e.HIGH_STREAM_LAYER5 = 7] = \"HIGH_STREAM_LAYER5\", e[e.HIGH_STREAM_LAYER6 = 8] = \"HIGH_STREAM_LAYER6\", e;\n      }({}),\n      jP = function (e) {\n        return e.TRANSCEIVER_UPDATED = \"transceiver-updated\", e.SEI_TO_SEND = \"sei-to-send\", e.SEI_RECEIVED = \"sei-received\", e.TRACK_UPDATED = \"track-updated\", e;\n      }({}),\n      GP = function (e) {\n        return e.SOURCE_STATE_CHANGE = \"source-state-change\", e.TRACK_ENDED = \"track-ended\", e.BEAUTY_EFFECT_OVERLOAD = \"beauty-effect-overload\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\", e.CLOSED = \"closed\", e;\n      }({}),\n      WP = function (e) {\n        return e.FIRST_FRAME_DECODED = \"first-frame-decoded\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\", e.VIDEO_STATE_CHANGED = \"video-state-changed\", e.PLAY_START = \"play-start\", e.PLAY_END = \"play-end\", e.FIRST_FRAME_RENDER = \"first-frame-render\", e;\n      }({}),\n      HP = function (e) {\n        return e.AUDIO = \"audio\", e.VIDEO = \"video\", e.DATA = \"data\", e;\n      }({}),\n      KP = function (e) {\n        return e.AUDIO_SOURCE_STATE_CHANGE = \"audio_source_state_change\", e.RECEIVE_TRACK_BUFFER = \"receive_track_buffer\", e.ON_AUDIO_BUFFER = \"on_audio_buffer\", e.UPDATE_SOURCE = \"update_source\", e;\n      }({});\n    !function (e) {\n      e.UPDATE_TRACK_SOURCE = \"update-track-source\";\n    }({});\n    const YP = {\n        sendVolumeLevel: 0,\n        sendBitrate: 0,\n        sendBytes: 0,\n        sendPackets: 0,\n        sendPacketsLost: 0,\n        sendJitterMs: 0,\n        sendRttMs: 0,\n        currentPacketLossRate: 0\n      },\n      zP = {\n        sendBytes: 0,\n        sendBitrate: 0,\n        sendPackets: 0,\n        sendPacketsLost: 0,\n        sendJitterMs: 0,\n        sendRttMs: 0,\n        sendResolutionHeight: 0,\n        sendResolutionWidth: 0,\n        captureResolutionHeight: 0,\n        captureResolutionWidth: 0,\n        targetSendBitrate: 0,\n        totalDuration: 0,\n        totalFreezeTime: 0,\n        currentPacketLossRate: 0\n      },\n      qP = {\n        transportDelay: 0,\n        end2EndDelay: 0,\n        receiveBitrate: 0,\n        receiveLevel: 0,\n        receiveBytes: 0,\n        receiveDelay: 0,\n        receivePackets: 0,\n        receivePacketsLost: 0,\n        receivePacketsDiscarded: 0,\n        totalDuration: 0,\n        totalFreezeTime: 0,\n        freezeRate: 0,\n        packetLossRate: 0,\n        currentPacketLossRate: 0,\n        publishDuration: -1\n      },\n      XP = {\n        uplinkNetworkQuality: 0,\n        downlinkNetworkQuality: 0\n      },\n      JP = {\n        transportDelay: 0,\n        end2EndDelay: 0,\n        receiveBitrate: 0,\n        receiveBytes: 0,\n        receiveDelay: 0,\n        receivePackets: 0,\n        receivePacketsLost: 0,\n        receiveResolutionHeight: 0,\n        receiveResolutionWidth: 0,\n        totalDuration: 0,\n        totalFreezeTime: 0,\n        freezeRate: 0,\n        packetLossRate: 0,\n        currentPacketLossRate: 0,\n        publishDuration: -1\n      };\n    let QP = function (e) {\n        return e.ON_TRACK = \"on_track\", e.ON_NODE = \"on_node\", e;\n      }({}),\n      ZP = function (e) {\n        return e.REQUEST_UPDATE_CONSTRAINTS = \"request_update_constraints\", e.REQUEST_CONSTRAINTS = \"request_constraints\", e;\n      }({}),\n      $P = function (e) {\n        return e.IDLE = \"IDLE\", e.INITING = \"INITING\", e.INITEND = \"INITEND\", e;\n      }({}),\n      eL = function (e) {\n        return e.STATE_CHANGE = \"state_change\", e.RECORDING_DEVICE_CHANGED = \"recordingDeviceChanged\", e.PLAYOUT_DEVICE_CHANGED = \"playoutDeviceChanged\", e.CAMERA_DEVICE_CHANGED = \"cameraDeviceChanged\", e;\n      }({}),\n      tL = function (e) {\n        return e.NONE = \"none\", e.INIT = \"init\", e.CANPLAY = \"canplay\", e.PLAYING = \"playing\", e.PAUSED = \"paused\", e.SUSPEND = \"suspend\", e.STALLED = \"stalled\", e.WAITING = \"waiting\", e.ERROR = \"error\", e.DESTROYED = \"destroyed\", e.ABORT = \"abort\", e.ENDED = \"ended\", e.EMPTIED = \"emptied\", e.LOADEDDATA = \"loadeddata\", e;\n      }({}),\n      iL = function (e) {\n        return e[e.VideoStateStopped = 0] = \"VideoStateStopped\", e[e.VideoStateStarting = 1] = \"VideoStateStarting\", e[e.VideoStateDecoding = 2] = \"VideoStateDecoding\", e[e.VideoStateFrozen = 3] = \"VideoStateFrozen\", e;\n      }({});\n    const nL = {\n      uninit: 100,\n      none: 110,\n      init: 120,\n      loadeddata: 130,\n      canplay: 200,\n      playing: 210,\n      paused: 220,\n      suspend: 300,\n      stalled: 310,\n      waiting: 320,\n      error: 330,\n      destroyed: 340,\n      abort: 350,\n      ended: 360,\n      emptied: 370\n    };\n    let rL = function (e) {\n      return e.OPEN = \"open\", e.MESSAGE = \"message\", e.CLOSE = \"close\", e.CLOSING = \"closing\", e.ERROR = \"error\", e;\n    }({});\n    function oL(e, t, i, n, r) {\n      var o,\n        s,\n        a = {};\n      return Object.keys(n).forEach(function (e) {\n        a[e] = n[e];\n      }), a.enumerable = !!a.enumerable, a.configurable = !!a.configurable, (\"value\" in a || a.initializer) && (a.writable = !0), a = nr(o = mr(s = i.slice()).call(s)).call(o, function (i, n) {\n        return n(e, t, i) || i;\n      }, a), r && void 0 !== a.initializer && (a.value = a.initializer ? a.initializer.call(r) : void 0, a.initializer = void 0), void 0 === a.initializer ? (Object.defineProperty(e, t, a), null) : a;\n    }\n    function sL(e, t, i) {\n      return (t = function (e) {\n        var t = function (e, t) {\n          if (\"object\" != typeof e || !e) return e;\n          var i = e[Symbol.toPrimitive];\n          if (void 0 !== i) {\n            var n = i.call(e, \"string\");\n            if (\"object\" != typeof n) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return String(e);\n        }(e);\n        return \"symbol\" == typeof t ? t : t + \"\";\n      }(t)) in e ? Object.defineProperty(e, t, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = i, e;\n    }\n    function aL(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function cL(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? aL(Object(i), !0).forEach(function (t) {\n          sL(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : aL(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    class dL extends NO {\n      set _mediaStreamTrack(e) {\n        e !== this.mediaStreamTrack && (this.safeEmit(jP.TRACK_UPDATED, e), this.mediaStreamTrack = e);\n      }\n      get _mediaStreamTrack() {\n        return this.mediaStreamTrack;\n      }\n      constructor(e, t) {\n        super(), sL(this, \"trackMediaType\", void 0), sL(this, \"_ID\", void 0), sL(this, \"_rtpTransceiver\", void 0), sL(this, \"_lowRtpTransceiver\", void 0), sL(this, \"_hints\", []), sL(this, \"_isClosed\", !1), sL(this, \"_originMediaStreamTrack\", void 0), sL(this, \"mediaStreamTrack\", void 0), sL(this, \"_external\", {}), this._ID = t || SN(8, \"track-\"), this._originMediaStreamTrack = e, this.mediaStreamTrack = e, function (e) {\n          Ln(kP).call(kP, e) || kP.push(e);\n        }(this);\n      }\n      toString() {\n        return this._ID;\n      }\n      getTrackId() {\n        return this._ID;\n      }\n      getMediaStreamTrack(e) {\n        return e || dN(() => {\n          var e;\n          lP.reportApiInvoke(null, {\n            name: LO.GET_MEDIA_STREAM_TRACK,\n            options: [],\n            tag: kO.TRACER\n          }).onSuccess((null === (e = this._mediaStreamTrack) || void 0 === e ? void 0 : e.label) || \"\");\n        }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;\n      }\n      getRTCRtpTransceiver(e) {\n        return e === xP.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;\n      }\n      getMediaStreamTrackSettings() {\n        return this.getMediaStreamTrack(!0).getSettings();\n      }\n      close() {\n        this._isClosed = !0, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function (e) {\n          const t = kP.indexOf(e);\n          -1 !== t && kP.splice(t, 1);\n        }(this), this.emit(GP.CLOSED), this.removeAllListeners(jP.SEI_RECEIVED);\n      }\n      _updateRtpTransceiver(e, t) {\n        if (t === xP.LOW_STREAM) {\n          if (this._lowRtpTransceiver === e) return;\n          this._lowRtpTransceiver = e;\n        } else {\n          if (this._rtpTransceiver === e) return;\n          this._rtpTransceiver = e;\n        }\n        this.emit(jP.TRANSCEIVER_UPDATED, e, t);\n      }\n    }\n    class lL extends dL {\n      get isExternalTrack() {\n        return this._isExternalTrack;\n      }\n      get muted() {\n        return this._muted;\n      }\n      get enabled() {\n        return this._enabled;\n      }\n      get processorContext() {\n        return this._processorContext;\n      }\n      constructor(e, t) {\n        super(e, t), sL(this, \"_enabled\", !0), sL(this, \"_muted\", !1), sL(this, \"_isExternalTrack\", !1), sL(this, \"_isClosed\", !1), sL(this, \"_enabledMutex\", void 0), sL(this, \"processor\", void 0), sL(this, \"_processorContext\", void 0), sL(this, \"_handleTrackEnded\", () => {\n          this.onTrackEnded();\n        }), this._enabledMutex = new PN(\"\".concat(this.getTrackId())), e.addEventListener(\"ended\", this._handleTrackEnded);\n      }\n      getTrackLabel() {\n        var e, t;\n        return null !== (e = null === (t = this._originMediaStreamTrack) || void 0 === t ? void 0 : t.label) && void 0 !== e ? e : \"\";\n      }\n      close() {\n        this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, iP.debug(\"[\".concat(this.getTrackId(), \"] close\")), this.emit(UP.NEED_CLOSE), super.close());\n      }\n      async _updateOriginMediaStreamTrack(e, t) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        this._isExternalTrack = i, e !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop()), e.addEventListener(\"ended\", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this._processorContext\n        }));\n      }\n      _getDefaultPlayerConfig() {\n        return {};\n      }\n      onTrackEnded() {\n        iP.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(GP.TRACK_ENDED);\n      }\n      stateCheck(e, t) {\n        if (iP.debug(\"check track state, [muted: \".concat(this._muted, \", enabled: \").concat(this._enabled, \"] to [\").concat(e, \": \").concat(t, \"]\")), _O(t, e), this._enabled && this._muted && \"enabled\" === e && !1 === t) throw new pO(hO.TRACK_STATE_UNREACHABLE, \"cannot set enabled while the track is muted\").print(\"error\", iP);\n        if (!this._enabled && !this._muted && \"muted\" === e && !0 === t) throw new pO(hO.TRACK_STATE_UNREACHABLE, \"cannot set muted while the track is disabled\").print(\"error\", iP);\n      }\n      getProcessorStats() {\n        return this._processorContext && this._processorContext.gatherStats() || [];\n      }\n      getProcessorUsage() {\n        return this._processorContext ? this._processorContext.gatherUsage() : rp.resolve([]);\n      }\n    }\n    const uL = window.AudioContext || window.webkitAudioContext;\n    let hL,\n      pL = null;\n    const _L = new class extends NO {\n      constructor() {\n        super(...arguments), sL(this, \"prevState\", void 0), sL(this, \"curState\", void 0), sL(this, \"currentTime\", void 0), sL(this, \"currentTimeStuckAt\", void 0), sL(this, \"interruptDetectorTrack\", void 0), sL(this, \"onLocalAudioTrackMute\", () => {\n          iP.info(\"ios15-interruption-start\"), this.emit(RP.IOS_15_16_INTERRUPTION_START);\n        }), sL(this, \"onLocalAudioTrackUnmute\", async () => {\n          iP.info(\"ios15-interruption-end\"), \"running\" !== this.curState || this.duringInterruption ? iP.info(\"ios15-interruption-end-canceled\") : (pL && (await pL.suspend()), this.emit(RP.IOS_15_16_INTERRUPTION_END));\n        });\n      }\n      get duringInterruption() {\n        return \"running\" === this.prevState && \"interrupted\" === this.curState;\n      }\n      bindInterruptDetectorTrack(e) {\n        iP.debug(\"webaudio bindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);\n      }\n      unbindInterruptDetectorTrack(e) {\n        iP.debug(\"webaudio unbindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);\n      }\n    }();\n    function EL() {\n      if (!pL) {\n        if (function () {\n          if (!uL) return void iP.error(\"your browser is not support web audio\");\n          iP.info(\"create audio context\");\n          const e = cL({}, CD(\"WEBAUDIO_INIT_OPTIONS\"));\n          iP.debug(\"audio context init option:\", JSON.stringify(e)), pL = new uL(e), _L.curState = pL.state, pL.onstatechange = () => {\n            _L.prevState = _L.curState, _L.curState = pL ? pL.state : void 0;\n            const {\n                prevState: e,\n                curState: t\n              } = _L,\n              i = \"running\" === t,\n              n = \"interrupted\" === t,\n              r = \"running\" === e,\n              o = \"suspended\" === e,\n              s = \"interrupted\" === e,\n              a = Dw().osVersion;\n            (jw() || iO()) && r && n && (iP.info(\"ios\".concat(a, \"-interruption-start\")), _L.emit(RP.IOS_INTERRUPTION_START)), (jw() || iO()) && (o || s) && i && (iP.info(\"ios\".concat(a, \"-interruption-end\")), _L.emit(RP.IOS_INTERRUPTION_END)), e !== t && _L.emit(RP.STATE_CHANGE, t, e);\n          }, setInterval(() => {\n            var e;\n            const t = null === (e = pL) || void 0 === e ? void 0 : e.currentTime;\n            _L.currentTime !== t ? (_L.currentTimeStuckAt && (iP.debug(\"AudioContext current time resume at \".concat(t)), _L.currentTimeStuckAt = void 0), _L.currentTime = t) : (t !== _L.currentTimeStuckAt && (lP.reportApiInvoke(null, {\n              name: \"WEB_AUDIO_CURRENT_TIME_STUCK\",\n              options: {\n                currentTime: t\n              },\n              tag: kO.TRACER\n            }).onSuccess(), iP.warning(\"AudioContext current time stuck at \".concat(t))), _L.currentTimeStuckAt = t);\n          }, 5e3), async function (e) {\n            const t = [\"click\", \"contextmenu\", \"auxclick\", \"dblclick\", \"mousedown\", \"mouseup\", \"touchend\", \"keydown\", \"keyup\"];\n            let i,\n              n,\n              r = !1,\n              o = !1,\n              s = !1;\n            function a(t) {\n              \"running\" === e.state ? c(!1) : jw() || iO() ? \"suspended\" === e.state && (c(!0), t && e.resume().then(d, d)) : \"closed\" !== e.state && (c(!0), t && e.resume().then(d, d));\n            }\n            function c(e) {\n              if (r !== e) {\n                r = e;\n                for (let i = 0, n = t; i < n.length; i += 1) {\n                  const t = n[i];\n                  e ? window.addEventListener(t, l, {\n                    capture: !0,\n                    passive: !0\n                  }) : window.removeEventListener(t, l, {\n                    capture: !0,\n                    passive: !0\n                  });\n                }\n              }\n            }\n            function d() {\n              a(!1);\n            }\n            function l() {\n              a(!0);\n            }\n            function u() {\n              let e;\n              try {\n                e = i.play(), e ? e.then(_, _) : (i.addEventListener(\"playing\", _), i.addEventListener(\"abort\", _), i.addEventListener(\"error\", _));\n              } catch (e) {\n                _();\n              }\n            }\n            function h(e) {\n              s || (i.paused ? e ? (p(!1), s = !0, u()) : p(!0) : p(!1));\n            }\n            function p(e) {\n              if (o !== e) {\n                o = e;\n                for (let i = 0, n = t; i < n.length; i++) {\n                  const t = n[i];\n                  e ? window.addEventListener(t, E, {\n                    capture: !0,\n                    passive: !0\n                  }) : window.removeEventListener(t, E, {\n                    capture: !0,\n                    passive: !0\n                  });\n                }\n              }\n            }\n            function _() {\n              i.removeEventListener(\"playing\", _), i.removeEventListener(\"abort\", _), i.removeEventListener(\"error\", _), s = !1, h(!1);\n            }\n            function E() {\n              h(!0);\n            }\n            if (jw() && CD(\"IOS_BG_TAG\")) {\n              const t = e.createMediaStreamDestination(),\n                r = document.createElement(\"div\");\n              r.innerHTML = \"<audio x-webkit-airplay='deny'></audio>\", i = r.children.item(0), i.controls = !1, i.disableRemotePlayback = !0, i.preload = \"auto\", i.srcObject = t.stream, n = () => {\n                if (CD(\"IOS_AUTO_RESTART_BG_TAG\") && i && i.srcObject && !s && (!i.paused || !0 !== o)) {\n                  i.paused || i.pause();\n                  try {\n                    s = !0, u();\n                  } catch (e) {\n                    s = !1;\n                  }\n                  return !0;\n                }\n              }, h(!0);\n            }\n            return _L.on(RP.STATE_CHANGE, function () {\n              a(!0);\n            }), a(!1), n;\n          }(pL).then(e => {\n            hL = e;\n          });\n        }(), !pL) throw new pO(hO.NOT_SUPPORTED, \"can not create audio context\");\n        return pL;\n      }\n      return pL;\n    }\n    function mL(e) {\n      if (function () {\n        if (null !== fL) return fL;\n        const e = EL(),\n          t = e.createBufferSource(),\n          i = e.createGain(),\n          n = e.createGain();\n        t.connect(i), t.connect(n), t.disconnect(i);\n        let r = !1;\n        try {\n          t.disconnect(i);\n        } catch (e) {\n          r = !0;\n        }\n        return t.disconnect(), fL = r, r;\n      }()) return;\n      const t = e.connect,\n        i = e.disconnect;\n      e.connect = (i, n, r) => {\n        var o;\n        return e._inputNodes || (e._inputNodes = []), Ln(o = e._inputNodes).call(o, i) || (i instanceof AudioNode ? (e._inputNodes.push(i), t.call(e, i, n, r)) : t.call(e, i, n)), e;\n      }, e.disconnect = (n, r, o) => {\n        i.call(e), n ? nN(e._inputNodes, n) : e._inputNodes = [];\n        for (const i of e._inputNodes) t.call(e, i);\n      };\n    }\n    let fL = null;\n    function SL(e, t) {\n      let i = !1;\n      const n = 1 / t;\n      if (CD(\"DISABLE_WEBAUDIO\")) {\n        const t = window.setInterval(() => {\n          i ? window.clearInterval(t) : e(performance.now() / 1e3);\n        }, 1e3 * n);\n      } else {\n        const t = EL();\n        let r = t.createGain();\n        r.gain.value = 0, r.connect(t.destination);\n        const o = () => {\n          if (i) return void (r = null);\n          const s = t.createOscillator();\n          s.onended = o, s.connect(r), s.start(0), s.stop(t.currentTime + n), e(t.currentTime);\n        };\n        o();\n      }\n      return () => {\n        i = !0;\n      };\n    }\n    class gL {\n      constructor() {\n        sL(this, \"context\", void 0), sL(this, \"analyserNode\", void 0), sL(this, \"sourceNode\", void 0), this.context = EL(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4;\n      }\n      updateSource(e) {\n        if (e !== this.sourceNode) {\n          if (this.sourceNode) try {\n            this.sourceNode.disconnect(this.analyserNode);\n          } catch (e) {}\n          this.sourceNode = e, null == e || e.connect(this.analyserNode);\n        }\n      }\n      getVolumeLevel() {\n        if (!this.sourceNode) return 0;\n        if (!this.context || jw() || iO() || \"running\" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;\n        const e = new Float32Array(this.analyserNode.fftSize);\n        if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e);else {\n          const t = new Uint8Array(this.analyserNode.fftSize);\n          this.analyserNode.getByteTimeDomainData(t);\n          for (let i = 0; i < e.length; ++i) e[i] = t[i] / 128 - 1;\n        }\n        const t = nr(e).call(e, (e, t) => e + t * t, 0) / e.length;\n        return Math.max(10 * Math.log10(t) + 100, 0) / 100;\n      }\n      getAnalyserNode() {\n        return this.analyserNode;\n      }\n      rebuildAnalyser() {\n        try {\n          var e, t;\n          null === (e = this.sourceNode) || void 0 === e || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4, null === (t = this.sourceNode) || void 0 === t || t.connect(this.analyserNode);\n        } catch (e) {\n          iP.warning(\"rebuild analyser node failed.\");\n        }\n      }\n      destroy() {\n        this.updateSource(void 0);\n      }\n    }\n    class TL extends NO {\n      get processSourceNode() {\n        return this.sourceNode;\n      }\n      set processedNode(e) {\n        var t;\n        if (!this.isDestroyed && this._processedNode !== e) {\n          try {\n            var i;\n            null === (i = this.sourceNode) || void 0 === i || i.disconnect(this.outputNode);\n          } catch (e) {}\n          null === (t = this._processedNode) || void 0 === t || t.disconnect(), this._processedNode = e, this.connect();\n        }\n      }\n      get processedNode() {\n        return this._processedNode;\n      }\n      constructor() {\n        super(), sL(this, \"outputNode\", void 0), sL(this, \"outputTrack\", void 0), sL(this, \"isPlayed\", !1), sL(this, \"sourceNode\", void 0), sL(this, \"context\", void 0), sL(this, \"audioBufferNode\", void 0), sL(this, \"destNode\", void 0), sL(this, \"audioOutputLevel\", 0), sL(this, \"volumeLevelAnalyser\", void 0), sL(this, \"_processedNode\", void 0), sL(this, \"playNode\", void 0), sL(this, \"isDestroyed\", !1), sL(this, \"onNoAudioInput\", void 0), sL(this, \"isNoAudioInput\", !1), sL(this, \"_noAudioInputCount\", 0), this.context = EL(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), mL(this.outputNode), this.volumeLevelAnalyser = new gL();\n      }\n      startGetAudioBuffer(e) {\n        this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = e => {\n          this.emit(KP.ON_AUDIO_BUFFER, function (e) {\n            for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) {\n              const i = e.outputBuffer.getChannelData(t);\n              for (let e = 0; e < i.length; e += 1) i[e] = 0;\n            }\n            return e.inputBuffer;\n          }(e));\n        });\n      }\n      stopGetAudioBuffer() {\n        this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);\n      }\n      createOutputTrack() {\n        if (!pP().webAudioMediaStreamDest) throw new pO(hO.NOT_SUPPORTED, \"your browser is not support audio processor\");\n        return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;\n      }\n      play(e) {\n        \"running\" !== this.context.state && oN(() => {\n          _L.emit(\"autoplay-failed\");\n        }), this.isPlayed = !0, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode);\n      }\n      stop() {\n        if (this.isPlayed) try {\n          this.outputNode.disconnect(this.playNode);\n        } catch (e) {}\n        this.isPlayed = !1;\n      }\n      getAccurateVolumeLevel() {\n        return this.volumeLevelAnalyser.getVolumeLevel();\n      }\n      async checkHasAudioInput() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n        if (e > 5) return this.isNoAudioInput = !0, this.onNoAudioInput && this.onNoAudioInput(), !1;\n        jw() || iO() ? \"suspended\" === this.context.state && this.context.resume() : \"running\" !== this.context.state && this.context.resume();\n        const t = this.volumeLevelAnalyser.getAnalyserNode();\n        let i;\n        t.getFloatTimeDomainData ? (i = new Float32Array(t.fftSize), t.getFloatTimeDomainData(i)) : (i = new Uint8Array(t.fftSize), t.getByteTimeDomainData(i));\n        let n = !1;\n        for (let e = 0; e < i.length; e++) 0 !== i[e] && (n = !0);\n        return n ? (this.isNoAudioInput = !1, !0) : (await fN(200), (await this.checkHasAudioInput(e ? e + 1 : 1)) && n);\n      }\n      getAudioVolume() {\n        return this.outputNode.gain.value;\n      }\n      setVolume(e) {\n        this.outputNode.gain.setValueAtTime(e, this.context.currentTime);\n      }\n      destroy() {\n        this.disconnect(), this.stop(), this.isDestroyed = !0, this.onNoAudioInput = void 0;\n      }\n      disconnect() {\n        var e, t;\n        null === (e = this.processedNode) || void 0 === e || e.disconnect(), null === (t = this.sourceNode) || void 0 === t || t.disconnect(), this.outputNode && this.outputNode.disconnect();\n      }\n      connect() {\n        var e;\n        this.processedNode ? null === (e = this.processedNode) || void 0 === e || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);\n      }\n    }\n    class RL extends TL {\n      get isFreeze() {\n        return !1;\n      }\n      constructor(e, t, i) {\n        var n;\n        if (super(), sL(this, \"sourceNode\", void 0), sL(this, \"track\", void 0), sL(this, \"clonedTrack\", void 0), sL(this, \"audioElement\", void 0), sL(this, \"isCurrentTrackCloned\", !1), sL(this, \"isRemoteTrack\", !1), sL(this, \"originVolumeLevelAnalyser\", void 0), sL(this, \"rebuildWebAudio\", async () => {\n          if (iP.debug(\"ready to rebuild web audio, state:\", this.context.state), this.isNoAudioInput && (await this.checkHasAudioInput()), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener(\"click\", this.rebuildWebAudio, !0), void iP.debug(\"rebuild web audio success, current volume status\", this.getAccurateVolumeLevel());\n          this.context.resume().then(() => iP.info(\"resume success\")), iP.debug(\"rebuild web audio because of ios 12 bugs\"), this.disconnect();\n          const e = this.track;\n          this.track = this.track.clone(), this.isCurrentTrackCloned ? e.stop() : this.isCurrentTrackCloned = !0;\n          const t = new MediaStream([this.track]);\n          this.sourceNode = this.context.createMediaStreamSource(t), mL(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();\n          const i = this.outputNode.gain.value;\n          this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i, this.context.currentTime), mL(this.outputNode), this.emit(KP.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();\n        }), \"audio\" !== e.kind) throw new pO(hO.UNEXPECTED_ERROR);\n        this.track = e;\n        const r = new MediaStream([this.track]);\n        if (this.isRemoteTrack = !!t, this.sourceNode = this.context.createMediaStreamSource(r), mL(this.sourceNode), i) {\n          const e = i.clone();\n          e.enabled = !0, this.clonedTrack = e, iP.debug(\"create an unmuted track \".concat(e.id, \" from the original track \").concat(i.id, \" to get the volume\"));\n          const t = this.context.createMediaStreamSource(new MediaStream([e]));\n          mL(t), this.originVolumeLevelAnalyser = new gL(), this.originVolumeLevelAnalyser.updateSource(t);\n        }\n        this.connect(), this.audioElement = document.createElement(\"audio\"), this.audioElement.srcObject = r;\n        const o = Dw();\n        t && o.os === Aw.IOS && Number(null === (n = o.osVersion) || void 0 === n ? void 0 : n.split(\".\")[0]) < 15 && (_L.on(RP.STATE_CHANGE, () => {\n          \"suspended\" === this.context.state ? document.body.addEventListener(\"click\", this.rebuildWebAudio, !0) : \"running\" === this.context.state && this.rebuildWebAudio();\n        }), this.checkHasAudioInput().then(e => {\n          e || document.body.addEventListener(\"click\", this.rebuildWebAudio, !0);\n        }));\n      }\n      updateTrack(e) {\n        this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = !1;\n        const t = new MediaStream([e]);\n        this.sourceNode = this.context.createMediaStreamSource(t), mL(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(KP.UPDATE_SOURCE), this.audioElement.srcObject = t;\n      }\n      destroy() {\n        var e;\n        this.audioElement.srcObject = null, this.audioElement.remove(), _L.off(\"state-change\", this.rebuildWebAudio), null === (e = this.originVolumeLevelAnalyser) || void 0 === e || e.destroy(), this.clonedTrack = void 0, super.destroy();\n      }\n      createMediaStreamSourceNode(e) {\n        return this.context.createMediaStreamSource(new MediaStream([e]));\n      }\n      updateOriginTrack(e) {\n        const t = e.clone();\n        t.enabled = !0, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t), iP.debug(\"create an unmuted track \".concat(t.id, \" from the original track \").concat(e.id, \" to get the volume\"));\n        const i = this.context.createMediaStreamSource(new MediaStream([t]));\n        mL(i), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i);\n      }\n      getOriginVolumeLevel() {\n        return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();\n      }\n    }\n    async function CL(e, t, i) {\n      const n = (e, t) => e ? \"number\" != typeof e ? e.max || e.exact || e.ideal || e.min || t : e : t,\n        r = {\n          audio: !!i && {\n            mandatory: {\n              chromeMediaSource: \"desktop\"\n            }\n          },\n          video: {\n            mandatory: {\n              chromeMediaSource: \"desktop\",\n              chromeMediaSourceId: e,\n              maxHeight: n(t.height, 1080),\n              maxWidth: n(t.width, 1920)\n            }\n          }\n        };\n      return t.frameRate && \"number\" != typeof t.frameRate ? (r.video.mandatory.maxFrameRate = t.frameRate.max, r.video.mandatory.minFrameRate = t.frameRate.min) : \"number\" == typeof t.frameRate && (r.video.mandatory.maxFrameRate = t.frameRate), await navigator.mediaDevices.getUserMedia(r);\n    }\n    async function vL(e, t) {\n      const i = await yL(e.mediaSource),\n        {\n          sourceId: n,\n          audio: r\n        } = await function (e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n          return new rp((i, n) => {\n            const r = document.createElement(\"div\");\n            r.innerText = \"share screen\", r.setAttribute(\"style\", \"text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;\");\n            const o = document.createElement(\"div\");\n            o.setAttribute(\"style\", \"width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;\");\n            const s = document.createElement(\"div\");\n            s.innerText = \"Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.\", s.setAttribute(\"style\", \"height: 12%;\");\n            const a = document.createElement(\"div\");\n            a.setAttribute(\"style\", \"width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;\");\n            const c = document.createElement(\"div\");\n            c.setAttribute(\"style\", \"display: flex; justify-content: space-between; padding: 16px 0;\");\n            const d = document.createElement(\"button\");\n            d.innerHTML = \"cancel\", d.setAttribute(\"style\", \"width: 85px;\"), d.onclick = () => {\n              document.body.removeChild(h);\n              const e = new Error(\"NotAllowedError\");\n              e.name = \"NotAllowedError\", n(e);\n            };\n            let l = t;\n            const u = document.createElement(\"div\");\n            if (t) {\n              const e = document.createElement(\"input\");\n              e.setAttribute(\"type\", \"checkbox\");\n              const t = document.createElement(\"span\");\n              e.setAttribute(\"style\", \"margin-right: 6px;\"), t.innerText = \"Share audio\", e.checked = l, e.onchange = () => {\n                l = e.checked;\n              }, u.appendChild(e), u.appendChild(t);\n            }\n            c.appendChild(u), c.appendChild(d), o.appendChild(s), o.appendChild(a), o.appendChild(c);\n            const h = document.createElement(\"div\");\n            h.setAttribute(\"style\", \"position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);\"), h.appendChild(r), h.appendChild(o), document.body.appendChild(h), e.map(e => {\n              if (e.id) {\n                const t = document.createElement(\"div\");\n                t.setAttribute(\"style\", \"width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;\");\n                let n = e.thumbnail;\n                try {\n                  const {\n                    width: e\n                  } = n.getSize();\n                  e > 1920 && (n = n.resize({\n                    width: 1920\n                  }));\n                } catch (e) {\n                  throw e && e.message.startsWith(\"Illegal invocation\") && console.error(\"Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)\"), e;\n                }\n                t.innerHTML = '<div style=\"height: 120px; display: table-cell; vertical-align: middle;\"><img style=\"width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);\" src=' + n.toDataURL() + ' /></div><span style=\"\\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">' + e.name.replace(/[\\u00A0-\\u9999<>\\&]/g, function (e) {\n                  return \"&#\" + e.charCodeAt(0) + \";\";\n                }) + \"</span>\", t.onclick = () => {\n                  document.body.removeChild(h), i({\n                    sourceId: e.id,\n                    audio: l\n                  });\n                }, a.appendChild(t);\n              }\n            });\n          });\n        }(i, t);\n      return await CL(n, e, r);\n    }\n    async function yL(e) {\n      let t = [\"window\", \"screen\"];\n      \"application\" !== e && \"window\" !== e || (t = [\"window\"]), \"screen\" === e && (t = [\"screen\"]);\n      const i = PO();\n      if (!i) throw console.error(\"failed to fetch electron, please mount it to window\"), new pO(hO.ELECTRON_IS_NULL);\n      let n = null;\n      try {\n        var r;\n        n = (null === (r = i.desktopCapturer) || void 0 === r ? void 0 : r.getSources({\n          types: t\n        })) || i.ipcRenderer.invoke(\"DESKTOP_CAPTURER_GET_SOURCES\", {\n          types: t\n        });\n      } catch (e) {\n        n = null;\n      }\n      n && n.then || (n = new rp((e, n) => {\n        i.desktopCapturer.getSources({\n          types: t\n        }, (t, i) => {\n          t ? n(t) : e(i);\n        });\n      }));\n      try {\n        return await n;\n      } catch (e) {\n        throw new pO(hO.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e.toString());\n      }\n    }\n    const IL = new PN(\"safari\");\n    let AL = !1,\n      bL = !1;\n    async function wL(e, t) {\n      let i = 0,\n        n = null;\n      for (; i < 2;) try {\n        n = await OL(e, t, i > 0);\n        break;\n      } catch (e) {\n        if (e instanceof pO) throw iP.error(\"[\".concat(t, \"] \").concat(e.toString())), e;\n        const n = NL(e.name || e.code || e, e.message);\n        if (n.code === hO.MEDIA_OPTION_INVALID) {\n          iP.debug(\"[\".concat(t, \"] detect media option invalid, retry\")), i += 1, await fN(500);\n          continue;\n        }\n        throw iP.error(\"[\".concat(t, \"] \").concat(n.toString())), n;\n      }\n      if (!n) throw new pO(hO.UNEXPECTED_ERROR, \"can not find stream after getUserMedia\");\n      return n;\n    }\n    async function OL(e, t, i) {\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new pO(hO.NOT_SUPPORTED, \"can not find getUserMedia\");\n      i && (e.video && (delete e.video.width, delete e.video.height), e.screen && (delete e.screen.width, delete e.screen.height));\n      const n = pP(),\n        r = new MediaStream();\n      if (e.audioSource && r.addTrack(e.audioSource), e.videoSource && r.addTrack(e.videoSource), !e.audio && !e.video && !e.screen) return iP.debug(\"Using Video Source/ Audio Source\"), r;\n      if (e.screen) if (PO()) e.screen.sourceId ? DL(r, await CL(e.screen.sourceId, e.screen, !!e.screenAudio)) : DL(r, await vL(e.screen, !!e.screenAudio));else if (Uw() && e.screen.extensionId && e.screen.mandatory) {\n        if (!n.getStreamFromExtension) throw new pO(hO.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n        iP.debug(\"[\".concat(t, '] Screen access on chrome stable, looking for extension\"'));\n        const i = await (s = e.screen.extensionId, a = t, new rp((e, t) => {\n          try {\n            chrome.runtime.sendMessage(s, {\n              getStream: !0\n            }, i => {\n              if (!i || !i.streamId) return iP.error(\"[\".concat(a, \"] No response from Chrome Plugin. Plugin not installed properly\"), i), void t(new pO(hO.CHROME_PLUGIN_NO_RESPONSE, \"No response from Chrome Plugin. Plugin not installed properly\"));\n              e(i.streamId);\n            });\n          } catch (e) {\n            iP.error(\"[\".concat(a, \"] AgoraRTC screensharing plugin is not accessible(\").concat(s, \")\"), e.toString()), t(new pO(hO.CHROME_PLUGIN_NOT_INSTALL));\n          }\n        }));\n        e.screen.mandatory.chromeMediaSourceId = i, DL(r, await navigator.mediaDevices.getUserMedia({\n          video: {\n            mandatory: e.screen.mandatory\n          }\n        }));\n      } else if (n.getDisplayMedia) {\n        var o;\n        e.screen.mediaSource && MP(e.screen.mediaSource);\n        const i = {\n            width: e.screen.width,\n            height: e.screen.height,\n            frameRate: e.screen.frameRate,\n            displaySurface: null !== (o = e.screen.displaySurface) && void 0 !== o ? o : \"screen\" === e.screen.mediaSource ? \"monitor\" : e.screen.mediaSource\n          },\n          {\n            selfBrowserSurface: n,\n            surfaceSwitching: s,\n            systemAudio: a,\n            preferCurrentTab: c,\n            windowAudio: d,\n            monitorTypeSurfaces: l\n          } = e.screen,\n          u = {\n            selfBrowserSurface: n,\n            surfaceSwitching: s,\n            systemAudio: a,\n            preferCurrentTab: c,\n            windowAudio: d,\n            monitorTypeSurfaces: l\n          };\n        !n && delete u.selfBrowserSurface, !s && delete u.surfaceSwitching, !a && delete u.systemAudio, !c && delete u.preferCurrentTab, !d && delete u.windowAudio, !l && delete u.monitorTypeSurfaces, iP.debug(\"[\".concat(t, \"] getDisplayMedia:\"), JSON.stringify({\n          video: i,\n          audio: e.screenAudio,\n          controls: u\n        })), DL(r, await navigator.mediaDevices.getDisplayMedia(cL({\n          video: i,\n          audio: e.screenAudio\n        }, u)));\n      } else {\n        if (!Bw()) throw iP.error(\"[\".concat(t, \"] This browser does not support screenSharing\")), new pO(hO.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n        {\n          e.screen.mediaSource && MP(e.screen.mediaSource);\n          const i = {\n            video: {\n              mediaSource: e.screen.mediaSource,\n              width: e.screen.width,\n              height: e.screen.height,\n              frameRate: e.screen.frameRate\n            }\n          };\n          iP.debug(\"[\".concat(t, \"] getUserMedia: \").concat(JSON.stringify(i))), DL(r, await navigator.mediaDevices.getUserMedia(i));\n        }\n      }\n      var s, a;\n      if (!e.video && !e.audio) return r;\n      let c = {\n          video: e.video,\n          audio: e.audio\n        },\n        d = CD(\"MEDIA_DEVICE_CONSTRAINTS\");\n      if (d) try {\n        \"string\" == typeof d && (d = JSON.parse(d)), c = yN(c, d);\n      } catch (e) {}\n      iP.debug(\"[\".concat(t, \"] GetUserMedia\"), JSON.stringify(c)), Dw();\n      let l,\n        u = null;\n      (Vw() || jw() || Mw()) && (u = await IL.lock());\n      try {\n        l = await navigator.mediaDevices.getUserMedia(c);\n      } catch (e) {\n        throw u && u(), e;\n      }\n      return c.audio && (AL = !0), c.video && (bL = !0), DL(r, l), u && u(), r;\n    }\n    function NL(e, t) {\n      switch (e) {\n        case \"Starting video failed\":\n        case \"OverconstrainedError\":\n        case \"TrackStartError\":\n          return new pO(hO.MEDIA_OPTION_INVALID, \"\".concat(e, \": \").concat(t));\n        case \"NotFoundError\":\n        case \"DevicesNotFoundError\":\n          return new pO(hO.DEVICE_NOT_FOUND, \"\".concat(e, \": \").concat(t));\n        case \"NotSupportedError\":\n          return new pO(hO.NOT_SUPPORTED, \"\".concat(e, \": \").concat(t));\n        case \"NotReadableError\":\n          return new pO(hO.NOT_READABLE, \"\".concat(e, \": \").concat(t));\n        case \"InvalidStateError\":\n        case \"NotAllowedError\":\n        case \"PERMISSION_DENIED\":\n        case \"PermissionDeniedError\":\n          return new pO(hO.PERMISSION_DENIED, \"\".concat(e, \": \").concat(t));\n        case \"ConstraintNotSatisfiedError\":\n          return new pO(hO.CONSTRAINT_NOT_SATISFIED, \"\".concat(e, \": \").concat(t));\n        default:\n          return iP.error(\"getUserMedia unexpected error\", e), new pO(hO.UNEXPECTED_ERROR, \"\".concat(e, \": \").concat(t));\n      }\n    }\n    function DL(e, t) {\n      const i = e.getVideoTracks()[0],\n        n = e.getAudioTracks()[0],\n        r = t.getVideoTracks()[0],\n        o = t.getAudioTracks()[0];\n      o && (n && e.removeTrack(n), e.addTrack(o)), r && (i && e.removeTrack(i), e.addTrack(r));\n    }\n    const PL = new class extends NO {\n      get state() {\n        return this._state;\n      }\n      set state(e) {\n        e !== this._state && (this.emit(eL.STATE_CHANGE, e), this._state = e);\n      }\n      constructor() {\n        super(), sL(this, \"_state\", $P.IDLE), sL(this, \"isAccessMicrophonePermission\", !1), sL(this, \"isAccessCameraPermission\", !1), sL(this, \"lastAccessMicrophonePermission\", !1), sL(this, \"lastAccessCameraPermission\", !1), sL(this, \"checkdeviceMatched\", !1), sL(this, \"deviceInfoMap\", new Map()), this.init().then(() => {\n          navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener(\"devicechange\", this.updateDevicesInfo.bind(this)), window.setInterval(() => {\n            (CD(\"ENUMERATE_DEVICES_INTERVAL\") || (aO() || Lw() === Aw.HARMONY_OS) && sO()) && this.updateDevicesInfo();\n          }, CD(\"ENUMERATE_DEVICES_INTERVAL_TIME\"));\n        }).catch(e => iP.error(e.toString()));\n      }\n      async enumerateDevices(e, t) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) throw new pO(hO.NOT_SUPPORTED, \"enumerateDevices() not supported.\");\n        const n = await navigator.mediaDevices.enumerateDevices(),\n          r = this.checkMediaDeviceInfoIsOk(n);\n        let o = !this.isAccessMicrophonePermission && e,\n          s = !this.isAccessCameraPermission && t;\n        r.audio && (o = !1), r.video && (s = !1);\n        let a = null,\n          c = null,\n          d = null;\n        if (!i && (o || s)) {\n          if (IL.isLocked && (iP.debug(\"[device manager] wait GUM lock\"), (await IL.lock())(), iP.debug(\"[device manager] GUM unlock\")), AL && (o = !1, this.isAccessMicrophonePermission = !0), bL && (s = !1, this.isAccessCameraPermission = !0), iP.debug(\"[device manager] check media device permissions\", e, t, o, s), o && s) {\n            try {\n              d = await navigator.mediaDevices.getUserMedia({\n                audio: !0,\n                video: !0\n              });\n            } catch (e) {\n              const t = NL(e.name || e.code || e, e.message);\n              if (t.code === hO.PERMISSION_DENIED) throw t;\n              iP.warning(\"getUserMedia failed in getDevices\", t);\n            }\n            this.isAccessCameraPermission = !0, this.isAccessMicrophonePermission = !0;\n          } else if (o) {\n            try {\n              a = await navigator.mediaDevices.getUserMedia({\n                audio: e\n              });\n            } catch (e) {\n              const t = NL(e.name || e.code || e, e.message);\n              if (t.code === hO.PERMISSION_DENIED) throw t;\n              iP.warning(\"getUserMedia failed in getDevices\", t);\n            }\n            this.isAccessMicrophonePermission = !0;\n          } else if (s) {\n            try {\n              c = await navigator.mediaDevices.getUserMedia({\n                video: t\n              });\n            } catch (e) {\n              const t = NL(e.name || e.code || e, e.message);\n              if (t.code === hO.PERMISSION_DENIED) throw t;\n              iP.warning(\"getUserMedia failed in getDevices\", t);\n            }\n            this.isAccessCameraPermission = !0;\n          }\n          iP.debug(\"[device manager] mic permission\", e, \"cam permission\", t);\n        }\n        try {\n          const e = await navigator.mediaDevices.enumerateDevices();\n          return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null, e;\n        } catch (e) {\n          return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null, new pO(hO.ENUMERATE_DEVICES_FAILED, e.toString()).throw();\n        }\n      }\n      async getRecordingDevices() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audioinput\" === e.kind);\n      }\n      async getCamerasDevices() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        return (await this.enumerateDevices(!1, !0, e)).filter(e => \"videoinput\" === e.kind);\n      }\n      async getSpeakers() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audiooutput\" === e.kind);\n      }\n      searchDeviceIdByName(e) {\n        let t = null;\n        return this.deviceInfoMap.forEach(i => {\n          i.device.label === e && (t = i.device.deviceId);\n        }), t;\n      }\n      async getDeviceById(e) {\n        const t = (await this.enumerateDevices(!0, !0, !0)).find(t => t.deviceId === e);\n        if (!t) throw new pO(hO.DEVICE_NOT_FOUND, \"deviceId: \".concat(e));\n        return t;\n      }\n      async init() {\n        this.state = $P.INITING;\n        try {\n          await this.updateDevicesInfo(), this.state = $P.INITEND;\n        } catch (e) {\n          if (this.state = $P.IDLE, !(\"boolean\" == typeof isSecureContext ? isSecureContext : \"https:\" === location.protocol || \"file:\" === location.protocol || \"localhost\" === location.hostname || \"127.0.0.1\" === location.hostname || \"::1\" === location.hostname)) throw new pO(hO.WEB_SECURITY_RESTRICT, \"Your context is limited by web security, please try using https protocol or localhost.\");\n          throw iP.warning(\"Device Detection functionality cannot start properly.\", e.toString()), e;\n        }\n      }\n      async updateDevicesInfo() {\n        const e = await this.enumerateDevices(!0, !0, !0),\n          t = Date.now(),\n          i = [];\n        if (e[0] && e[0].label && !1 === this.checkdeviceMatched) {\n          this.checkdeviceMatched = !0;\n          const t = e.find(e => \"audioinput\" === e.kind && \"default\" === e.deviceId),\n            i = e.find(e => \"audiooutput\" === e.kind && \"default\" === e.deviceId);\n          t && i ? i.groupId === t.groupId ? iP.debug(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is the same group\")) : iP.debug(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is not the same group\")) : iP.debug(\"[device-check] default input or output not found\");\n        }\n        const n = this.checkMediaDeviceInfoIsOk(e);\n        if (e.forEach(e => {\n          if (!e.deviceId) return;\n          const n = this.deviceInfoMap.get(\"\".concat(e.kind, \"_\").concat(e.deviceId));\n          if (\"ACTIVE\" !== (n ? n.state : \"INACTIVE\")) {\n            const n = {\n              initAt: t,\n              updateAt: t,\n              device: e,\n              state: \"ACTIVE\"\n            };\n            this.deviceInfoMap.set(\"\".concat(e.kind, \"_\").concat(e.deviceId), n), i.push(n);\n          }\n          n && (n.updateAt = t);\n        }), this.deviceInfoMap.forEach((e, n) => {\n          \"ACTIVE\" === e.state && e.updateAt !== t && (e.state = \"INACTIVE\", i.push(e));\n        }), this.state !== $P.INITEND) return n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), void (n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0));\n        i.forEach(e => {\n          switch (e.device.kind) {\n            case \"audioinput\":\n              this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(eL.RECORDING_DEVICE_CHANGED, e);\n              break;\n            case \"videoinput\":\n              this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(eL.CAMERA_DEVICE_CHANGED, e);\n              break;\n            case \"audiooutput\":\n              this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(eL.PLAYOUT_DEVICE_CHANGED, e);\n          }\n        }), n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0);\n      }\n      checkMediaDeviceInfoIsOk(e) {\n        const t = e.filter(e => \"audioinput\" === e.kind),\n          i = e.filter(e => \"videoinput\" === e.kind),\n          n = {\n            audio: !1,\n            video: !1\n          };\n        for (const e of t) if (e.label && e.deviceId) {\n          n.audio = !0;\n          break;\n        }\n        for (const e of i) if (e.label && e.deviceId) {\n          n.video = !0;\n          break;\n        }\n        return n;\n      }\n    }();\n    let LL = !1;\n    const kL = new class extends NO {\n      constructor() {\n        super(...arguments), sL(this, \"onAutoplayFailed\", void 0), sL(this, \"onAudioAutoplayFailed\", void 0);\n      }\n    }();\n    function ML() {\n      if (LL) return CD(\"FLS_AUTOPLAY_EMITS\") ? (kL.onAutoplayFailed && kL.onAutoplayFailed(), kL.emit(\"autoplay-failed\")) : void 0;\n      {\n        const e = t => {\n          t.preventDefault(), LL = !1, cO() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0));\n        };\n        LL = !0, cO() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), iP.info(\"detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web\"), kL.onAutoplayFailed ? kL.onAutoplayFailed() : kL.onAudioAutoplayFailed ? iP.warning(\"AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\\n\\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\") : iP.warning(\"We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\\n\\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\\n\\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\"), kL.emit(\"autoplay-failed\");\n      }\n    }\n    function UL(e, t, i, n) {\n      if (!e) return;\n      const r = lP.getBaseInfoBySessionId(e);\n      if (!r) return;\n      const o = r.info,\n        s = Date.now(),\n        a = cL(cL({}, o), {}, {\n          vid: void 0 === o.vid ? 0 : Number(o.vid),\n          lts: s,\n          elapse: s - r.startTime,\n          cbRegistered: kL.onAutoplayFailed || kL.onAudioAutoplayFailed ? 1 : -1,\n          errorMsg: i,\n          mediaType: t,\n          trackId: n,\n          extend: void 0\n        });\n      lP.send({\n        type: aP.AUTOPLAY_FAILED,\n        data: a\n      }, !0);\n    }\n    const VL = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"error\"],\n      xL = new class {\n        constructor() {\n          sL(this, \"onAutoplayFailed\", void 0), sL(this, \"elementMap\", new Map()), sL(this, \"elementStateMap\", new Map()), sL(this, \"elementsNeedToResume\", []), sL(this, \"sinkIdMap\", new Map()), sL(this, \"autoResumeAfterInterruption\", e => rp.all(Array.from(this.elementMap.entries()).map(async t => {\n            let [i, n] = t;\n            const r = this.elementStateMap.get(i),\n              o = n.srcObject.getAudioTracks()[0],\n              s = o && o.readyState;\n            if (iP.debug(\"resume after interrupted, ele: \".concat(r, \" audio: \").concat(s, \" \").concat(e)), \"live\" === s) {\n              if (e) return n.pause(), n.play();\n              if (\"running\" === _L.curState) return $w() ? (n.pause(), n.play()) : r && \"paused\" === r ? n.play() : void 0;\n            }\n          }))), sL(this, \"autoResumeAfterInterruptionOnIOS15_16\", () => {\n            Array.from(this.elementMap.entries()).forEach(e => {\n              let [t, i] = e;\n              const n = i.srcObject.getAudioTracks()[0];\n              n && \"live\" === n.readyState && (iP.debug(\"auto resume after interruption inside autoResumeAfterInterruptionOnIOS15\"), i.pause(), i.play());\n            });\n          }), this.autoResumeAudioElement(), _L.on(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), _L.on(RP.STATE_CHANGE, () => {\n            jw() && \"suspended\" === _L.prevState && \"running\" === _L.curState && this.autoResumeAfterInterruption();\n          });\n        }\n        async setSinkID(e, t) {\n          const i = this.elementMap.get(e);\n          if (this.sinkIdMap.set(e, t), i) try {\n            await i.setSinkId(t);\n          } catch (e) {\n            throw new pO(hO.PERMISSION_DENIED, \"can not set sink id: \" + e.toString());\n          }\n        }\n        play(e, t, i, n) {\n          if (this.elementMap.has(t)) return;\n          const r = document.createElement(\"audio\");\n          r.autoplay = !0, r.srcObject = new MediaStream([e]), this.bindAudioElementEvents(t, r), this.elementMap.set(t, r), this.elementStateMap.set(t, tL.INIT), this.setVolume(t, i);\n          const o = this.sinkIdMap.get(t);\n          if (o) try {\n            r.setSinkId(o).catch(e => {\n              iP.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n            });\n          } catch (e) {\n            iP.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n          }\n          const s = r.play();\n          s && s.then && s.catch(e => {\n            n && UL(n, \"audio\", e.message, t), iP.warning(\"audio element play warning\", e.toString()), this.elementMap.has(t) && \"NotAllowedError\" === e.name && (iP.warning(\"detected audio element autoplay failed\"), this.elementsNeedToResume.push(r), oN(() => {\n              this.onAutoplayFailed && this.onAutoplayFailed(), ML();\n            }));\n          });\n        }\n        updateTrack(e, t) {\n          const i = this.elementMap.get(e);\n          i && (i.srcObject = new MediaStream([t]));\n        }\n        isPlaying(e) {\n          return this.elementMap.has(e) && \"playing\" === this.elementStateMap.get(e);\n        }\n        setVolume(e, t) {\n          const i = this.elementMap.get(e);\n          i && (t = Math.max(0, Math.min(100, t)), i.volume = t / 100);\n        }\n        getVolume(e) {\n          const t = this.elementMap.get(e);\n          return t ? t.volume : 0;\n        }\n        stop(e) {\n          const t = this.elementMap.get(e);\n          if (this.sinkIdMap.delete(e), !t) return;\n          const i = this.elementsNeedToResume.indexOf(t);\n          this.elementsNeedToResume.splice(i, 1), t.srcObject = null, t.remove(), this.elementMap.delete(e), this.elementStateMap.delete(e);\n        }\n        bindAudioElementEvents(e, t) {\n          VL.forEach(i => {\n            t.addEventListener(i, i => {\n              const n = this.elementStateMap.get(e),\n                r = \"pause\" === i.type ? \"paused\" : i.type;\n              if (iP.debug(\"[\".concat(e, \"] audio-element-status change \").concat(n, \" => \").concat(r)), \"error\" === i.type) {\n                const i = null == t ? void 0 : t.error;\n                i && iP.error(\"[\".concat(e, \"] media error, code: \").concat(i.code, \", message: \").concat(i.message));\n              }\n              this.elementStateMap.set(e, r);\n            });\n          });\n        }\n        getPlayerState(e) {\n          return this.elementStateMap.get(e) || \"uninit\";\n        }\n        autoResumeAudioElement() {\n          const e = () => {\n            this.elementsNeedToResume.forEach(e => {\n              e.play().then(e => {\n                iP.debug(\"Auto resume audio element success\");\n              }).catch(e => {\n                iP.warning(\"Auto resume audio element failed!\", e);\n              });\n            }), this.elementsNeedToResume = [];\n          };\n          new rp(e => {\n            document.body ? e() : window.addEventListener(\"load\", () => e());\n          }).then(() => {\n            cO() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0));\n          });\n        }\n      }();\n    function FL() {\n      return function (e, t, i) {\n        const n = i.value;\n        return \"function\" == typeof n && (i.value = function () {\n          this._isClosed && new pO(hO.INVALID_OPERATION, \"[\".concat(this.getTrackId(), \"] cannot operate a closed track\")).print(\"warning\", iP);\n          for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n          const r = n.apply(this, t);\n          return r instanceof rp ? new rp((e, t) => {\n            r.then(e).catch(t);\n          }) : r;\n        }), i;\n      };\n    }\n    class BL extends NO {\n      constructor(e) {\n        super(), sL(this, \"name\", \"VideoProcessorDestination\"), sL(this, \"ID\", \"0\"), sL(this, \"_source\", void 0), sL(this, \"videoContext\", void 0), sL(this, \"inputTrack\", void 0), this.videoContext = e;\n      }\n      get kind() {\n        return \"video\";\n      }\n      get enabled() {\n        return !0;\n      }\n      pipe() {\n        throw new pO(hO.NOT_SUPPORTED, \"VideoProcessor cannot pipe to any other Processor\");\n      }\n      unpipe() {\n        throw new pO(hO.NOT_SUPPORTED, \"VideoProcessor cannot unpipe to any other Processor\");\n      }\n      enable() {}\n      disable() {}\n      updateInput(e) {\n        if (e.context !== this.videoContext) throw new Error(\"ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\\nProbably you are making pipeline like this:\\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).\");\n        e.track && e.track !== this.inputTrack && (this.videoContext.chained = !0, this.inputTrack = e.track, this.emit(QP.ON_TRACK, e.track));\n      }\n      reset() {\n        this.inputTrack = void 0, this.videoContext.chained = !1, this.emit(QP.ON_TRACK, void 0);\n      }\n    }\n    class jL extends NO {\n      set chained(e) {\n        this._chained = e;\n      }\n      get chained() {\n        return this._chained;\n      }\n      constructor(e, t) {\n        super(), sL(this, \"constraintsMap\", new Map()), sL(this, \"statsRegistry\", []), sL(this, \"usageRegistry\", []), sL(this, \"trackId\", void 0), sL(this, \"direction\", void 0), sL(this, \"_chained\", !1), this.trackId = e, this.direction = t;\n      }\n      async getConstraints() {\n        return await zO(this, ZP.REQUEST_CONSTRAINTS);\n      }\n      async requestApplyConstraints(e, t) {\n        var i;\n        return iP.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(i = this.constraintsMap).call(i)));\n      }\n      async requestRevertConstraints(e) {\n        var t;\n        if (this.constraintsMap.has(e)) return iP.info(\"processor \".concat(e.name, \" requestRevertConstraints for \").concat(this.trackId)), this.constraintsMap.delete(e), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(t = this.constraintsMap).call(t)));\n      }\n      registerStats(e, t, i) {\n        this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n          processorName: e.name,\n          processorID: e.ID,\n          type: t,\n          cb: i\n        });\n      }\n      unregisterStats(e, t) {\n        const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n        -1 !== i && this.statsRegistry.splice(i, 1);\n      }\n      gatherStats() {\n        const e = [];\n        for (const {\n          processorID: t,\n          processorName: i,\n          type: n,\n          cb: r\n        } of this.statsRegistry) try {\n          const o = r();\n          e.push({\n            processorID: t,\n            processorName: i,\n            type: n,\n            stats: o\n          });\n        } catch (e) {\n          iP.error(new pO(hO.UNEXPECTED_ERROR, e.message));\n        }\n        return e;\n      }\n      registerUsage(e, t) {\n        this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n          processorID: e.ID,\n          processorName: e.name,\n          cb: t\n        });\n      }\n      unregisterUsage(e) {\n        const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n        -1 !== t && this.usageRegistry.splice(t, 1);\n      }\n      async gatherUsage() {\n        const e = [];\n        if (!this.chained) return [];\n        for (const {\n          cb: t\n        } of this.usageRegistry) try {\n          let i = t();\n          i instanceof rp && (i = await i), e.push(cL(cL({}, i), {}, {\n            direction: this.direction\n          }));\n        } catch (e) {\n          iP.error(\"gather extension usage error\", e);\n        }\n        return e;\n      }\n      getDirection() {\n        return this.direction;\n      }\n    }\n    class GL extends NO {\n      constructor(e) {\n        super(), sL(this, \"name\", \"AudioProcessorDestination\"), sL(this, \"ID\", \"0\"), sL(this, \"inputTrack\", void 0), sL(this, \"inputNode\", void 0), sL(this, \"audioProcessorContext\", void 0), sL(this, \"_source\", void 0), this.audioProcessorContext = e;\n      }\n      get kind() {\n        return \"audio\";\n      }\n      get enabled() {\n        return !0;\n      }\n      pipe() {\n        throw new pO(hO.NOT_SUPPORTED, \"AudioProcessorDestination cannot pipe to any other Processor\");\n      }\n      unpipe() {\n        throw new pO(hO.NOT_SUPPORTED, \"AudioProcessor cannot unpipe to any other Processor\");\n      }\n      enable() {}\n      disable() {}\n      reset() {\n        this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = !1, this.emit(QP.ON_TRACK, void 0), this.emit(QP.ON_NODE, void 0);\n      }\n      updateInput(e) {\n        if (e.context !== this.audioProcessorContext) throw new Error(\"ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).\");\n        e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = !0, this.inputTrack = e.track, this.emit(QP.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = !0, this.inputNode = e.node, this.emit(QP.ON_NODE, this.inputNode));\n      }\n    }\n    class WL extends NO {\n      set chained(e) {\n        this._chained = e;\n      }\n      get chained() {\n        return this._chained;\n      }\n      constructor(e, t, i) {\n        super(), sL(this, \"constraintsMap\", new Map()), sL(this, \"statsRegistry\", []), sL(this, \"audioContext\", void 0), sL(this, \"trackId\", void 0), sL(this, \"direction\", void 0), sL(this, \"usageRegistry\", []), sL(this, \"_chained\", !1), this.audioContext = e, this.trackId = t, this.direction = i;\n      }\n      async getConstraints() {\n        return zO(this, ZP.REQUEST_CONSTRAINTS);\n      }\n      getAudioContext() {\n        return this.audioContext;\n      }\n      async requestApplyConstraints(e, t) {\n        var i;\n        return iP.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(i = this.constraintsMap).call(i)));\n      }\n      async requestRevertConstraints(e) {\n        var t;\n        if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(t = this.constraintsMap).call(t)));\n      }\n      registerStats(e, t, i) {\n        this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n          processorName: e.name,\n          processorID: e.ID,\n          type: t,\n          cb: i\n        });\n      }\n      unregisterStats(e, t) {\n        const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n        -1 !== i && this.statsRegistry.splice(i, 1);\n      }\n      gatherStats() {\n        const e = [];\n        for (const {\n          processorID: t,\n          processorName: i,\n          type: n,\n          cb: r\n        } of this.statsRegistry) try {\n          const o = r();\n          e.push({\n            processorID: t,\n            processorName: i,\n            type: n,\n            stats: o\n          });\n        } catch (e) {\n          iP.error(new pO(hO.UNEXPECTED_ERROR, e.message));\n        }\n        return e;\n      }\n      registerUsage(e, t) {\n        this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n          processorID: e.ID,\n          processorName: e.name,\n          cb: t\n        });\n      }\n      unregisterUsage(e) {\n        const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n        -1 !== t && this.usageRegistry.splice(t, 1);\n      }\n      async gatherUsage() {\n        const e = [];\n        if (!this.chained) return [];\n        for (const {\n          cb: t\n        } of this.usageRegistry) try {\n          let i = t();\n          i instanceof rp && (i = await i), e.push(cL(cL({}, i), {}, {\n            direction: this.direction\n          }));\n        } catch (e) {\n          iP.error(\"gather extension usage error\", e);\n        }\n        return e;\n      }\n      getDirection() {\n        return this.direction;\n      }\n    }\n    class HL extends NO {\n      get isPlayed() {\n        return !0;\n      }\n      get isFreeze() {\n        return !1;\n      }\n      constructor() {\n        super(), sL(this, \"context\", void 0), sL(this, \"processSourceNode\", void 0), sL(this, \"outputTrack\", void 0), sL(this, \"processedNode\", void 0), sL(this, \"clonedTrack\", void 0), sL(this, \"outputNode\", void 0), this.outputNode = new KL();\n      }\n      setVolume() {}\n      createOutputTrack() {\n        throw new pO(hO.NOT_SUPPORTED, \"can not create output MediaStreamTrack when WebAudio disabled\");\n      }\n      getOriginVolumeLevel() {\n        return 0;\n      }\n      getAccurateVolumeLevel() {\n        return 0;\n      }\n      stopGetAudioBuffer() {}\n      startGetAudioBuffer() {}\n      play() {}\n      stop() {}\n      destroy() {}\n      updateTrack() {}\n      updateOriginTrack() {}\n      createMediaStreamSourceNode() {}\n    }\n    class KL {\n      disconnect() {}\n      connect() {}\n    }\n    function YL(e) {\n      return new rp((t, i) => {\n        let n = !1;\n        const r = document.createElement(\"video\");\n        r.setAttribute(\"autoplay\", \"\"), r.setAttribute(\"muted\", \"\"), r.muted = !0, r.autoplay = !0, r.setAttribute(\"playsinline\", \"\"), r.setAttribute(\"style\", \"position: fixed; top: 0; left: 0; width: 1px; height: 1px\"), document.body.appendChild(r);\n        const o = jw() ? \"canplay\" : \"playing\";\n        r.addEventListener(o, () => {\n          const e = r.videoWidth,\n            i = r.videoHeight;\n          !e && Bw() || (n = !0, r.srcObject = null, r.remove(), t([e, i]));\n        }), r.srcObject = new MediaStream([e]), r.play().catch(TN), setTimeout(() => {\n          n || (r.srcObject = null, r.remove(), t([r.videoWidth, r.videoHeight]));\n        }, 4e3);\n      });\n    }\n    function zL(e) {\n      const t = {};\n      e.facingMode && (t.facingMode = e.facingMode), e.cameraId && (t.deviceId = {\n        exact: e.cameraId\n      });\n      const i = OP(e.encoderConfig);\n      return null != i.width && (t.width = i.width), null != i.height && (t.height = i.height), !rO() && i.frameRate && (t.frameRate = i.frameRate), Fw() && \"object\" == typeof t.frameRate && (t.frameRate.max = 60), Bw() && (t.frameRate = {\n        ideal: 30,\n        max: 30\n      }), t;\n    }\n    function qL(e) {\n      const t = {};\n      return rO() || (void 0 !== e.AGC && (t.autoGainControl = e.AGC), void 0 !== e.AEC && (t.echoCancellation = e.AEC), void 0 !== e.ANS && (t.noiseSuppression = e.ANS, Uw() && e.ANS && (t.googHighpassFilter = e.ANS))), t;\n    }\n    function XL(e) {\n      const t = qL(e);\n      if (e.encoderConfig) {\n        const i = LP(e.encoderConfig);\n        t.channelCount = i.stereo ? 2 : 1, t.sampleRate = i.sampleRate, t.sampleSize = i.sampleSize;\n      }\n      return e.microphoneId && (t.deviceId = {\n        exact: e.microphoneId\n      }), aO() && (t.sampleRate = void 0), t;\n    }\n    const JL = e => {\n        const t = e._encoderConfig;\n        if (!t) return;\n        const {\n          frameRate: i,\n          width: n,\n          height: r\n        } = e.getMediaStreamTrackSettings();\n        let {\n          frameRate: o = i,\n          width: s = n,\n          height: a = r\n        } = t;\n        if (!o || !s || !a) return;\n        s = AN(s), a = AN(a), o = AN(o);\n        const {\n            max: c,\n            min: d\n          } = function (e, t, i) {\n            const n = 200 * Math.pow(i / 15, .6) * Math.pow(e * t / 640 / 360, .75);\n            return {\n              min: Math.floor(n),\n              max: Math.floor(4 * n)\n            };\n          }(s, a, o),\n          {\n            bitrateMax: l,\n            bitrateMin: u\n          } = t || {};\n        l || iP.debug(\"calculate bitrate: [w: \".concat(s, \", h: \").concat(a, \", fps: \").concat(o, \"] => [brMax: \").concat(l, \", brMin: \").concat(u, \"]\"));\n        const {\n          maxFramerate: h\n        } = CD(\"ENCODER_CONFIG_LIMIT\");\n        return h && \"number\" == typeof h && (o = Math.min(o, h)), {\n          frameRate: o,\n          bitrateMax: l || c,\n          bitrateMin: u || d,\n          scaleResolutionDownBy: 1,\n          scale: 0\n        };\n      },\n      QL = async (e, t, i) => await (async (e, t, i) => {\n        const n = function (e) {\n            const t = [];\n            for (let i = 0; i < e.length; i += 2) t.push(parseInt(e.slice(i, i + 2), 16));\n            return Uint8Array.from(t);\n          }(ON(\"\" + t + i)).slice(0, 16),\n          r = n.slice(0, 12),\n          o = await window.crypto.subtle.importKey(\"raw\", n, \"AES-GCM\", !0, [\"encrypt\"]);\n        return new Uint8Array(await window.crypto.subtle.encrypt({\n          name: \"AES-GCM\",\n          iv: r\n        }, o, e));\n      })(e.buffer, t, i),\n      ZL = e => {\n        const t = document.createElement(\"canvas\");\n        return t.width = 2, t.height = 2, new rp((i, n) => {\n          t.toBlob(async e => {\n            if (t.remove(), e) {\n              const n = await $L(e);\n              i({\n                buffer: n,\n                width: t.width,\n                height: t.height\n              });\n            } else n(new pO(hO.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n          }, e, 1);\n        });\n      },\n      $L = async e => {\n        const t = await e.arrayBuffer();\n        return new Uint8Array(t);\n      };\n    var ek, tk, ik, nk, rk, ok, sk, ak, ck, dk, lk, uk, hk, pk, _k, Ek, mk, fk, Sk, gk, Tk, Rk, Ck, vk, yk, Ik, Ak, bk, wk, Ok, Nk, Dk, Pk, Lk, kk, Mk, Uk, Vk, xk, Fk;\n    let Bk = (ek = dP({\n        argsMap: (e, t) => [e.getTrackId(), t],\n        throttleTime: 300\n      }), tk = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), ik = FL(), nk = LN(\"LocalAudioTrack\", \"_enabledMutex\"), rk = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), ok = FL(), sk = LN(\"LocalAudioTrack\", \"_enabledMutex\"), ak = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), ck = FL(), dk = FL(), lk = FL(), uk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), hk = FL(), pk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), _k = FL(), Ek = dP({\n        argsMap: e => [e.getTrackId()]\n      }), mk = dP({\n        argsMap: (e, t) => [e.getTrackId(), t.name]\n      }), fk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), oL((Sk = class extends lL {\n        get _source() {\n          return this.initWebAudio();\n        }\n        set _source(e) {\n          this._trackSource = e;\n        }\n        get processorContext() {\n          return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;\n        }\n        get processorDestination() {\n          return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;\n        }\n        get isPlaying() {\n          return this._useAudioElement ? xL.isPlaying(this.getTrackId()) : this._source.isPlayed;\n        }\n        get __className__() {\n          return \"LocalAudioTrack\";\n        }\n        constructor(e, t, i, n) {\n          super(e, i), sL(this, \"trackMediaType\", HP.AUDIO), sL(this, \"_encoderConfig\", void 0), sL(this, \"_trackSource\", void 0), sL(this, \"metadata\", []), sL(this, \"_enabled\", !0), sL(this, \"_volume\", 100), sL(this, \"_useAudioElement\", !0), sL(this, \"_bypassWebAudio\", !1), sL(this, \"processor\", void 0), sL(this, \"_processorContext\", void 0), sL(this, \"_processorDestination\", void 0), sL(this, \"_getOriginVolumeLevel\", void 0), this._encoderConfig = t, this._getOriginVolumeLevel = !!n, this._trackSource = new HL(), CD(\"DISABLE_WEBAUDIO\") && (this._bypassWebAudio = !0), CD(\"LOCAL_AUDIO_TRACK_USES_WEB_AUDIO\") && (this._useAudioElement = !1), Vw() && !pL ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();\n        }\n        setVolume(e) {\n          mO(e, \"volume\", 0, 1e3), this._volume = e, this._source.setVolume(e / 100), this._useAudioElement && xL.setVolume(this.getTrackId(), e);\n          try {\n            if (this._bypassWebAudio) return void iP.debug(\"[\".concat(this.getTrackId(), \"] setVolume returned because no pass through WebAudio.\"));\n            const e = this._source.createOutputTrack();\n            this._mediaStreamTrack !== e && (this._mediaStreamTrack = e, qO(this, UP.NEED_REPLACE_TRACK, this).then(() => {\n              iP.debug(\"[\".concat(this.getTrackId(), \"] replace web audio track success\"));\n            }).catch(e => {\n              iP.warning(\"[\".concat(this.getTrackId(), \"] replace web audio track failed\"), e);\n            }));\n          } catch (e) {}\n        }\n        getVolumeLevel() {\n          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();\n        }\n        async setPlaybackDevice(e) {\n          if (!this._useAudioElement || !_P()) throw new pO(hO.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n          await xL.setSinkID(this.getTrackId(), e);\n        }\n        async setEnabled(e, t, i) {\n          return this._setEnabled(e, t, i);\n        }\n        async _setEnabled(e, t, i) {\n          if (!i) {\n            if (e === this._enabled) return;\n            this.stateCheck(\"enabled\", e);\n          }\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), e) {\n            this._originMediaStreamTrack.enabled = !0;\n            try {\n              i || (this._enabled = !0), await qO(this, UP.NEED_ENABLE_TRACK, this), iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled to \").concat(e, \" success\"));\n            } catch (e) {\n              throw i || (this._enabled = !1), iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n            }\n          } else {\n            this._originMediaStreamTrack.enabled = !1, i || (this._enabled = !1);\n            try {\n              await qO(this, UP.NEED_DISABLE_TRACK, this);\n            } catch (e) {\n              throw i || (this._enabled = !0), iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n            }\n          }\n        }\n        async setMuted(e) {\n          e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, iP.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await qO(this, UP.NEED_MUTE_TRACK, this) : await qO(this, UP.NEED_UNMUTE_TRACK, this));\n        }\n        getStats() {\n          dN(() => {\n            iP.warning(\"[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead\");\n          }, \"localAudioTrackGetStatsWarning\");\n          return XO(this, UP.GET_STATS) || cL({}, YP);\n        }\n        setAudioFrameCallback(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n          if (!e) return this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n          this._source.startGetAudioBuffer(t), this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), this._source.on(KP.ON_AUDIO_BUFFER, t => e(t));\n        }\n        play() {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._useAudioElement ? (iP.debug(\"[\".concat(this.getTrackId(), \"] start audio playback in element\")), xL.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();\n        }\n        stop() {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._useAudioElement ? xL.stop(this.getTrackId()) : this._source.stop();\n        }\n        close() {\n          super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();\n        }\n        _updatePlayerSource() {\n          let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          iP.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xL.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n        }\n        async _updateOriginMediaStreamTrack(e, t) {\n          this._originMediaStreamTrack !== e && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop()), e.addEventListener(\"ended\", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this.processor && this._processorContext && this.processor.updateInput({\n            track: e,\n            context: this._processorContext\n          }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e));\n        }\n        renewMediaStreamTrack(e) {\n          return rp.resolve(void 0);\n        }\n        pipe(e) {\n          if (this._bypassWebAudio) throw new pO(hO.INVALID_OPERATION, \"Can not process AudioTrack when bypassWebAudio set to true.\");\n          if (this.processor === e) return e;\n          if (e._source) throw new pO(hO.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n          return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n            track: this._originMediaStreamTrack,\n            node: this._source.processSourceNode,\n            context: this.processorContext\n          }), e;\n        }\n        unpipe() {\n          var e;\n          if (!this.processor) return;\n          const t = this.processor;\n          null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n        }\n        bindProcessorDestinationEvents(e) {\n          e.on(QP.ON_TRACK, async e => {\n            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this));\n          }), e.on(QP.ON_NODE, e => {\n            this._source.processedNode = e;\n          });\n        }\n        unbindProcessorDestinationEvents(e) {\n          e.removeAllListeners(QP.ON_TRACK), e.removeAllListeners(QP.ON_NODE);\n        }\n        bindProcessorContextEvents(e) {\n          e.on(ZP.REQUEST_CONSTRAINTS, async e => {\n            e(this._originMediaStreamTrack.getSettings());\n          });\n        }\n        unbindProcessorContextEvents(e) {\n          e.removeAllListeners(ZP.REQUEST_CONSTRAINTS);\n        }\n        initWebAudio() {\n          return this._trackSource instanceof HL && (this._trackSource = new RL(this._mediaStreamTrack, !1, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;\n        }\n        initProcessor() {\n          const e = new WL(this._source.context, this.getTrackId(), \"local\"),\n            t = new GL(e);\n          return this._processorContext = e, this._processorDestination = t, this.bindProcessorContextEvents(e), this.bindProcessorDestinationEvents(t), this._source.on(KP.UPDATE_SOURCE, () => {\n            this.processor && this.processor.updateInput({\n              node: this._source.processSourceNode,\n              context: e\n            });\n          }), this._useAudioElement && (this._useAudioElement = !1, this.isPlaying && (xL.stop(this.getTrackId()), this._source.play()), qO(this, UP.NEED_REPLACE_MIXING_TRACK, this).then(() => {\n            iP.debug(\"[\".concat(this.getTrackId(), \"] replace from origin track to web audio track success\"));\n          }).catch(e => {\n            iP.warning(\"[\".concat(this.getTrackId(), \"] replace from origin track to web audio track failed\"), e);\n          })), {\n            processorContext: e,\n            processorDestination: t\n          };\n        }\n      }).prototype, \"setVolume\", [ek], Object.getOwnPropertyDescriptor(Sk.prototype, \"setVolume\"), Sk.prototype), oL(Sk.prototype, \"setPlaybackDevice\", [tk, ik], Object.getOwnPropertyDescriptor(Sk.prototype, \"setPlaybackDevice\"), Sk.prototype), oL(Sk.prototype, \"setEnabled\", [nk, rk, ok], Object.getOwnPropertyDescriptor(Sk.prototype, \"setEnabled\"), Sk.prototype), oL(Sk.prototype, \"setMuted\", [sk, ak, ck], Object.getOwnPropertyDescriptor(Sk.prototype, \"setMuted\"), Sk.prototype), oL(Sk.prototype, \"getStats\", [dk], Object.getOwnPropertyDescriptor(Sk.prototype, \"getStats\"), Sk.prototype), oL(Sk.prototype, \"setAudioFrameCallback\", [lk], Object.getOwnPropertyDescriptor(Sk.prototype, \"setAudioFrameCallback\"), Sk.prototype), oL(Sk.prototype, \"play\", [uk, hk], Object.getOwnPropertyDescriptor(Sk.prototype, \"play\"), Sk.prototype), oL(Sk.prototype, \"stop\", [pk, _k], Object.getOwnPropertyDescriptor(Sk.prototype, \"stop\"), Sk.prototype), oL(Sk.prototype, \"close\", [Ek], Object.getOwnPropertyDescriptor(Sk.prototype, \"close\"), Sk.prototype), oL(Sk.prototype, \"pipe\", [mk], Object.getOwnPropertyDescriptor(Sk.prototype, \"pipe\"), Sk.prototype), oL(Sk.prototype, \"unpipe\", [fk], Object.getOwnPropertyDescriptor(Sk.prototype, \"unpipe\"), Sk.prototype), Sk),\n      jk = (gk = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), Tk = FL(), Rk = LN(\"MicrophoneAudioTrack\", \"_enabledMutex\"), Ck = dP({\n        argsMap: (e, t, i) => [e.getTrackId(), t, i]\n      }), vk = FL(), yk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), oL((Ik = class extends Bk {\n        get __className__() {\n          return \"MicrophoneAudioTrack\";\n        }\n        constructor(e, t, i, n) {\n          super(e, t.encoderConfig ? LP(t.encoderConfig) : {}, n, CD(\"GET_VOLUME_OF_MUTED_AUDIO_TRACK\")), sL(this, \"_config\", void 0), sL(this, \"_deviceName\", \"default\"), sL(this, \"_constraints\", void 0), sL(this, \"_originalConstraints\", void 0), sL(this, \"_enabled\", !0), this._config = t, this._constraints = i, this._originalConstraints = i, this._deviceName = e.label, \"boolean\" == typeof t.bypassWebAudio && (this._bypassWebAudio = t.bypassWebAudio), ($w() || eO()) && _L.bindInterruptDetectorTrack(this);\n        }\n        async setDevice(e) {\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] start set device to \").concat(e)), this._enabled) try {\n            const t = await PL.getDeviceById(e),\n              i = {};\n            i.audio = cL({}, this._constraints), i.audio.deviceId = {\n              exact: e\n            }, this._originMediaStreamTrack.stop();\n            let n = null;\n            try {\n              n = await wL(i, this.getTrackId());\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), n = await wL({\n                audio: this._constraints\n              }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), e;\n            }\n            await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n              exact: e\n            };\n          } catch (e) {\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n          } else try {\n            const t = await PL.getDeviceById(e);\n            this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n              exact: e\n            };\n          } catch (e) {\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n          }\n          iP.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e, \" success\"));\n        }\n        async setEnabled(e, t, i) {\n          if (t) return iP.debug(\"[\".concat(this.getTrackId(), \"] setEnabled false (do not close microphone)\")), await super._setEnabled(e);\n          if (!i) {\n            if (e === this._enabled) return;\n            this.stateCheck(\"enabled\", e);\n          }\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), CD(\"AUTO_RESET_AUDIO_ROUTE\") && (jw() || iO())) {\n            const t = navigator.audioSession;\n            t && (e || (t.type = \"playback\"), t.type = \"auto\");\n          }\n          if (!e) {\n            var n;\n            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n = this._source.clonedTrack) || void 0 === n || n.stop(), i || (this._enabled = !1);\n            try {\n              await qO(this, UP.NEED_DISABLE_TRACK, this);\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled false failed\"), e.toString()), e;\n            }\n            return;\n          }\n          const r = cL({}, this._constraints),\n            o = PL.searchDeviceIdByName(this._deviceName);\n          o && !r.deviceId && (r.deviceId = o);\n          try {\n            i || (this._enabled = !0);\n            const e = await wL({\n              audio: this._constraints\n            }, this.getTrackId());\n            await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1), await qO(this, UP.NEED_ENABLE_TRACK, this);\n          } catch (e) {\n            throw i || (this._enabled = !1), iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled true failed\"), e.toString()), e;\n          }\n          iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled success\"));\n        }\n        close() {\n          super.close(), ($w() || eO()) && _L.unbindInterruptDetectorTrack(this), kP.some(e => function (e) {\n            return \"__className__\" in e && \"MicrophoneAudioTrack\" === e.__className__;\n          }(e)) || hL && hL() && (lP.reportApiInvoke(null, {\n            name: \"BG_AUDIO_TAG_RESTART\",\n            options: {},\n            tag: kO.TRACER\n          }).onSuccess(), iP.debug(\"restart background audio tag success\"));\n        }\n        onTrackEnded() {\n          if ((jw() || iO()) && this._enabled && !this._isClosed && _L.duringInterruption) {\n            const e = async () => {\n              _L.off(RP.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (iP.debug(\"[\".concat(this.getTrackId(), \"] try capture microphone media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n            };\n            _L.on(RP.IOS_INTERRUPTION_END, e);\n          } else iP.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(GP.TRACK_ENDED);\n        }\n        async renewMediaStreamTrack(e) {\n          const t = e || this._constraints,\n            i = PL.searchDeviceIdByName(this._deviceName);\n          if (i && !t.deviceId && (t.deviceId = i), this._constraints = t, this._enabled) {\n            this._originMediaStreamTrack.stop();\n            const e = await wL({\n              audio: this._constraints\n            }, this.getTrackId());\n            await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !0);\n          }\n        }\n        bindProcessorContextEvents(e) {\n          super.bindProcessorContextEvents(e), e.on(ZP.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n            try {\n              const i = Object.assign({}, this._originalConstraints, ...e);\n              await this.renewMediaStreamTrack(i), t();\n            } catch (e) {\n              i(e);\n            }\n          });\n        }\n        unbindProcessorContextEvents(e) {\n          super.unbindProcessorContextEvents(e), e.removeAllListeners(ZP.REQUEST_UPDATE_CONSTRAINTS);\n        }\n      }).prototype, \"setDevice\", [gk, Tk], Object.getOwnPropertyDescriptor(Ik.prototype, \"setDevice\"), Ik.prototype), oL(Ik.prototype, \"setEnabled\", [Rk, Ck, vk], Object.getOwnPropertyDescriptor(Ik.prototype, \"setEnabled\"), Ik.prototype), oL(Ik.prototype, \"close\", [yk], Object.getOwnPropertyDescriptor(Ik.prototype, \"close\"), Ik.prototype), Ik),\n      Gk = (Ak = dP({\n        argsMap: (e, t) => [e.getTrackId(), t, e.duration]\n      }), bk = FL(), wk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), Ok = FL(), Nk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), Dk = FL(), Pk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), Lk = FL(), kk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), Mk = FL(), Uk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), Vk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), xk = FL(), oL((Fk = class extends Bk {\n        get __className__() {\n          return \"BufferSourceAudioTrack\";\n        }\n        constructor(e, t, i, n) {\n          super(t.createOutputTrack(), i, n), sL(this, \"source\", void 0), sL(this, \"_bufferSource\", void 0), this._useAudioElement = !1, this.source = e, this._bufferSource = t, this._bufferSource.on(KP.AUDIO_SOURCE_STATE_CHANGE, e => {\n            this.safeEmit(GP.SOURCE_STATE_CHANGE, e);\n          });\n          try {\n            this._mediaStreamTrack = this._source.createOutputTrack();\n          } catch (e) {}\n        }\n        get currentState() {\n          return this._bufferSource.currentState;\n        }\n        get duration() {\n          return this._bufferSource.duration;\n        }\n        get playbackSpeed() {\n          return this._bufferSource.playbackSpeed;\n        }\n        getCurrentTime() {\n          return this._bufferSource.currentTime;\n        }\n        startProcessAudioBuffer(e) {\n          e && this._bufferSource.updateOptions(e), this._bufferSource.startProcessAudioBuffer();\n        }\n        pauseProcessAudioBuffer() {\n          this._bufferSource.pauseProcessAudioBuffer();\n        }\n        seekAudioBuffer(e) {\n          this._bufferSource.seekAudioBuffer(e);\n        }\n        resumeProcessAudioBuffer() {\n          this._bufferSource.resumeProcessAudioBuffer();\n        }\n        stopProcessAudioBuffer() {\n          this._bufferSource.stopProcessAudioBuffer();\n        }\n        close() {\n          this.source = null, this._bufferSource.destroy(), super.close();\n        }\n        setAudioBufferPlaybackSpeed(e) {\n          mO(e, \"speed\", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e);\n        }\n      }).prototype, \"startProcessAudioBuffer\", [Ak, bk], Object.getOwnPropertyDescriptor(Fk.prototype, \"startProcessAudioBuffer\"), Fk.prototype), oL(Fk.prototype, \"pauseProcessAudioBuffer\", [wk, Ok], Object.getOwnPropertyDescriptor(Fk.prototype, \"pauseProcessAudioBuffer\"), Fk.prototype), oL(Fk.prototype, \"seekAudioBuffer\", [Nk, Dk], Object.getOwnPropertyDescriptor(Fk.prototype, \"seekAudioBuffer\"), Fk.prototype), oL(Fk.prototype, \"resumeProcessAudioBuffer\", [Pk, Lk], Object.getOwnPropertyDescriptor(Fk.prototype, \"resumeProcessAudioBuffer\"), Fk.prototype), oL(Fk.prototype, \"stopProcessAudioBuffer\", [kk, Mk], Object.getOwnPropertyDescriptor(Fk.prototype, \"stopProcessAudioBuffer\"), Fk.prototype), oL(Fk.prototype, \"close\", [Uk], Object.getOwnPropertyDescriptor(Fk.prototype, \"close\"), Fk.prototype), oL(Fk.prototype, \"setAudioBufferPlaybackSpeed\", [Vk, xk], Object.getOwnPropertyDescriptor(Fk.prototype, \"setAudioBufferPlaybackSpeed\"), Fk.prototype), Fk);\n    class Wk extends Bk {\n      get __className__() {\n        return \"MixingAudioTrack\";\n      }\n      get isActive() {\n        for (const e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return !0;\n        return !1;\n      }\n      constructor() {\n        const e = EL().createMediaStreamDestination();\n        super(e.stream.getAudioTracks()[0], void 0, SN(8, \"track-mix-\")), sL(this, \"trackList\", void 0), sL(this, \"destNode\", void 0), this._useAudioElement = !1;\n        try {\n          this._mediaStreamTrack = this._source.createOutputTrack();\n        } catch (e) {}\n        this.destNode = e, this.trackList = [];\n      }\n      hasAudioTrack(e) {\n        return -1 !== this.trackList.indexOf(e);\n      }\n      addAudioTrack(e) {\n        -1 === this.trackList.indexOf(e) ? (iP.debug(\"add \".concat(e.getTrackId(), \" to mixing track\")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : iP.debug(\"track \".concat(e.getTrackId(), \" is already added\"));\n      }\n      removeAudioTrack(e) {\n        if (-1 !== this.trackList.indexOf(e)) {\n          iP.debug(\"remove \".concat(e.getTrackId(), \" from mixing track\"));\n          try {\n            e._source.outputNode.disconnect(this.destNode);\n          } catch (e) {}\n          nN(this.trackList, e), this.updateEncoderConfig();\n        }\n      }\n      updateEncoderConfig() {\n        const e = {};\n        this.trackList.forEach(t => {\n          t._encoderConfig && ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = t._encoderConfig.bitrate), (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = t._encoderConfig.sampleRate), (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = t._encoderConfig.sampleSize), t._encoderConfig.stereo && (e.stereo = !0));\n        }), this._encoderConfig = e;\n      }\n      _updateRtpTransceiver(e) {\n        this._rtpTransceiver !== e && (this._rtpTransceiver = e, this.trackList.forEach(t => {\n          t instanceof Wk ? t.emit(jP.TRANSCEIVER_UPDATED, e) : t._updateRtpTransceiver(e);\n        }));\n      }\n    }\n    class Hk extends TL {\n      set currentState(e) {\n        e !== this._currentState && (this._currentState = e, this.safeEmit(KP.AUDIO_SOURCE_STATE_CHANGE, this._currentState));\n      }\n      get currentState() {\n        return this._currentState;\n      }\n      constructor(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        super(), sL(this, \"audioBuffer\", void 0), sL(this, \"sourceNode\", void 0), sL(this, \"startPlayTime\", 0), sL(this, \"startPlayOffset\", 0), sL(this, \"pausePlayTime\", 0), sL(this, \"options\", void 0), sL(this, \"currentLoopCount\", 0), sL(this, \"currentPlaybackSpeed\", 100), sL(this, \"_currentState\", \"stopped\"), this.audioBuffer = e, this.options = t, this.startPlayOffset = this.options.startPlayTime || 0;\n      }\n      createWebAudioDiagram() {\n        return this.context.createGain();\n      }\n      get duration() {\n        return this.audioBuffer ? this.audioBuffer.duration : 0;\n      }\n      get playbackSpeed() {\n        return this.currentPlaybackSpeed;\n      }\n      get currentTime() {\n        return this.audioBuffer ? \"stopped\" === this.currentState ? 0 : \"paused\" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;\n      }\n      updateOptions(e) {\n        \"stopped\" === this.currentState ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : iP.warning(\"can not set audio source options\");\n      }\n      startProcessAudioBuffer() {\n        this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = \"playing\";\n      }\n      pauseProcessAudioBuffer() {\n        this.sourceNode && \"playing\" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = \"paused\");\n      }\n      seekAudioBuffer(e) {\n        this.sourceNode && (this.sourceNode.onended = null, \"playing\" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), \"playing\" === this.currentState ? (this.startPlayOffset = e, this.startSourceNode()) : \"paused\" === this.currentState && (this.pausePlayTime = e));\n      }\n      resumeProcessAudioBuffer() {\n        \"paused\" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = \"playing\");\n      }\n      stopProcessAudioBuffer() {\n        if (this.sourceNode) {\n          this.sourceNode.onended = null;\n          try {\n            this.sourceNode.stop();\n          } catch (e) {}\n          this.reset();\n        }\n      }\n      destroy() {\n        this.audioBuffer = null, super.destroy();\n      }\n      setAudioBufferPlaybackSpeed(e) {\n        this.sourceNode && (\"playing\" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e / 100), this.currentPlaybackSpeed = e;\n      }\n      startSourceNode() {\n        this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));\n      }\n      createSourceNode() {\n        const e = this.context.createBufferSource();\n        return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e.playbackRate.value = this.currentPlaybackSpeed / 100, e;\n      }\n      handleSourceNodeEnded() {\n        if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();\n        this.reset();\n      }\n      reset() {\n        this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = \"stopped\", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;\n      }\n    }\n    const Kk = new Map();\n    function Yk(e, t) {\n      if (0 === e.length || 0 === t.length) return 1 / 0;\n      const i = wN(e),\n        n = wN(t);\n      return Math.floor(n / i);\n    }\n    class zk {\n      get rendFrameRate() {\n        const e = Math.max(1, Yk(this._render_interframe_delays_sizes, this._render_interframe_delays));\n        return Math.floor(1e3 / e);\n      }\n      get videoElementStatus() {\n        return this._isInPage ? this._videoElementStatus : tL.DESTROYED;\n      }\n      set videoElementStatus(e) {\n        e !== this._videoElementStatus && (iP.debug(\"[\".concat(this.trackId, \"] video-element-status change \").concat(this._videoElementStatus, \" => \").concat(e)), this._videoElementStatus = e);\n      }\n      get videoState() {\n        return this._videoState;\n      }\n      set videoState(e) {\n        var t;\n        e !== this._videoState && (this._videoState = e, null === (t = this.onVideoStateChanged) || void 0 === t || t.call(this, this.videoState));\n      }\n      constructor(e) {\n        sL(this, \"trackId\", void 0), sL(this, \"config\", void 0), sL(this, \"onFirstVideoFrameDecoded\", void 0), sL(this, \"onFirstVideoFrameRender\", void 0), sL(this, \"onVideoBufferReady\", void 0), sL(this, \"onVideoStateChanged\", void 0), sL(this, \"freezeTimeCounterList\", []), sL(this, \"renderFreezeAccTime\", 0), sL(this, \"renderFreezeAccTime2\", 0), sL(this, \"isKeepLastFrame\", !1), sL(this, \"isDestroyed\", !1), sL(this, \"timeUpdatedCount\", 0), sL(this, \"freezeTime\", 0), sL(this, \"playbackTime\", 0), sL(this, \"lastTimeUpdatedTime\", 0), sL(this, \"autoplayFailed\", !1), sL(this, \"videoTrack\", void 0), sL(this, \"videoElement\", void 0), sL(this, \"cacheVideoElement\", void 0), sL(this, \"cancelRVFId\", void 0), sL(this, \"internal\", !1), sL(this, \"_render_interframe_delays\", []), sL(this, \"_render_interframe_delays_sizes\", []), sL(this, \"_videoState\", iL.VideoStateStopped), sL(this, \"videoElementCheckInterval\", void 0), sL(this, \"videoElementFreezeTimeout\", void 0), sL(this, \"_videoElementStatus\", tL.NONE), sL(this, \"_isInPage\", !0), sL(this, \"isGettingVideoDimensions\", !1), sL(this, \"startGetVideoDimensions\", () => {\n          const e = () => {\n            if (this.isGettingVideoDimensions = !0, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return iP.debug(\"[\".concat(this.trackId, \"] current video dimensions:\"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1);\n            setTimeout(e, 500);\n          };\n          !this.isGettingVideoDimensions && e();\n        }), sL(this, \"autoResumeAfterInterruption\", () => {\n          this.videoTrack && \"live\" === this.videoTrack.readyState && \"running\" === _L.curState && (iP.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for \").concat(kw())), tO() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));\n        }), sL(this, \"handleVideoEvents\", e => {\n          switch (e.type) {\n            case \"play\":\n            case \"playing\":\n              \"play\" === e.type && iP.debug(\"[\".concat(this.trackId, \"] video element status: play\")), this.startGetVideoDimensions(), this.videoElementStatus = tL.PLAYING;\n              break;\n            case \"loadeddata\":\n              if (this.videoState = iL.VideoStateStarting, this.onFirstVideoFrameRender && this.onFirstVideoFrameRender(), this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {\n                try {\n                  this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();\n                } catch (e) {}\n                this.cacheVideoElement = void 0;\n              }\n              break;\n            case \"canplay\":\n              this.videoElementStatus = tL.CANPLAY;\n              break;\n            case \"stalled\":\n              this.videoElementStatus = tL.STALLED;\n              break;\n            case \"suspend\":\n              this.videoElementStatus = tL.SUSPEND;\n              break;\n            case \"pause\":\n              this.videoElementStatus = tL.PAUSED, jw() || iO() || Vw() && this.autoplayFailed || !this.videoTrack || \"live\" !== this.videoTrack.readyState || (iP.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume\")), this.videoElement.play());\n              break;\n            case \"waiting\":\n              this.videoElementStatus = tL.WAITING;\n              break;\n            case \"abort\":\n              this.videoElementStatus = tL.ABORT;\n              break;\n            case \"ended\":\n              this.videoElementStatus = tL.ENDED;\n              break;\n            case \"emptied\":\n              this.videoElementStatus = tL.EMPTIED;\n              break;\n            case \"error\":\n              {\n                const e = this.videoElement.error;\n                e && (this.videoElementStatus = tL.ERROR, iP.error(\"[\".concat(this.trackId, \"] media error: \").concat(e.message, \" (\").concat(e.code, \")\")));\n                break;\n              }\n            case \"timeupdate\":\n              {\n                const e = performance.now();\n                if (this.timeUpdatedCount += 1, this.onVideoBufferReady && this.timeUpdatedCount > CD(\"BUFFER_READY_FRAMES\") && this.onVideoBufferReady(), this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e);\n                const t = e - this.lastTimeUpdatedTime,\n                  i = this.lastTimeUpdatedTime;\n                if (this.lastTimeUpdatedTime = e, eU.lastVisibleTime < eU.lastHiddenTime || i < eU.lastHiddenTime || i < eU.lastVisibleTime) return;\n                if (this.isSkipCalcRenderFreezeTime()) return;\n                for (t > CD(\"VIDEO_FREEZE_DURATION\") && (this.freezeTime += t), this.playbackTime += t; this.playbackTime >= 6e3;) {\n                  this.playbackTime -= 6e3;\n                  const e = Math.min(6e3, this.freezeTime);\n                  this.freezeTimeCounterList.push(e), this.freezeTime = Math.max(0, this.freezeTime - 6e3);\n                }\n                break;\n              }\n          }\n        }), sL(this, \"autoResumeAfterInterruptionOnIOS15_16\", () => {\n          this.videoTrack && \"live\" === this.videoTrack.readyState && (iP.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for \").concat(kw())), tO() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));\n        }), this.trackId = e.trackId, this.config = e, e.element instanceof HTMLVideoElement ? this.videoElement = e.element : this.videoElement = document.createElement(\"video\"), _L.on(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);\n      }\n      getVideoElement() {\n        return this.videoElement;\n      }\n      getContainerElement() {\n        var e;\n        return null !== (e = this.videoElement.parentElement) && void 0 !== e ? e : void 0;\n      }\n      updateConfig(e) {\n        this.config = e, this.trackId = e.trackId, e.element !== this.videoElement && (this.destroy(), this.videoElement = e.element), this.videoTrack && this.initVideoElement();\n      }\n      updateVideoTrack(e) {\n        this.videoTrack !== e && (this.videoTrack = e, this.initVideoElement());\n      }\n      play(e) {\n        const t = this.videoElement.play();\n        t && t.catch && t.catch(t => {\n          e && UL(e, \"video\", t.message, this.trackId), \"NotAllowedError\" === t.name ? (iP.warning(\"detected video element autoplay failed\", t), this.autoplayFailed = !0, this.handleAutoPlayFailed()) : iP.warning(\"[\".concat(this.trackId, \"] play warning: \"), t);\n        });\n        const i = Dw();\n        if ((\"Safari\" === i.name && 15 === Number(i.version) || $w()) && t && t.then) {\n          const e = () => {\n            this.config.mirror && !this.config.noStyle && (this.videoElement.style.transform = \"rotateY(180deg)\");\n          };\n          t.then(e).catch(e);\n        }\n      }\n      getCurrentFrame() {\n        const e = document.createElement(\"canvas\");\n        e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;\n        const t = e.getContext(\"2d\");\n        if (!t) return iP.error(\"create canvas context failed!\"), new ImageData(2, 2);\n        t.drawImage(this.videoElement, 0, 0, e.width, e.height);\n        const i = t.getImageData(0, 0, e.width, e.height);\n        return e.remove(), i;\n      }\n      async getCurrentFrameToUint8Array(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n        const i = document.createElement(\"canvas\");\n        i.width = this.videoElement.videoWidth, i.height = this.videoElement.videoHeight;\n        const n = i.getContext(\"2d\");\n        return n ? (n.drawImage(this.videoElement, 0, 0, i.width, i.height), new rp((n, r) => {\n          i.toBlob(async e => {\n            if (i.remove(), e) {\n              const t = await $L(e);\n              n({\n                buffer: t,\n                width: i.width,\n                height: i.height\n              });\n            } else r(new pO(hO.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n          }, e, t < 0 ? .1 : t > 1 ? 1 : t);\n        })) : await ZL(e);\n      }\n      destroy() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        this.isDestroyed = !0, _L.off(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.off(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), e ? this.videoElement.pause() : this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = iL.VideoStateStopped;\n      }\n      initVideoElement() {\n        if (this.videoElementStatus = tL.INIT, !this.videoElementCheckInterval && (qk.forEach(e => {\n          this.videoElement.addEventListener(e, this.handleVideoEvents);\n        }), this.videoElementCheckInterval = window.setInterval(() => {\n          this._isInPage = function (e) {\n            return e !== document.body && document.body.contains(e);\n          }(this.videoElement);\n        }, 1e3), CD(\"ENABLE_VIDEO_FRAME_CALLBACK\"))) {\n          var e, t;\n          let i;\n          const n = () => {\n              \"visible\" === document.visibilityState && (document.removeEventListener(\"visibilitychange\", n), this.videoElementFreezeTimeout = window.setTimeout(r, CD(\"VIDEO_FREEZE_DURATION\")));\n            },\n            r = () => {\n              this.videoElementFreezeTimeout = void 0, this.videoState === iL.VideoStateDecoding && (\"visible\" === document.visibilityState ? this.videoState = iL.VideoStateFrozen : document.addEventListener(\"visibilitychange\", n));\n            },\n            o = (e, t) => {\n              if (this.videoElementStatus === tL.PLAYING) {\n                if (i) {\n                  const e = t.presentationTime - i.presentationTime,\n                    n = t.presentedFrames - i.presentedFrames;\n                  this._render_interframe_delays_sizes.push(n), this._render_interframe_delays.push(e);\n                  const o = wN(this._render_interframe_delays_sizes),\n                    s = o - this._render_interframe_delays_sizes[0];\n                  if (o > 30 && s > 5 && (this._render_interframe_delays_sizes.shift(), this._render_interframe_delays.shift()), this.videoState === iL.VideoStateStarting && (this.videoState = iL.VideoStateDecoding), this.videoState === iL.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r, CD(\"VIDEO_FREEZE_DURATION\"))), e < CD(\"VIDEO_FREEZE_DURATION\") && this.videoState === iL.VideoStateFrozen && (this.videoState = iL.VideoStateDecoding), e > CD(\"VIDEO_FREEZE_DURATION\") && eU.lastVisibleTime >= eU.lastHiddenTime && i.timestamp > eU.lastVisibleTime && i.timestamp > eU.lastHiddenTime) {\n                    const t = Math.min(66, Yk(this._render_interframe_delays_sizes, this._render_interframe_delays)),\n                      i = Math.max(0, e - (n - 1) * t);\n                    this.renderFreezeAccTime2 += i > t ? i : 0, this.renderFreezeAccTime += e;\n                  }\n                }\n                i = cL(cL({}, t), {}, {\n                  timestamp: e\n                });\n              } else this.isSkipCalcRenderFreezeTime() && (i = cL(cL({}, t), {}, {\n                timestamp: e\n              }));\n              var n, s;\n              CD(\"ENABLE_VIDEO_FRAME_CALLBACK\") && (this.cancelRVFId = null === (n = (s = this.videoElement).requestVideoFrameCallback) || void 0 === n ? void 0 : n.call(s, o));\n            };\n          this.cancelRVFId = null === (e = (t = this.videoElement).requestVideoFrameCallback) || void 0 === e ? void 0 : e.call(t, o);\n        }\n        this.videoElement.controls = !1, this.videoElement.setAttribute(\"playsinline\", \"\"), aO() && !CD(\"HIDE_NO_POSTER\") && (this.videoElement.poster = \"noposter\");\n        const i = Dw();\n        this.config.noStyle || (\"Safari\" === i.name && 15 === Number(i.version) || $w() || !this.config.mirror || (this.videoElement.style.transform = \"rotateY(180deg)\"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = \"cover\"), this.videoElement.setAttribute(\"muted\", \"\"), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Bw() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Bw() && this.videoElement.load());\n        const n = this.videoElement.play();\n        void 0 !== n && n.catch(e => {\n          iP.debug(\"[\".concat(this.trackId, \"] playback interrupted\"), e.toString());\n        });\n      }\n      resetVideoElement() {\n        var e, t;\n        qk.forEach(e => {\n          this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents);\n        }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.cancelRVFId && this.videoElement && (null === (e = (t = this.videoElement).cancelVideoFrameCallback) || void 0 === e || e.call(t, this.cancelRVFId), this.cancelRVFId = void 0), this.videoElementStatus = tL.NONE;\n      }\n      isSkipCalcRenderFreezeTime() {\n        return this.videoElementStatus === tL.DESTROYED || this.internal;\n      }\n      handleAutoPlayFailed() {\n        const e = t => {\n          t.preventDefault(), this.videoElement.play().then(() => {\n            iP.debug(\"[\".concat(this.trackId, \"] Video element for trackId:\").concat(this.trackId, \" autoplay resumed.\"));\n          }).catch(e => {\n            iP.error(e);\n          }), this.autoplayFailed = !1, cO() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0));\n        };\n        cO() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), ML();\n      }\n    }\n    const qk = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"timeupdate\", \"error\"];\n    class Xk extends zk {\n      constructor(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        super(e), sL(this, \"container\", void 0), sL(this, \"slot\", void 0), this.slot = e.element, this.internal = t, this.updateConfig(e);\n      }\n      updateConfig(e) {\n        this.config = e, this.trackId = e.trackId;\n        const t = e.element;\n        var i;\n        !this.internal || this.slot ? (t !== this.slot && (this.destroy(), this.slot = t), this.createElements()) : (this.slot = t, t && this.container ? (this.internal = !1, this.container.id = \"agora-video-player-\".concat(this.trackId), this.videoElement.id = \"video_\".concat(this.trackId), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = \"cover\", null === (i = this.slot) || void 0 === i || i.appendChild(this.container)) : this.createElements());\n      }\n      updateVideoTrack(e) {\n        this.videoTrack !== e && (this.videoTrack = e, this.createElements());\n      }\n      play(e) {\n        var t;\n        null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) && super.play(e);\n      }\n      getCurrentFrame() {\n        var e;\n        return null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);\n      }\n      async getCurrentFrameToUint8Array(e) {\n        var t;\n        let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n        return null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e, i) : await ZL(e);\n      }\n      destroy() {\n        if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement(\"video\"), this.container) {\n          try {\n            var e;\n            this.container.remove(), null === (e = this.slot) || void 0 === e || e.removeChild(this.container);\n          } catch (e) {}\n          this.container = void 0;\n        }\n      }\n      createElements() {\n        var e;\n        this.container || (this.container = document.createElement(\"div\")), this.container.id = \"agora-video-player-\".concat(this.trackId), this.container.style.width = \"100%\", this.container.style.height = \"100%\", this.container.style.position = \"relative\", this.container.style.overflow = \"hidden\", this.videoTrack ? (this.container.style.backgroundColor = \"black\", CD(\"KEEP_LAST_FRAME\") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), null === (e = this.slot) || void 0 === e || e.appendChild(this.container);\n      }\n      mountedVideoElement() {\n        var e;\n        !this.container || null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = \"video_\".concat(this.trackId), this.videoElement.className = \"agora_video_player\", this.videoElement.style.width = \"100%\", this.videoElement.style.height = \"100%\", this.videoElement.style.position = \"absolute\", this.videoElement.style.left = \"0\", this.videoElement.style.top = \"0\";\n      }\n      unmountedVideoElement() {\n        var e;\n        if (null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement)) {\n          super.resetVideoElement();\n          try {\n            this.container && this.container.removeChild(this.videoElement);\n          } catch (e) {}\n          this.videoElement = document.createElement(\"video\");\n        }\n      }\n      resetVideoElement() {\n        var e;\n        null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement(\"video\"));\n      }\n      getContainerElement() {\n        return this.container;\n      }\n    }\n    var Jk, Qk, Zk, $k, eM, tM, iM, nM, rM, oM, sM, aM, cM, dM, lM, uM, hM, pM, _M, EM, mM, fM, SM, gM, TM, RM, CM, vM, yM, IM, AM, bM, wM, OM, NM, DM, PM, LM;\n    let kM = (Jk = dP({\n        argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : t instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\", i]\n      }), Qk = FL(), Zk = dP({\n        argsMap: e => [e.getTrackId()]\n      }), $k = LN(\"LocalVideoTrack\", \"_enabledMutex\"), eM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), tM = FL(), iM = LN(\"LocalVideoTrack\", \"_enabledMutex\"), nM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), rM = FL(), oM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t, e._saveEncodeBitrateRatio]\n      }), sM = FL(), aM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), cM = FL(), dM = FL(), lM = dP({\n        argsMap: (e, t, i) => [e.getTrackId(), t, i]\n      }), uM = FL(), hM = FL(), pM = FL(), _M = dP({\n        argsMap: e => [e.getTrackId()]\n      }), EM = FL(), mM = FL(), fM = FL(), SM = FL(), gM = FL(), TM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t.name]\n      }), RM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), CM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), vM = dP({\n        argsMap: (e, t, i) => [e.getTrackId(), t.label, i]\n      }), yM = class e extends lL {\n        get videoHeight() {\n          if (Vw()) {\n            const {\n              height: e\n            } = this._mediaStreamTrack.getSettings();\n            return this._videoHeight = e, this._videoHeight;\n          }\n          return this._videoHeight;\n        }\n        get videoWidth() {\n          if (Vw()) {\n            const {\n              width: e\n            } = this._mediaStreamTrack.getSettings();\n            return this._videoWidth = e, this._videoWidth;\n          }\n          return this._videoWidth;\n        }\n        get isPlaying() {\n          return !(!this._player || this._player.videoElementStatus !== tL.PLAYING);\n        }\n        get processorDestination() {\n          return this._processorDestination;\n        }\n        get processorContext() {\n          return this._processorContext;\n        }\n        set processorContext(e) {\n          this._processorContext = e;\n        }\n        get __className__() {\n          return \"LocalVideoTrack\";\n        }\n        constructor(e, t, i, n, r, o) {\n          if (super(e, r), sL(this, \"trackMediaType\", HP.VIDEO), sL(this, \"_player\", void 0), sL(this, \"isUseScaleResolutionDownBy\", !1), sL(this, \"_videoVisibleTimer\", null), sL(this, \"_previousVideoVisibleStatus\", void 0), sL(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), sL(this, \"_encoderConfig\", void 0), sL(this, \"_scalabilityMode\", {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          }), sL(this, \"_optimizationMode\", void 0), sL(this, \"_saveEncodeBitrateRatio\", 1), sL(this, \"_videoHeight\", void 0), sL(this, \"_videoWidth\", void 0), sL(this, \"_forceBitrateLimit\", void 0), sL(this, \"_enabled\", !0), sL(this, \"_processorDestination\", void 0), sL(this, \"_processorContext\", void 0), Vw()) {\n            const {\n              width: t,\n              height: i\n            } = e.getSettings();\n            this._videoWidth = t, this._videoHeight = i;\n          } else this.updateMediaStreamTrackResolution();\n          if (this._scalabilityMode = i, this._optimizationMode = n, this._hints = o || [], t && -1 !== this._hints.indexOf(VP.CUSTOM_TRACK) ? this._encoderConfig = sN(t) : this._encoderConfig = t, -1 === this._hints.indexOf(VP.SCREEN_TRACK)) this.updateBitrateFromProfile();else if (Hw(bw.CHROME, 115) && -1 !== Lw().indexOf(\"Windows\")) {\n            const t = function (e, t) {\n              if (\"VideoFrame\" in window && \"TransformStream\" in window && pP().supportWebRTCInsertableStream) {\n                const i = new MediaStreamTrackProcessor(e),\n                  n = new MediaStreamTrackGenerator({\n                    kind: \"video\"\n                  });\n                let r,\n                  o,\n                  s = Date.now();\n                const a = () => {\n                  c && (clearInterval(c), c = void 0), r && (r.close(), r = void 0), e.stop(), o = void 0, n.removeEventListener(\"ended\", a);\n                };\n                let c = window.setInterval(() => {\n                  if (o && r && Date.now() - s > (null != t ? t : 1e3)) try {\n                    \"live\" === n.readyState ? o.enqueue(r.clone()) : a();\n                  } catch (e) {\n                    a();\n                  }\n                }, null != t ? t : 1e3);\n                const d = new TransformStream({\n                  transform: (e, t) => {\n                    \"live\" === n.readyState ? (o = t, s = Date.now(), void 0 === r ? (r = e, t.enqueue(e.clone())) : (t.enqueue(r), r = e)) : e.close();\n                  }\n                });\n                return n.addEventListener(\"ended\", a), i.readable.pipeThrough(d).pipeTo(n.writable), n;\n              }\n            }(e);\n            t && (iP.info(\"local screen video track begin to inject frame\"), this._mediaStreamTrack = t);\n          }\n          t && -1 !== this._hints.indexOf(VP.CUSTOM_TRACK) && this.setEncoderConfiguration(t), this._processorContext = new jL(this.getTrackId(), \"local\"), this._processorDestination = new BL(this.processorContext), this.bindProcessorDestinationEvents();\n        }\n        play(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n          if (\"string\" == typeof e) {\n            const t = document.getElementById(e);\n            t ? e = t : (iP.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n          }\n          iP.debug(\"[\".concat(this.getTrackId(), \"] start video playback in \").concat(e instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\"), JSON.stringify(t));\n          const i = cL(cL(cL({}, this._getDefaultPlayerConfig()), t), {}, {\n            trackId: this.getTrackId(),\n            element: e\n          });\n          this._player ? this._player.updateConfig(i) : (e instanceof HTMLVideoElement ? this._player = new zk(i) : this._player = new Xk(i), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n            try {\n              const e = this.getVideoElementVisibleStatus();\n              this.safeEmit(GP.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n            } catch (e) {}\n          }, CD(\"CHECK_VIDEO_VISIBLE_INTERVAL\"));\n        }\n        stop() {\n          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, iP.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n        }\n        async setEnabled(e, t) {\n          if (!t) {\n            if (e === this._enabled) return;\n            this.stateCheck(\"enabled\", e);\n          }\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), !e) {\n            this._originMediaStreamTrack.enabled = !1;\n            try {\n              await qO(this, UP.NEED_DISABLE_TRACK, this);\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n            }\n            return t || (this._enabled = !1), void iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n          }\n          this._originMediaStreamTrack.enabled = !0;\n          try {\n            await qO(this, UP.NEED_ENABLE_TRACK, this);\n          } catch (e) {\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n          }\n          iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n        }\n        async setMuted(e) {\n          e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, iP.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await qO(this, UP.NEED_MUTE_TRACK, this) : await qO(this, UP.NEED_UNMUTE_TRACK, this));\n        }\n        async setSaveEncodeBitrateRatio() {\n          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._saveEncodeBitrateRatio;\n          if (1 !== this._saveEncodeBitrateRatio && this._encoderConfig && this._encoderConfig.bitrateMax && this._encoderConfig.bitrateMin) {\n            this._encoderConfig.bitrateMin = Math.floor(this._encoderConfig.bitrateMin * e), this._encoderConfig.bitrateMax = Math.floor(this._encoderConfig.bitrateMax * e), iP.debug(\"[\".concat(this.getTrackId(), \"] set save encode bitrate ratio, \").concat(e)), this._saveEncodeBitrateRatio = 1;\n            try {\n              await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);\n            } catch (e) {\n              return e.throw(iP);\n            }\n          }\n        }\n        async setEncoderConfiguration(e, t) {\n          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n          if (e = OP(e), CD(\"USE_STANDARD_BITRATE_DEFAULT\") && (delete e.bitrateMax, delete e.bitrateMin), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), e.width || e.height || e.frameRate) {\n            const t = zL({\n              encoderConfig: e\n            });\n            (Vw() || jw() || iO()) && (t.deviceId = void 0), iP.debug(\"[\".concat(this.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), JSON.stringify(e), JSON.stringify(t));\n            try {\n              await this._originMediaStreamTrack.applyConstraints(t), this.updateMediaStreamTrackResolution();\n            } catch (e) {\n              const t = new pO(hO.UNEXPECTED_ERROR, e.toString());\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] applyConstraints error\"), t.toString()), t;\n            }\n          }\n          this._encoderConfig = e, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();\n          try {\n            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);\n          } catch (e) {\n            return e.throw(iP);\n          }\n        }\n        getStats() {\n          dN(() => {\n            iP.warning(\"[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead\");\n          }, \"localVideoTrackGetStatsWarning\");\n          return XO(this, UP.GET_STATS) || cL({}, zP);\n        }\n        async setBeautyEffect(e) {\n          iP.error(\"LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect\");\n        }\n        getCurrentFrameData() {\n          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n        }\n        async getCurrentFrameImage(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          return this._player ? this._player.getCurrentFrameToUint8Array(e, t) : await ZL(e);\n        }\n        async findClosestProfile() {\n          const {\n              width: e,\n              height: t,\n              frameRate: i\n            } = this.getMediaStreamTrackSettings(),\n            {\n              width: n,\n              height: r,\n              frameRate: o\n            } = this._encoderConfig || {},\n            s = AN(this._videoWidth || e || n || 0),\n            a = AN(this._videoHeight || t || r || 0),\n            c = function (e, t, i) {\n              if (!Array.isArray(CD(\"VIDEO_ENCODER_CONFIG_LIST\"))) return !1;\n              if (0 === CD(\"VIDEO_ENCODER_CONFIG_LIST\").length) return !1;\n              const n = Math.min(e, t);\n              return !(n >= 480) && cL(cL({}, CD(\"VIDEO_ENCODER_CONFIG_LIST\").find(e => e.height > n)), {}, {\n                frameRate: i\n              });\n            }(s, a, AN(i || o || 15));\n          if (c) return iP.debug(\"[\".concat(this.getTrackId(), \"] find closest profile, \").concat(s, \"x\").concat(a, \" => \").concat(JSON.stringify(c))), this.setEncoderConfiguration(c);\n        }\n        async setBitrateLimit(e) {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] set bitrate limit, \").concat(JSON.stringify(e))), e && (this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate));\n        }\n        async setOptimizationMode(e) {\n          if (\"motion\" !== e && \"detail\" !== e && \"balanced\" !== e) return void iP.error(hO.INVALID_PARAMS, \"optimization mode must be motion, detail or balanced\");\n          const t = this._optimizationMode;\n          try {\n            this._optimizationMode = e, await qO(this, UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);\n          } catch (e) {\n            throw this._optimizationMode = t, iP.error(\"[\".concat(this.getTrackId(), \"] set optimization mode failed\"), e.toString()), e;\n          }\n          iP.info(\"[\".concat(this.getTrackId(), \"] set optimization mode success (\").concat(e, \")\"));\n        }\n        setScalabiltyMode(e) {\n          if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers) return iP.error(hO.INVALID_PARAMS, \"scalability mode currently not supported, no SVC.\"), void (this._scalabilityMode = {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          });\n          this._scalabilityMode = e, iP.info(\"[\".concat(this.getTrackId(), \"] set scalability mode success (\").concat(e, \")\"));\n        }\n        updateMediaStreamTrackResolution() {\n          YL(this._originMediaStreamTrack).then(e => {\n            let [t, i] = e;\n            this._videoHeight = i, this._videoWidth = t;\n          }).catch(TN);\n        }\n        _updatePlayerSource() {\n          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n        }\n        _getDefaultPlayerConfig() {\n          return {\n            fit: \"contain\"\n          };\n        }\n        async setSenderConfiguration(e) {\n          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n          iP.debug(\"[\".concat(this.getTrackId(), \"] setSenderConfiguration applyConstraints\"), JSON.stringify(e)), e = OP(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), this._encoderConfig = e, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();\n          try {\n            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);\n          } catch (e) {\n            return e.throw(iP);\n          }\n        }\n        updateBitrateFromProfile() {\n          if (!this._encoderConfig) return;\n          const {\n            width: e,\n            height: t,\n            frameRate: i\n          } = this.getMediaStreamTrackSettings();\n          if (!e || !t || !i) return;\n          const {\n            bitrateMax: n,\n            bitrateMin: r\n          } = this._encoderConfig;\n          if (null == r || null == n) {\n            const {\n              max: o,\n              min: s\n            } = function (e, t, i, n, r) {\n              const o = CD(\"BITRATE_ADAPTER_TYPE\");\n              if (\"DEFAULT_BITRATE\" === o) return {\n                min: n,\n                max: r\n              };\n              if (void 0 === r) {\n                const s = Math.floor(200 * Math.pow(i / 15, .6) * Math.pow(e * t / 640 / 360, .75));\n                r = \"STANDARD_BITRATE\" === o ? 4 * s : 2 * s, n = null != n ? n : s;\n              } else n = null != n ? n : Math.floor(r / 10);\n              return {\n                min: n,\n                max: r\n              };\n            }(e, t, i, r, n);\n            if (this._encoderConfig.bitrateMin = s, this._encoderConfig.bitrateMax = o, CD(\"VIDEO_STANDARD_BITRATE_VERSION\") && null == r && null == n) {\n              const [n, r] = function (e, t, i) {\n                const n = 4 * Math.floor(2e5 * Math.pow(i / 15, .6) * Math.pow(e * t / 230400, .75)),\n                  r = e * t,\n                  o = new Map([[19200, .9], [230400, .85], [518400, .75], [921600, .7], [2073600, .6], [3686400, .5]]),\n                  s = new Map([[230400, .95], [518400, .9], [921600, .85], [2073600, .8]]);\n                let a = pp(o).call(o).next().value,\n                  c = 1;\n                if (o.has(r)) a = o.get(r);else {\n                  var d;\n                  const e = Qp(d = Array.from(o.entries())).call(d, (e, t) => {\n                      let [i] = e,\n                        [n] = t;\n                      return i - n;\n                    }),\n                    t = e.find(e => {\n                      let [t] = e;\n                      return t > r;\n                    });\n                  if (t) {\n                    const i = e.indexOf(t);\n                    if (i > 0) {\n                      const n = e[i - 1],\n                        o = (r - n[0]) / (t[0] - n[0]);\n                      a = n[1] + o * (t[1] - n[1]);\n                    } else a = t[1];\n                  } else a = e[e.length - 1][1];\n                }\n                if (s.has(r)) c = s.get(r);else {\n                  var l;\n                  const e = Qp(l = Array.from(s.entries())).call(l, (e, t) => {\n                      let [i] = e,\n                        [n] = t;\n                      return i - n;\n                    }),\n                    t = e.find(e => {\n                      let [t] = e;\n                      return t > r;\n                    });\n                  if (t) {\n                    const i = e.indexOf(t);\n                    if (i > 0) {\n                      const n = e[i - 1],\n                        o = (r - n[0]) / (t[0] - n[0]);\n                      c = n[1] + o * (t[1] - n[1]);\n                    } else c = t[1];\n                  } else c = e[e.length - 1][1];\n                }\n                const u = CD(\"VIDEO_NEW_BITRATE_RATIO\");\n                u && u > 0 && (a = u / 100);\n                const h = Math.floor(n * a),\n                  p = Math.floor(65e4 * Math.pow(e * t / 230400, .5) * Math.pow(i / 15, .69));\n                let _ = h;\n                const E = CD(\"VIDEO_STANDARD_BITRATE_VERSION\");\n                return E && E > 0 && (1 === E ? _ = n : 2 === E ? _ = h : 3 === E && (_ = p)), [Math.floor(_ / 1e3), c];\n              }(e, t, i);\n              this._encoderConfig.bitrateMax = n, this._encoderConfig.bitrateMin = s ? Math.min(s, n) : n, this._saveEncodeBitrateRatio = r, iP.debug(\"[\".concat(this.getTrackId(), \"] update new bitrate from profile, [w: \").concat(e, \", h: \").concat(t, \", fps: \").concat(i, \"] => [brMax: \").concat(this._encoderConfig.bitrateMax, \", brMin: \").concat(this._encoderConfig.bitrateMin, \", save_bitrate_ratio: \").concat(this._saveEncodeBitrateRatio, \"]\"));\n            } else iP.debug(\"[\".concat(this.getTrackId(), \"] update bitrate from profile, [w: \").concat(e, \", h: \").concat(t, \", fps: \").concat(i, \"] => [brMax: \").concat(o, \", brMin: \").concat(s, \"]\")), this._saveEncodeBitrateRatio = 1;\n          }\n        }\n        getVideoElementVisibleStatus() {\n          try {\n            var e, t;\n            const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n              n = {\n                track: this,\n                element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n                slot: null == i ? void 0 : i.parentElement\n              },\n              {\n                element: r,\n                slot: o\n              } = n;\n            if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) {\n              const e = AO.checkOneElementVisible(r),\n                t = Object.assign({}, e);\n              if (t.visible !== this._previousVideoVisibleStatus) {\n                this._previousVideoVisibleStatus = t.visible;\n                const e = lP.reportApiInvoke(null, {\n                  tag: kO.TRACER,\n                  name: LO.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                  options: [this.getTrackId()]\n                });\n                t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n              }\n              return t;\n            }\n            return;\n          } catch (e) {\n            throw new pO(hO.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n          }\n        }\n        async renewMediaStreamTrack(e) {}\n        pipe(e) {\n          if (this.processor === e) return e;\n          if (e._source) throw new pO(hO.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n          return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n            track: this._originMediaStreamTrack,\n            context: this.processorContext\n          }), e;\n        }\n        unpipe() {\n          if (!this.processor) return;\n          const e = this.processor;\n          this.processor._source = void 0, this.processor = void 0, e.reset();\n        }\n        close() {\n          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();\n        }\n        clone(t) {\n          let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            n = this._encoderConfig;\n          t && (n = cL(cL({}, n), OP(t))), n = aN(n);\n          const r = SN(8, \"track-video-cloned-\"),\n            o = new e(i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n, aN(this._scalabilityMode), this._optimizationMode, r, aN(this._hints));\n          return t && n && o.setEncoderConfiguration(n), iP.debug(\"clone video track from \".concat(this.getTrackId(), \" to \").concat(r, \", clone \").concat(i)), o;\n        }\n        async replaceTrack(e, t) {\n          if (!(e instanceof MediaStreamTrack)) throw new pO(hO.INVALID_PARAMS, \"track should be an instance of MediaStreamTrack\");\n          if (\"video\" !== e.kind) throw new pO(hO.INVALID_PARAMS, \"track should be a video MediaStreamTrack\");\n          await this._updateOriginMediaStreamTrack(e, t, !0), this.updateMediaStreamTrackResolution();\n        }\n        sendSeiData(e) {\n          if (dN(() => {\n            lP.reportApiInvoke(null, {\n              name: LO.LOCAL_VIDEO_SEND_SEI_DATA,\n              options: [],\n              tag: kO.TRACER\n            }).onSuccess(\"\");\n          }, this._mediaStreamTrack.id || this.getTrackId()), !CD(\"ENABLE_VIDEO_SEI\") || !CD(\"ENABLE_ENCODED_TRANSFORM\")) return void iP.warning('To send/receive SEI, please call AgoraRTC.setParameter(\"ENABLE_VIDEO_SEI\", true) before instantiate IAgoraRtcClient');\n          if (e instanceof Uint8Array == 0) return new pO(hO.INVALID_PARAMS, \"Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.\").throw();\n          const t = this.getRTCRtpTransceiver();\n          if (!t) return void iP.warning(\"Video track is not published, SEI can not be send\");\n          const i = t.sender.getParameters();\n          if (0 === i.codecs.length) return;\n          const n = i.codecs[0].mimeType.toLocaleLowerCase();\n          \"video/h264\" === n || \"video/h265\" === n ? this.safeEmit(\"sei-to-send\", e) : iP.warning(\"SEI is not supported by \".concat(n));\n        }\n        bindProcessorDestinationEvents() {\n          this.processorDestination.on(QP.ON_TRACK, async e => {\n            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this));\n          });\n        }\n        unbindProcessorDestinationEvents() {\n          this.processorDestination.removeAllListeners(QP.ON_TRACK);\n        }\n        unbindProcessorContextEvents() {\n          this.processorContext.removeAllListeners(ZP.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(ZP.REQUEST_CONSTRAINTS);\n        }\n      }, oL(yM.prototype, \"play\", [Jk, Qk], Object.getOwnPropertyDescriptor(yM.prototype, \"play\"), yM.prototype), oL(yM.prototype, \"stop\", [Zk], Object.getOwnPropertyDescriptor(yM.prototype, \"stop\"), yM.prototype), oL(yM.prototype, \"setEnabled\", [$k, eM, tM], Object.getOwnPropertyDescriptor(yM.prototype, \"setEnabled\"), yM.prototype), oL(yM.prototype, \"setMuted\", [iM, nM, rM], Object.getOwnPropertyDescriptor(yM.prototype, \"setMuted\"), yM.prototype), oL(yM.prototype, \"setSaveEncodeBitrateRatio\", [oM, sM], Object.getOwnPropertyDescriptor(yM.prototype, \"setSaveEncodeBitrateRatio\"), yM.prototype), oL(yM.prototype, \"setEncoderConfiguration\", [aM, cM], Object.getOwnPropertyDescriptor(yM.prototype, \"setEncoderConfiguration\"), yM.prototype), oL(yM.prototype, \"getStats\", [dM], Object.getOwnPropertyDescriptor(yM.prototype, \"getStats\"), yM.prototype), oL(yM.prototype, \"setBeautyEffect\", [lM, uM], Object.getOwnPropertyDescriptor(yM.prototype, \"setBeautyEffect\"), yM.prototype), oL(yM.prototype, \"getCurrentFrameData\", [hM], Object.getOwnPropertyDescriptor(yM.prototype, \"getCurrentFrameData\"), yM.prototype), oL(yM.prototype, \"getCurrentFrameImage\", [pM], Object.getOwnPropertyDescriptor(yM.prototype, \"getCurrentFrameImage\"), yM.prototype), oL(yM.prototype, \"findClosestProfile\", [_M, EM], Object.getOwnPropertyDescriptor(yM.prototype, \"findClosestProfile\"), yM.prototype), oL(yM.prototype, \"setBitrateLimit\", [mM], Object.getOwnPropertyDescriptor(yM.prototype, \"setBitrateLimit\"), yM.prototype), oL(yM.prototype, \"setOptimizationMode\", [fM], Object.getOwnPropertyDescriptor(yM.prototype, \"setOptimizationMode\"), yM.prototype), oL(yM.prototype, \"setScalabiltyMode\", [SM], Object.getOwnPropertyDescriptor(yM.prototype, \"setScalabiltyMode\"), yM.prototype), oL(yM.prototype, \"updateMediaStreamTrackResolution\", [gM], Object.getOwnPropertyDescriptor(yM.prototype, \"updateMediaStreamTrackResolution\"), yM.prototype), oL(yM.prototype, \"pipe\", [TM], Object.getOwnPropertyDescriptor(yM.prototype, \"pipe\"), yM.prototype), oL(yM.prototype, \"unpipe\", [RM], Object.getOwnPropertyDescriptor(yM.prototype, \"unpipe\"), yM.prototype), oL(yM.prototype, \"close\", [CM], Object.getOwnPropertyDescriptor(yM.prototype, \"close\"), yM.prototype), oL(yM.prototype, \"replaceTrack\", [vM], Object.getOwnPropertyDescriptor(yM.prototype, \"replaceTrack\"), yM.prototype), yM),\n      MM = (IM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), AM = FL(), bM = LN(\"CameraVideoTrack\", \"_enabledMutex\"), wM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), OM = FL(), NM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), DM = FL(), PM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), LM = class e extends kM {\n        get __className__() {\n          return \"CameraVideoTrack\";\n        }\n        constructor(e, t, i, n, r, o) {\n          super(e, OP(t.encoderConfig), n, r, o), sL(this, \"_config\", void 0), sL(this, \"_originalConstraints\", void 0), sL(this, \"_constraints\", void 0), sL(this, \"_enabled\", !0), sL(this, \"_deviceName\", \"default\"), sL(this, \"tryResumeVideoForIOS15_16WeChat\", async () => {\n            ($w() || eO()) && !function () {\n              const e = Dw();\n              if (e.os !== Aw.IOS || !e.osVersion) return !1;\n              const t = e.osVersion.split(\".\");\n              return 15 === Number(t[0]) && Number(t[1]) >= 2;\n            }() && nO() && this._enabled && !this._isClosed && (iP.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS 15 device on WeChat.\")), await this.renewMediaStreamTrack());\n          }), this._config = t, this._originalConstraints = i, this._constraints = i, this._deviceName = e.label, this._encoderConfig = OP(this._config.encoderConfig), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _L.on(RP.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();\n        }\n        async setDevice(e) {\n          return \"string\" == typeof e ? this._setDeviceById(e) : e.deviceId ? this._setDeviceById(e.deviceId) : e.facingMode ? this._setDeviceByFacingModel(e.facingMode) : void 0;\n        }\n        async _setDeviceById(e) {\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e)), this._enabled) try {\n            const t = await PL.getDeviceById(e),\n              i = {};\n            i.video = cL({}, this._constraints), i.video.deviceId = {\n              exact: e\n            }, i.video.facingMode = void 0, this._originMediaStreamTrack.stop();\n            let n = null;\n            try {\n              n = await wL(i, this.getTrackId());\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), n = await wL({\n                video: this._constraints\n              }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), e;\n            }\n            await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution(), this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n              exact: e\n            };\n          } catch (e) {\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n          } else try {\n            const t = await PL.getDeviceById(e);\n            this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n              exact: e\n            };\n          } catch (e) {\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n          }\n          iP.info(\"[\".concat(this.getTrackId(), \"] setDevice success\"));\n        }\n        async _setDeviceByFacingModel(e) {\n          iP.info(\"[\".concat(this.getTrackId(), \"] set facingMode \").concat(e));\n          const t = {\n            video: cL(cL({}, this._constraints), {}, {\n              deviceId: void 0,\n              facingMode: {\n                exact: e\n              }\n            })\n          };\n          if (this._enabled) {\n            this._originMediaStreamTrack.stop();\n            let e = null;\n            try {\n              e = await wL(t, this.getTrackId());\n            } catch (t) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setDeviceByFacingModel failed\"), t.toString()), e = await wL({\n                video: this._constraints\n              }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1), t;\n            }\n            await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution();\n          }\n          this._deviceName = \"\", this._config.facingMode = e, this._config.cameraId = void 0, this._constraints = cL({}, t.video), iP.info(\"[\".concat(this.getTrackId(), \"] setDeviceByFacingModel success\"));\n        }\n        async setEnabled(e, t) {\n          if (!t) {\n            if (e === this._enabled) return;\n            this.stateCheck(\"enabled\", e);\n          }\n          if (iP.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), e) {\n            try {\n              if (this.isExternalTrack) this._originMediaStreamTrack.enabled = !0;else {\n                const e = await wL({\n                  video: this._constraints\n                }, this.getTrackId());\n                await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1);\n              }\n              await qO(this, UP.NEED_ENABLE_TRACK, this);\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled true error\"), e.toString()), e;\n            }\n            this.updateMediaStreamTrackResolution(), iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n          } else {\n            this.isExternalTrack ? this._originMediaStreamTrack.enabled = !1 : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t || (this._enabled = !1);\n            try {\n              await qO(this, UP.NEED_DISABLE_TRACK, this);\n            } catch (e) {\n              throw iP.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n            }\n            iP.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n          }\n        }\n        async setEncoderConfiguration(e, t) {\n          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n          e = OP(e), CD(\"USE_STANDARD_BITRATE_DEFAULT\") && (delete e.bitrateMax, delete e.bitrateMin), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate || e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate || e.bitrateMin);\n          const i = sN(this._config);\n          i.encoderConfig = e;\n          const n = zL(i);\n          (Vw() || jw() || iO()) && (n.deviceId = void 0), iP.debug(\"[\".concat(this.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), JSON.stringify(e), JSON.stringify(n));\n          try {\n            await this._originMediaStreamTrack.applyConstraints(n), this.updateMediaStreamTrackResolution();\n          } catch (e) {\n            const t = new pO(hO.UNEXPECTED_ERROR, e.toString());\n            throw iP.error(\"[\".concat(this.getTrackId(), \"] applyConstraints error\"), t.toString()), t;\n          }\n          this._config = i, this._constraints = n, this._originalConstraints = n, this._encoderConfig = e, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();\n          try {\n            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);\n          } catch (e) {\n            return e.throw(iP);\n          }\n        }\n        _getDefaultPlayerConfig() {\n          return {\n            mirror: !0,\n            fit: \"cover\"\n          };\n        }\n        onTrackEnded() {\n          if ((jw() || iO()) && this._enabled && !this._isClosed && _L.duringInterruption) {\n            const e = async () => {\n              _L.off(RP.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (iP.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n            };\n            _L.on(RP.IOS_INTERRUPTION_END, e);\n          } else iP.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(GP.TRACK_ENDED);\n        }\n        async renewMediaStreamTrack(e) {\n          const t = e || this._constraints,\n            i = PL.searchDeviceIdByName(this._deviceName);\n          if (i && !t.deviceId && (t.deviceId = {\n            exact: i\n          }), this._enabled) {\n            const e = await wL({\n              video: t\n            }, this.getTrackId());\n            this._constraints = t, await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !0), this.updateMediaStreamTrackResolution();\n          }\n        }\n        close() {\n          super.close(), _L.off(RP.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _L.off(RP.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);\n        }\n        clone(t) {\n          let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            n = this._encoderConfig;\n          t && (n = cL(cL({}, n), OP(t))), n = aN(n);\n          const r = SN(8, \"track-cam-cloned-\"),\n            o = new e(i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, aN(cL(cL({}, this._config), {}, {\n              encoderConfig: n\n            })), aN(this._constraints), aN(this._scalabilityMode), this._optimizationMode, r);\n          return t && n && o.setEncoderConfiguration(n), iP.debug(\"clone track from \".concat(this.getTrackId(), \" to \").concat(r, \", clone \").concat(i)), o;\n        }\n        bindProcessorContextEvents() {\n          this.processorContext.on(ZP.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n            try {\n              const i = Object.assign({}, this._originalConstraints, ...e);\n              await this.renewMediaStreamTrack(i), t();\n            } catch (e) {\n              i(e);\n            }\n          }), this.processorContext.on(ZP.REQUEST_CONSTRAINTS, async e => {\n            e(this._originMediaStreamTrack.getSettings());\n          });\n        }\n      }, oL(LM.prototype, \"setDevice\", [IM, AM], Object.getOwnPropertyDescriptor(LM.prototype, \"setDevice\"), LM.prototype), oL(LM.prototype, \"setEnabled\", [bM, wM, OM], Object.getOwnPropertyDescriptor(LM.prototype, \"setEnabled\"), LM.prototype), oL(LM.prototype, \"setEncoderConfiguration\", [NM, DM], Object.getOwnPropertyDescriptor(LM.prototype, \"setEncoderConfiguration\"), LM.prototype), oL(LM.prototype, \"close\", [PM], Object.getOwnPropertyDescriptor(LM.prototype, \"close\"), LM.prototype), LM);\n    function UM(e) {\n      const t = SN(8, \"track-cus-\"),\n        i = lP.reportApiInvoke(null, {\n          id: t,\n          tag: kO.TRACER,\n          name: LO.CREATE_CUSTOM_AUDIO_TRACK,\n          options: [e]\n        }),\n        n = new Bk(e.mediaStreamTrack, e.encoderConfig ? LP(e.encoderConfig) : {}, t, !1);\n      return iP.info(\"create custom audio track success with config\", e, \"trackId\", n.getTrackId()), i.onSuccess(n.getTrackId()), n;\n    }\n    function VM(e, t, i, n) {\n      i.optimizationMode && (n && n.width && n.height ? (i.encoderConfig = cL(cL({}, n), {}, {\n        bitrateMin: n.bitrateMin,\n        bitrateMax: n.bitrateMax\n      }), \"motion\" !== i.optimizationMode && \"detail\" !== i.optimizationMode || (t.contentHint = i.optimizationMode, t.contentHint === i.optimizationMode ? iP.debug(\"[\".concat(e, \"] set content hint to\"), i.optimizationMode) : iP.debug(\"[\".concat(e, \"] set content hint failed\")))) : iP.warning(\"[\".concat(e, \"] can not apply optimization mode bitrate config, no encoderConfig\")));\n    }\n    var xM, FM, BM, jM, GM, WM, HM, KM, YM, zM, qM, XM, JM;\n    class QM extends dL {\n      getUserId() {\n        return this._userId;\n      }\n      constructor(e, t, i, n) {\n        super(e, \"track-\".concat(e.kind, \"-\").concat(t, \"-\").concat(n.clientId, \"_\").concat(SN(5, \"\"))), sL(this, \"_userId\", void 0), sL(this, \"_uintId\", void 0), sL(this, \"_isDestroyed\", !1), sL(this, \"store\", void 0), sL(this, \"processor\", void 0), sL(this, \"processorContext\", void 0), this._userId = t, this._uintId = i, this.store = n;\n      }\n      _updateOriginMediaStreamTrack(e) {\n        this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this.processorContext\n        });\n      }\n      _destroy() {\n        this._isDestroyed = !0, iP.info(\"[\".concat(this.getTrackId(), \"] is destroyed\")), this.stop(), super.close();\n      }\n      getProcessorStats() {\n        return this.processorContext.gatherStats();\n      }\n      getProcessorUsage() {\n        return this.processorContext.gatherUsage();\n      }\n    }\n    let ZM = (xM = dP({\n        argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : t instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\", i]\n      }), FM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), BM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t.name]\n      }), jM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), oL((GM = class extends QM {\n        get isPlaying() {\n          return !(!this._player || this._player.videoElementStatus !== tL.PLAYING);\n        }\n        get __className__() {\n          return \"RemoteVideoTrack\";\n        }\n        constructor(e, t, i, n, r) {\n          super(e, t, i, n), sL(this, \"_videoVisibleTimer\", null), sL(this, \"_previousVideoVisibleStatus\", void 0), sL(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), sL(this, \"trackMediaType\", HP.VIDEO), sL(this, \"_videoWidth\", void 0), sL(this, \"_videoHeight\", void 0), sL(this, \"_player\", void 0), sL(this, \"_prePlayer\", void 0), sL(this, \"processorDestination\", void 0), sL(this, \"processorContext\", void 0), this._prePlayer = r, this.updateMediaStreamTrackResolution(), this.processorContext = new jL(this.getTrackId(), \"remote\"), this.processorDestination = new BL(this.processorContext), this.bindProcessorDestinationEvents();\n        }\n        getStats() {\n          return dN(() => {\n            iP.warning(\"[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead\");\n          }, \"remoteVideoTrackGetStatsWarning\"), XO(this, UP.GET_STATS) || cL({}, JP);\n        }\n        play(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n          if (this.safeEmit(WP.PLAY_START), \"string\" == typeof e) {\n            const t = document.getElementById(e);\n            t ? e = t : (iP.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n          }\n          iP.debug(\"[\".concat(this.getTrackId(), \"] start video playback in \").concat(e instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\"), JSON.stringify(t));\n          const i = cL(cL({\n            fit: \"cover\"\n          }, t), {}, {\n            trackId: this.getTrackId(),\n            element: e\n          });\n          if (this._player) this._player.updateConfig(i);else {\n            let t = !1,\n              n = !1;\n            e instanceof HTMLVideoElement ? (this._player = new zk(i), this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0, n = !0)) : this._prePlayer && !this._prePlayer.isDestroyed ? (this._player = this._prePlayer, this._prePlayer = void 0, t = this._player.videoState > 0, this._player.updateConfig(i)) : this._player = new Xk(i), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {\n              this.store.subscribe(this.getUserId(), \"video\", void 0, void 0, Date.now()), this.safeEmit(WP.FIRST_FRAME_DECODED), n && this.safeEmit(WP.FIRST_FRAME_RENDER);\n            }, this._player.onVideoStateChanged = e => {\n              this.safeEmit(WP.VIDEO_STATE_CHANGED, e);\n            }, t && (this._player.onFirstVideoFrameDecoded(), this._player.onVideoStateChanged(this._player.videoState));\n          }\n          this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n            try {\n              const e = this.getVideoElementVisibleStatus();\n              this.safeEmit(WP.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n            } catch (e) {}\n          }, CD(\"CHECK_VIDEO_VISIBLE_INTERVAL\")), this.safeEmit(WP.PLAY_END);\n        }\n        stop() {\n          let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(e), this._player = void 0, iP.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n        }\n        getCurrentFrameData() {\n          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n        }\n        updateMediaStreamTrackResolution() {\n          YL(this._originMediaStreamTrack).then(e => {\n            let [t, i] = e;\n            this._videoHeight = i, this._videoWidth = t;\n          }).catch(TN);\n        }\n        _updatePlayerSource() {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n        }\n        getVideoElementVisibleStatus() {\n          try {\n            var e, t;\n            const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n              n = {\n                track: this,\n                element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n                slot: null == i ? void 0 : i.parentElement\n              },\n              {\n                element: r,\n                slot: o\n              } = n;\n            if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) {\n              const e = AO.checkOneElementVisible(r),\n                t = Object.assign({}, e);\n              if (t.visible !== this._previousVideoVisibleStatus) {\n                this._previousVideoVisibleStatus = t.visible;\n                const e = lP.reportApiInvoke(null, {\n                  tag: kO.TRACER,\n                  name: LO.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                  options: [this.getTrackId()]\n                });\n                t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n              }\n              return t;\n            }\n            return;\n          } catch (e) {\n            throw new pO(hO.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n          }\n        }\n        pipe(e) {\n          if (this.processor === e) return e;\n          if (e._source) throw new pO(hO.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n          return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n            track: this._originMediaStreamTrack,\n            context: this.processorContext\n          }), e;\n        }\n        unpipe() {\n          if (!this.processor) return;\n          const e = this.processor;\n          this.processor._source = void 0, this.processor = void 0, e.reset();\n        }\n        bindProcessorDestinationEvents() {\n          this.processorDestination.on(QP.ON_TRACK, async e => {\n            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n          });\n        }\n        unbindProcessorDestinationEvents() {\n          this.processorDestination.removeAllListeners(QP.ON_TRACK);\n        }\n        _destroy() {\n          this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0), super._destroy(), this.unbindProcessorDestinationEvents();\n        }\n        _onSei(e) {\n          this.emit(jP.SEI_RECEIVED, e);\n        }\n      }).prototype, \"play\", [xM], Object.getOwnPropertyDescriptor(GM.prototype, \"play\"), GM.prototype), oL(GM.prototype, \"stop\", [FM], Object.getOwnPropertyDescriptor(GM.prototype, \"stop\"), GM.prototype), oL(GM.prototype, \"pipe\", [BM], Object.getOwnPropertyDescriptor(GM.prototype, \"pipe\"), GM.prototype), oL(GM.prototype, \"unpipe\", [jM], Object.getOwnPropertyDescriptor(GM.prototype, \"unpipe\"), GM.prototype), GM),\n      $M = (WM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t],\n        throttleTime: 300\n      }), HM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t],\n        throttleTime: 300\n      }), KM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t]\n      }), YM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), zM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), qM = dP({\n        argsMap: (e, t) => [e.getTrackId(), t.name]\n      }), XM = dP({\n        argsMap: e => [e.getTrackId()]\n      }), oL((JM = class extends QM {\n        get isPlaying() {\n          return this._useAudioElement ? xL.isPlaying(this.getTrackId()) : this._source.isPlayed;\n        }\n        get __className__() {\n          return \"RemoteAudioTrack\";\n        }\n        constructor(e, t, i, n) {\n          super(e, t, i, n), sL(this, \"trackMediaType\", HP.AUDIO), sL(this, \"_source\", void 0), sL(this, \"_useAudioElement\", !0), sL(this, \"_volume\", 100), sL(this, \"processorContext\", void 0), sL(this, \"processorDestination\", void 0), sL(this, \"_played\", !1), sL(this, \"_bypassWebAudio\", !1), CD(\"DISABLE_WEBAUDIO\") ? (this._source = new HL(), this._bypassWebAudio = !0, this._useAudioElement = !0) : (this._source = new RL(e, !0), CD(\"REMOTE_AUDIO_TRACK_USES_WEB_AUDIO\") && (this._useAudioElement = !1)), this._source.once(KP.RECEIVE_TRACK_BUFFER, () => {\n            this.safeEmit(WP.FIRST_FRAME_DECODED);\n          }), this.processorContext = new WL(this._source.context, this.getTrackId(), \"remote\"), this.processorDestination = new GL(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(KP.UPDATE_SOURCE, () => {\n            this.processor && this.processor.updateInput({\n              node: this._source.processSourceNode,\n              context: this.processorContext\n            });\n          });\n        }\n        setAudioFrameCallback(e) {\n          let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n          if (!e) return this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n          this._source.startGetAudioBuffer(t), this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), this._source.on(KP.ON_AUDIO_BUFFER, t => e(t));\n        }\n        setVolume(e) {\n          this._volume = e, this._useAudioElement ? xL.setVolume(this.getTrackId(), e) : this._source.setVolume(e / 100);\n        }\n        setAmplifiedVolume(e) {\n          this._useAudioElement && this._played && (xL.stop(this.getTrackId()), this._source.play()), this._useAudioElement = !1, e = Math.min(e, CD(\"MAX_WEBAUDIO_VOLUME\")), this._volume = e, this._source.setVolume(e / 100);\n        }\n        async setPlaybackDevice(e) {\n          if (!this._useAudioElement || !_P()) throw new pO(hO.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n          await xL.setSinkID(this.getTrackId(), e);\n        }\n        getVolumeLevel() {\n          return this._source.getAccurateVolumeLevel();\n        }\n        getVolume() {\n          return this._useAudioElement ? xL.getVolume(this.getTrackId()) : this._source instanceof RL ? this._source.getAudioVolume() : 0;\n        }\n        getStats() {\n          return dN(() => {\n            iP.warning(\"[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead\");\n          }, \"remoteAudioTrackGetStatsWarning\"), XO(this, UP.GET_STATS) || cL({}, qP);\n        }\n        play() {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._played = !0, this._useAudioElement ? (iP.debug(\"[\".concat(this.getTrackId(), \"] use audio element to play\")), xL.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : (iP.debug(\"[\".concat(this.getTrackId(), \"] use audio context to play\")), this._source.play());\n        }\n        stop() {\n          iP.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._played = !1, this._useAudioElement ? xL.stop(this.getTrackId()) : this._source.stop();\n        }\n        _destroy() {\n          super._destroy(), this._played = !1, this.unbindProcessorDestinationEvents(), this._source.destroy();\n        }\n        _isFreeze() {\n          return this._source.isFreeze;\n        }\n        _updatePlayerSource() {\n          let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n          iP.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xL.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n        }\n        pipe(e) {\n          if (this._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, \"can not pipe extension when WebAudio disabled\");\n          if (this.processor === e) return e;\n          if (e._source) throw new pO(hO.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n          return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n            track: this._originMediaStreamTrack,\n            node: this._source.processSourceNode,\n            context: this.processorContext\n          }), e;\n        }\n        unpipe() {\n          var e;\n          if (this._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, \"can not unpipe extension when WebAudio disabled\");\n          if (!this.processor) return;\n          const t = this.processor;\n          null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n        }\n        bindProcessorDestinationEvents() {\n          this.processorDestination.on(QP.ON_TRACK, async e => {\n            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n          }), this.processorDestination.on(QP.ON_NODE, e => {\n            this._source.processedNode = e;\n            const t = !e;\n            this._useAudioElement !== t && (this._played ? (this.stop(), this._useAudioElement = t, this.play()) : this._useAudioElement = t);\n          });\n        }\n        unbindProcessorDestinationEvents() {\n          this.processorDestination.removeAllListeners(QP.ON_TRACK), this.processorDestination.removeAllListeners(QP.ON_NODE);\n        }\n      }).prototype, \"setVolume\", [WM], Object.getOwnPropertyDescriptor(JM.prototype, \"setVolume\"), JM.prototype), oL(JM.prototype, \"setAmplifiedVolume\", [HM], Object.getOwnPropertyDescriptor(JM.prototype, \"setAmplifiedVolume\"), JM.prototype), oL(JM.prototype, \"setPlaybackDevice\", [KM], Object.getOwnPropertyDescriptor(JM.prototype, \"setPlaybackDevice\"), JM.prototype), oL(JM.prototype, \"play\", [YM], Object.getOwnPropertyDescriptor(JM.prototype, \"play\"), JM.prototype), oL(JM.prototype, \"stop\", [zM], Object.getOwnPropertyDescriptor(JM.prototype, \"stop\"), JM.prototype), oL(JM.prototype, \"pipe\", [qM], Object.getOwnPropertyDescriptor(JM.prototype, \"pipe\"), JM.prototype), oL(JM.prototype, \"unpipe\", [XM], Object.getOwnPropertyDescriptor(JM.prototype, \"unpipe\"), JM.prototype), JM);\n    const eU = new class extends NO {\n      get visibility() {\n        return document.visibilityState;\n      }\n      get lastHiddenTime() {\n        return this._lastHiddenTime;\n      }\n      get lastVisibleTime() {\n        return this._lastVisibleTime;\n      }\n      constructor() {\n        super(), sL(this, \"_lastHiddenTime\", 0), sL(this, \"_lastVisibleTime\", 0), sL(this, \"needUploadStats\", []), sL(this, \"isCollectingStats\", !1), document.addEventListener(\"visibilitychange\", () => {\n          \"hidden\" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), this.isCollectingStats && this.needUploadStats.push(\"visible\" === document.visibilityState ? 1 : 0), iP.debug(\"current web page is \".concat(document.visibilityState)), this.emit(\"VISIBILITY_CHANGE\", document.visibilityState);\n        });\n      }\n      startCollectStats() {\n        this.isCollectingStats = !0, this.needUploadStats.push(\"visible\" === this.visibility ? 1 : 0);\n      }\n      stopCollectStats() {\n        this.isCollectingStats = !1, this.needUploadStats.length = 0;\n      }\n    }();\n    class tU extends NO {\n      constructor(e, t) {\n        super(), sL(this, \"trackMediaType\", HP.DATA), sL(this, \"_version\", 1), sL(this, \"_type\", 3), sL(this, \"_config\", void 0), sL(this, \"_originDataChannel\", void 0), sL(this, \"_dataStreamPacketHeader\", new ArrayBuffer(4)), sL(this, \"_dataStreamPacketHandler\", {\n          serialize: e => e,\n          deserialize: e => e\n        }), sL(this, \"_datachannelEventMap\", new Map()), this._config = e, t && (this._originDataChannel = t, this._bandDataChannelEvents(t)), this._initPacketHeader();\n      }\n      useDataStream(e) {\n        this._dataStreamPacketHandler = e;\n      }\n      get id() {\n        return this._config.id;\n      }\n      get ordered() {\n        return this._config.ordered;\n      }\n      get maxRetransmits() {\n        return CD(\"DATASTREAM_MAX_RETRANSMITS\");\n      }\n      get metadata() {\n        return this._config.metadata;\n      }\n      get readyState() {\n        var e, t;\n        return null !== (e = null === (t = this._originDataChannel) || void 0 === t ? void 0 : t.readyState) && void 0 !== e ? e : \"connecting\";\n      }\n      get _originDataChannelId() {\n        var e, t;\n        return null !== (e = null === (t = this._originDataChannel) || void 0 === t ? void 0 : t.id) && void 0 !== e ? e : null;\n      }\n      getChannelId() {\n        return this.id;\n      }\n      getConfig() {\n        return this._config;\n      }\n      _close() {\n        this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);\n      }\n      async _waitTillOpen() {\n        return new rp((e, t) => {\n          if (this._originDataChannel) {\n            \"open\" === this._originDataChannel.readyState && e();\n            const i = setTimeout(() => {\n              var e;\n              t(new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT, \"Cannot create datachannel, id: \".concat(null === (e = this._originDataChannel) || void 0 === e ? void 0 : e.id)));\n            }, 1e4);\n            this._originDataChannel.onopen = () => {\n              clearTimeout(i), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e();\n            }, this._originDataChannel.onerror = () => {\n              throw clearTimeout(i), new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT);\n            };\n          } else t(new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT, \"cannot find dataChannel\"));\n        });\n      }\n      _updateOriginDataChannel(e) {\n        this._originDataChannel = e, this._bandDataChannelEvents(e);\n      }\n      _initPacketHeader() {\n        const e = new DataView(this._dataStreamPacketHeader);\n        e.setUint16(0, this._version), e.setUint8(2, this._type), e.setUint8(3, this._config.id);\n      }\n      _bandDataChannelEvents(e) {\n        this._unbindDataChannelEvents(e), [rL.OPEN, rL.CLOSE, rL.ERROR].forEach(t => {\n          const i = () => {\n            this.emit(t);\n          };\n          this._datachannelEventMap.set(t, i), e.addEventListener(t, i);\n        });\n      }\n      _unbindDataChannelEvents(e) {\n        Array.from(this._datachannelEventMap.entries()).forEach(t => {\n          let [i, n] = t;\n          e.removeEventListener(i, n);\n        }), this._datachannelEventMap.clear();\n      }\n    }\n    class iU extends tU {\n      constructor(e) {\n        super(e), sL(this, \"_messageListener\", void 0), this._messageListener = e => {\n          if (e.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error(\"invalid byteLength: the byte length must exceed \" + this._dataStreamPacketHeader.byteLength);\n          const t = e.data.slice(0, this._dataStreamPacketHeader.byteLength),\n            i = new DataView(t).getUint8(3);\n          if (i !== this.id) return void (CD(\"SHOW_DATASTREAM2_LOG\") && iP.debug(\"invalid datachannel id: \".concat(i, \" !== \").concat(this.id)));\n          let n = e.data.slice(this._dataStreamPacketHeader.byteLength);\n          n = this._dataStreamPacketHandler.deserialize(n), this.emit(rL.MESSAGE, n);\n        };\n      }\n      _updateOriginDataChannel(e) {\n        super._updateOriginDataChannel(e), this._bandRemoteDataChannelEvents();\n      }\n      _close() {\n        this._originDataChannel && (this._originDataChannel.removeEventListener(\"message\", this._messageListener), super._close());\n      }\n      _bandRemoteDataChannelEvents() {\n        this._originDataChannel && this._originDataChannel.addEventListener(\"message\", this._messageListener);\n      }\n    }\n    class nU extends tU {\n      send(e) {\n        if (this._originDataChannel) {\n          let t = e;\n          t = this._dataStreamPacketHandler.serialize(e);\n          const i = new Uint8Array(this._dataStreamPacketHeader.byteLength + t.byteLength);\n          i.set(new Uint8Array(this._dataStreamPacketHeader), 0), i.set(new Uint8Array(t), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i.buffer);\n        }\n      }\n    }\n    function rU() {\n      const e = new Blob([atob(\"Y29uc3QgdD0idmlkZW8vaDI2NCIsZT0idmlkZW8vaDI2NSI7ZnVuY3Rpb24gbih0LGUsbil7bGV0IGE9bmV3IFVpbnQ4QXJyYXkodCxlLG4pLHI9W10sbz0wO2Zvcig7ci5sZW5ndGg8bjspbyszPG4mJjA9PT1hW29dJiYwPT09YVtvKzFdJiYzPT09YVtvKzJdJiYoMD09PWFbbyszXXx8MT09PWFbbyszXXx8Mj09PWFbbyszXXx8Mz09PWFbbyszXSk/KHIucHVzaChhW29dLGFbbysxXSxhW28rM10pLG8rPTQpOihyLnB1c2goYVtvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocil9ZnVuY3Rpb24gYShhLHIpe3N3aXRjaChyKXtjYXNlIHQ6cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IERhdGFWaWV3KHQuZGF0YSk7bGV0IGE9MDtmb3IoO2ErNDx0LmRhdGEuYnl0ZUxlbmd0aDspe2lmKDA9PT1lLmdldFVpbnQ4KGErMCkmJjA9PT1lLmdldFVpbnQ4KGErMSkmJjA9PT1lLmdldFVpbnQ4KGErMikmJjE9PT1lLmdldFVpbnQ4KGErMykmJjY9PT1lLmdldFVpbnQ4KGErNCkpe2xldCByPWErNixvPTAsaT0wO2Zvcig7MjU1PT09KGk9ZS5nZXRVaW50OChyKyspKTspbys9MjU1O28rPWk7Y29uc3Qgcz1uKHQuZGF0YSxyLG8pO3JldHVybiBuZXcgVWludDhBcnJheShzKX1hKyt9cmV0dXJuIG51bGx9KGEpO2Nhc2UgZTpyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgRGF0YVZpZXcodC5kYXRhKTtsZXQgYT0wO2Zvcig7YSs1PHQuZGF0YS5ieXRlTGVuZ3RoOyl7aWYoMD09PWUuZ2V0VWludDgoYSswKSYmMD09PWUuZ2V0VWludDgoYSsxKSYmMD09PWUuZ2V0VWludDgoYSsyKSYmMT09PWUuZ2V0VWludDgoYSszKSYmNzg9PT1lLmdldFVpbnQ4KGErNCkmJjE9PT1lLmdldFVpbnQ4KGErNSkmJjEwMT09PWUuZ2V0VWludDgoYSs2KSl7bGV0IHI9YSs3LG89MCxpPTA7Zm9yKDsyNTU9PT0oaT1lLmdldFVpbnQ4KHIrKykpOylvKz0yNTU7bys9aTtjb25zdCBzPW4odC5kYXRhLHIsbyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHMpfWErK31yZXR1cm4gbnVsbH0oYSk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcih0KXtjb25zdCBlPXQubGVuZ3RoO2xldCBuPVtdLGE9MDtmb3IoO2E8ZTspYSsyPGUmJjA9PT10W2FdJiYwPT09dFthKzFdJiYoMD09PXRbYSsyXXx8MT09PXRbYSsyXXx8Mj09PXRbYSsyXXx8Mz09PXRbYSsyXSk/KG4ucHVzaCh0W2FdLHRbYSsxXSwzLHRbYSsyXSksYSs9Myk6KG4ucHVzaCh0W2FdKSxhKyspO3JldHVybiBuZXcgVWludDhBcnJheShuKX1mdW5jdGlvbiBvKG4sYSxvKXtzd2l0Y2gobyl7Y2FzZSB0OnJldHVybiBmdW5jdGlvbih0LGUpe2NvbnN0IG49cihlKSxhPW4ubGVuZ3RoLG89TWF0aC5mbG9vcihhLzI1NSksaT1hJTI1NSxzPW5ldyBVaW50OEFycmF5KDYrbysxK2ErdC5ieXRlTGVuZ3RoKTtzWzBdPTAsc1sxXT0wLHNbMl09MCxzWzNdPTEsc1s0XT02LHNbNV09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNitmXT0yNTUsZisrO3JldHVybiBzWzYrZl09aSxmKysscy5zZXQobiw2K2YpLHMuc2V0KG5ldyBVaW50OEFycmF5KHQpLDYrZithKSxzLmJ1ZmZlcn0obixhKTtjYXNlIGU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1yKGUpLGE9bi5sZW5ndGgsbz1NYXRoLmZsb29yKGEvMjU1KSxpPWElMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNytvKzErYSsxK3QuYnl0ZUxlbmd0aCk7c1swXT0wLHNbMV09MCxzWzJdPTAsc1szXT0xLHNbNF09Nzgsc1s1XT0xLHNbNl09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNytmXT0yNTUsZisrO3JldHVybiBzWzcrZl09aSxmKysscy5zZXQobiw3K2YpLGYrPWEsc1s3K2ZdPTEyOCxmKysscy5zZXQobmV3IFVpbnQ4QXJyYXkodCksNytmKSxzLmJ1ZmZlcn0obixhKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBpKG4pe2lmKG4ubGVuZ3RoPDUpcmV0dXJuIiI7bGV0IGE9LTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aC0zO3QrKyl7aWYoMD09PW5bdF0mJjA9PT1uW3QrMV0mJjE9PT1uW3QrMl0pe2E9dDticmVha31pZih0PG4ubGVuZ3RoLTQmJjA9PT1uW3RdJiYwPT09blt0KzFdJiYwPT09blt0KzJdJiYxPT09blt0KzNdKXthPXQ7YnJlYWt9fWlmKC0xPT09YSlyZXR1cm4iIjtjb25zdCByPWErKDA9PT1uW2ErMl0/NDozKTtpZihyPj1uLmxlbmd0aClyZXR1cm4iIjtjb25zdCBvPW5bcl07aWYoMTI4Jm8pcmV0dXJuIiI7aWYoKG8+PjEmNjMpPj0zMilyZXR1cm4gZTtpZihyKzE8bi5sZW5ndGgpe2lmKDA9PSgyNDgmbltyKzFdKSlyZXR1cm4gZX1yZXR1cm4oMzEmbyk8PTMxP3Q6IiJ9Y29uc3Qgcz03MSxmPTEsbD0yLHU9MSxnPTI7dmFyIGM7ZnVuY3Rpb24gZCh0LGU9ITEpe2NvbnN0IG49dC5nZXRVaW50OCgwKTtpZihuIT09cylyZXR1cm47Y29uc3QgYT10LmdldFVpbnQxNigxKSxyPWYrbCthLG89bmV3IFVpbnQ4QXJyYXkodC5ieXRlTGVuZ3RoLXIpO28uc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHIsdC5ieXRlTGVuZ3RoLXIpKTtjb25zdCBpPXttOm4sdGx2TGVuOmEsdGx2OltdLGZyYW1lOm99O2xldCBkPWYrbDtmb3IoO2Q8cjspe2NvbnN0IG49dC5nZXRVaW50OChkKSxhPXQuZ2V0VWludDE2KGQrdSkscj11K2c7aWYobj09PWMuQVVESU9fTEVWRUwpe2xldCBvPXQuZ2V0VWludDgoZCtyKTtmb3IobGV0IGU9MTtlPGE7ZSsrKW89bzw8OHx0LmdldFVpbnQ4KGQrcitlKTtpLnRsdi5wdXNoKHt0YWc6bixsZW5ndGg6YSx2YWx1ZTplPzEyN15vPj4xOjEyNyZvfSl9ZWxzZSBpZihuPT09Yy5NRVRBREFUQXx8bj09PWMuQVVESU9fNjRfQklUX1BUUyl7Y29uc3QgZT1uZXcgVWludDhBcnJheShhKTtmb3IobGV0IG49MDtuPGE7bisrKWVbbl09dC5nZXRVaW50OChkK3Irbik7aS50bHYucHVzaCh7dGFnOm4sbGVuZ3RoOmEsdmFsdWU6ZX0pfWQrPXIrYX1yZXR1cm4gaX0hZnVuY3Rpb24odCl7dFt0LkFVRElPX0xFVkVMPTFdPSJBVURJT19MRVZFTCIsdFt0Lk1FVEFEQVRBPTJdPSJNRVRBREFUQSIsdFt0LkFVRElPXzY0X0JJVF9QVFM9M109IkFVRElPXzY0X0JJVF9QVFMifShjfHwoYz17fSkpLHNlbGYub25ydGN0cmFuc2Zvcm09dD0+e2NvbnN0IGU9dC50cmFuc2Zvcm1lcixuPVtdLHI9W107bGV0IGg9bnVsbDtlLm9wdGlvbnMucG9ydC5vbm1lc3NhZ2U9dD0+e3QuZGF0YS5zZWkmJm4ucHVzaCh0LmRhdGEuc2VpKSx0LmRhdGEubWV0YWRhdGEmJnIucHVzaCh0LmRhdGEubWV0YWRhdGEpfSxzZWxmLnBvc3RNZXNzYWdlKCJzdGFydGVkIik7Y29uc3QgcD1lLnJlYWRhYmxlLmdldFJlYWRlcigpLFU9ZS53cml0YWJsZS5nZXRXcml0ZXIoKTsic2VpLXJ4Ij09PWUub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1pKG5ldyBVaW50OEFycmF5KG4udmFsdWUuZGF0YSkpLHI9YShuLnZhbHVlLHQpO2lmKHImJmUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHtzZWk6cn0pLCFoKXtjb25zdCB0PW4udmFsdWUuZ2V0TWV0YWRhdGEoKXx8e307aD17dHlwZTpuLnZhbHVlLnR5cGUscnRwVGltZXN0YW1wOm4udmFsdWUudGltZXN0YW1wLHBheWxvYWRUeXBlOnQucGF5bG9hZFR5cGV8fDAsc3NyYzp0LnN5bmNocm9uaXphdGlvblNvdXJjZXx8MCxsZW5ndGg6bi52YWx1ZS5kYXRhLmJ5dGVMZW5ndGgsLi4uIm1pbWVUeXBlImluIHQ/e21pbWVUeXBlOnQubWltZVR5cGV9Ont9fSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7Zmlyc3RGcmFtZUluZm86aH0pfX1VLndyaXRlKG4udmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToic2VpLXR4Ij09PWUub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigoYT0+e2lmKCFhLmRvbmUpe2lmKGEudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1pKG5ldyBVaW50OEFycmF5KGEudmFsdWUuZGF0YSkpLGU9bi5zaGlmdCgpO2lmKGUpe2NvbnN0IG49byhhLnZhbHVlLmRhdGEsZSx0KTtuJiYoYS52YWx1ZS5kYXRhPW4pfX1VLndyaXRlKGEudmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToiYXVkaW8tbWV0YWRhdGEtcngiPT09ZS5vcHRpb25zLm5hbWU/ZnVuY3Rpb24gdChlKXtwLnJlYWQoKS50aGVuKChuPT57aWYoIW4uZG9uZSl7aWYobi52YWx1ZSBpbnN0YW5jZW9mIFJUQ0VuY29kZWRBdWRpb0ZyYW1lKXtjb25zdCB0PW5ldyBEYXRhVmlldyhuLnZhbHVlLmRhdGEpLGE9dC5nZXRVaW50OCgwKTtsZXQgcjtpZigwIT0oMTI4JmEpJiY3MSE9PWEpe2NvbnN0IGU9ZnVuY3Rpb24odCl7aWYodC5ieXRlTGVuZ3RoPD0wKXJldHVybltdO2NvbnN0IGU9W107bGV0IG49MDtmb3IoO248dC5ieXRlTGVuZ3RoOyl7Y29uc3QgYT0oMTI4JnQuZ2V0VWludDgobikpPj43LHI9MTI3JnQuZ2V0VWludDgobik7aWYoIShhJiZuKzQ8PXQuYnl0ZUxlbmd0aCkpe24rKzticmVha317Y29uc3QgYT10LmdldFVpbnQzMihuLCExKSxvPSgxNjc3NjE5MiZhKT4+MTAsaT0xMDIzJmE7ZS5wdXNoKHtwdDpyLHRzX29mZnNldDpvLGxlbmd0aDppLGRhdGE6bmV3IFVpbnQ4QXJyYXl9KSxuKz00fX1sZXQgYT10LmJ5dGVMZW5ndGgtbjtmb3IoY29uc3QgciBvZiBlKXtpZihyLmxlbmd0aD5hKXJldHVybiBjb25zb2xlLndhcm4oIkJyb2tlbiByZWQgcGF5bG9hZCIpLFtdO3IubGVuZ3RoPjAmJihyLmRhdGE9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sci5sZW5ndGgpLG4rPXIubGVuZ3RoLGEtPXIubGVuZ3RoKX1pZihhPjApe2NvbnN0IHI9e3B0OmUubGVuZ3RoPjA/ZVtlLmxlbmd0aC0xXS5wdDowLHRzX29mZnNldDowLGxlbmd0aDphLGRhdGE6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sYSl9O2UucHVzaChyKX1yZXR1cm4gZX0odCk7aWYoZS5sZW5ndGg+MCl7Y29uc3QgdD1mdW5jdGlvbih0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUrPW48dC5sZW5ndGgtMT80OjEsZSs9dFtuXS5sZW5ndGg7Y29uc3Qgbj1uZXcgVWludDhBcnJheShlKTtsZXQgYT0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKGU8dC5sZW5ndGgtMSl7Y29uc3Qgcj0oMjE0NzQ4MzY0OHwoMTI3JnRbZV0ucHQpPDwyNHwoMjYyMTQzJnRbZV0udHNfb2Zmc2V0KTw8MTB8MTAyMyZ0W2VdLmxlbmd0aCk+Pj4wO25bYSsrXT1yPj4yNCYyNTUsblthKytdPXI+PjE2JjI1NSxuW2ErK109cj4+OCYyNTUsblthKytdPTI1NSZyfWVsc2UgblthKytdPTEyNyZ0W2VdLnB0O2Zvcihjb25zdCBlIG9mIHQpbi5zZXQoZS5kYXRhLGEpLGErPWUubGVuZ3RoO3JldHVybiBufShlLm1hcCgodD0+e2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO2Uuc2V0KHQuZGF0YSk7Y29uc3Qgbj1kKG5ldyBEYXRhVmlldyhlLmJ1ZmZlcikpO3JldHVybiBuPy5mcmFtZSYmKHQuZGF0YT1uPy5mcmFtZSkscj1uLHR9KSkpO24udmFsdWUuZGF0YT10LmJ1ZmZlcn19ZWxzZSByPWQodCksciYmKG4udmFsdWUuZGF0YT1yLmZyYW1lLmJ1ZmZlcik7aWYocil7bGV0IHQ9ci50bHYuZmluZCgodD0+dC50YWc9PT1jLk1FVEFEQVRBKSk7aWYodCYmdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHttZXRhZGF0YTp0LnZhbHVlfSksdD1yLnRsdi5maW5kKCh0PT50LnRhZz09PWMuQVVESU9fNjRfQklUX1BUUykpLHQmJnQudmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5JiY4PT10LnZhbHVlLmxlbmd0aCl7Y29uc3Qgbj1uZXcgRGF0YVZpZXcodC52YWx1ZS5idWZmZXIpLmdldEJpZ1VpbnQ2NCgwLCEwKTt0JiZ0LnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSYmZS5vcHRpb25zLnBvcnQucG9zdE1lc3NhZ2Uoe3B0czpufSl9fX1VLndyaXRlKG4udmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToiYXVkaW8tbWV0YWRhdGEtdHgiPT09ZS5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHtnZXRNZXRhZGF0YTohMH0pLG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkQXVkaW9GcmFtZSl7Y29uc3QgdD1yLnNoaWZ0KCk7dCYmKG4udmFsdWUuZGF0YT1mdW5jdGlvbih0LGUsbil7Y29uc3QgYT1uLmJ5dGVMZW5ndGgscj1hK3UrZyxvPWYrbCtyLGk9bmV3IEFycmF5QnVmZmVyKHQuYnl0ZUxlbmd0aCtvKSxjPW5ldyBEYXRhVmlldyhpKTtjLnNldFVpbnQ4KDAscyksYy5zZXRVaW50MTYoMSxyKSxjLnNldFVpbnQ4KDMsZSksYy5zZXRVaW50MTYoNCxhKTtmb3IobGV0IHQ9MDt0PGE7dCsrKWMuc2V0VWludDgoNit0LG5bdF0pO2NvbnN0IGQ9bmV3IFVpbnQ4QXJyYXkoYy5idWZmZXIpO3JldHVybiBkLnNldChuZXcgVWludDhBcnJheSh0KSxvKSxkLmJ1ZmZlcn0obi52YWx1ZS5kYXRhLGMuQVVESU9fNjRfQklUX1BUUyx0KSl9VS53cml0ZShuLnZhbHVlKSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSx0KGUpfX0pKX0oZSl9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKTsK\")], {\n        type: \"text/javascript\"\n      });\n      return setTimeout(() => vS.revokeObjectURL(e), 0), new Worker(vS.createObjectURL(e));\n    }\n    const oU = 71,\n      sU = 1,\n      aU = 2,\n      cU = 1,\n      dU = 2;\n    var lU = function (e) {\n      return e[e.AUDIO_LEVEL = 1] = \"AUDIO_LEVEL\", e[e.METADATA = 2] = \"METADATA\", e[e.AUDIO_64_BIT_PTS = 3] = \"AUDIO_64_BIT_PTS\", e;\n    }(lU || {});\n    function uU(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = e.getUint8(0);\n      if (i !== oU) return;\n      const n = e.getUint16(1),\n        r = sU + aU + n,\n        o = new Uint8Array(e.byteLength - r);\n      o.set(new Uint8Array(e.buffer, r, e.byteLength - r));\n      const s = {\n        m: i,\n        tlvLen: n,\n        tlv: [],\n        frame: o\n      };\n      let a = sU + aU;\n      for (; a < r;) {\n        const i = e.getUint8(a),\n          n = e.getUint16(a + cU),\n          r = cU + dU;\n        if (i === lU.AUDIO_LEVEL) {\n          let o = e.getUint8(a + r);\n          for (let t = 1; t < n; t++) o = o << 8 | e.getUint8(a + r + t);\n          s.tlv.push({\n            tag: i,\n            length: n,\n            value: t ? 127 ^ o >> 1 : 127 & o\n          });\n        } else if (i === lU.METADATA || i === lU.AUDIO_64_BIT_PTS) {\n          const t = new Uint8Array(n);\n          for (let i = 0; i < n; i++) t[i] = e.getUint8(a + r + i);\n          s.tlv.push({\n            tag: i,\n            length: n,\n            value: t\n          });\n        }\n        a += r + n;\n      }\n      return s;\n    }\n    const hU = new Map();\n    const pU = 127,\n      _U = 1e-10,\n      EU = 139 / 13,\n      mU = new Map();\n    function fU(e, t, i) {\n      const n = \"\".concat(e, \"-\").concat(t, \"-\").concat(i);\n      let r = 0;\n      if (mU.has(n)) r = mU.get(n);else {\n        const o = .5;\n        r = Math.log(function (e, t) {\n          const i = e - t;\n          t < i && (t = i);\n          let n = 1;\n          for (let i = e, r = 1; i > t; i--, r++) n = n * i / r;\n          return n;\n        }(t, e)) + e * Math.log(o) + (t - e) * Math.log(1 - o) - Math.log(i) + i * e, mU.set(n, r);\n      }\n      return r < _U && (r = _U), r;\n    }\n    function SU(e, t, i) {\n      const n = t.length,\n        r = e.length / n;\n      let o = !1;\n      for (let s = 0, a = 0; s < n; s++) {\n        let n = 0;\n        for (let t = a + r; a < t; a++) e[a] > i && n++;\n        t[s] !== n && (t[s] = n, o = !0);\n      }\n      return o;\n    }\n    window.cache = mU;\n    let gU = 0;\n    class TU {\n      constructor(e) {\n        sL(this, \"id\", void 0), sL(this, \"immediates\", []), sL(this, \"lastNonSilence\", -1), sL(this, \"immediateSpeechActivityScore\", _U), sL(this, \"lastLevelChangedTime\", Date.now()), sL(this, \"levels\", []), sL(this, \"longs\", []), sL(this, \"longSpeechActivityScore\", _U), sL(this, \"mediums\", []), sL(this, \"mediumSpeechActivityScore\", _U), sL(this, \"minLevel\", 0), sL(this, \"nextMinLevel\", 0), sL(this, \"nextMinLevelWindowLength\", 0), sL(this, \"energyScore\", 0), this.id = e || \"\".concat(gU++), this.immediates.length = 50, this.mediums.length = 10, this.longs.length = 1, this.levels.length = this.immediates.length;\n      }\n      computeImmediates() {\n        const e = this.immediates,\n          t = this.levels,\n          i = this.minLevel + EU;\n        let n = !1;\n        for (let r = 0; r < e.length; ++r) {\n          let o = t[r];\n          o < i && (o = 0);\n          const s = Math.floor(o / EU);\n          e[r] !== s && (e[r] = s, n = !0);\n        }\n        return n;\n      }\n      computeLongs() {\n        return SU(this.mediums, this.longs, 4);\n      }\n      computeMediums() {\n        return SU(this.immediates, this.mediums, 7);\n      }\n      evaluateImmediateSpeechActivityScore() {\n        this.immediateSpeechActivityScore = fU(this.immediates[0], 13, .78);\n      }\n      evaluateLongSpeechActivityScore(e) {\n        this.longSpeechActivityScore = fU(this.longs[0], 10, 47), this.longSpeechActivityScore > _U && (this.lastNonSilence = e);\n      }\n      evaluateMediumSpeechActivityScore() {\n        this.mediumSpeechActivityScore = fU(this.mediums[0], 5, 24);\n      }\n      evaluateSpeechActivityScores(e) {\n        this.computeImmediates() && (this.evaluateImmediateSpeechActivityScore(), this.computeMediums() && (this.evaluateMediumSpeechActivityScore(), this.computeLongs() && this.evaluateLongSpeechActivityScore(e)));\n      }\n      getLastLevelChangedTime() {\n        return this.lastLevelChangedTime;\n      }\n      getLevels() {\n        var e;\n        return \"[\".concat(mr(e = [...this.levels]).call(e).join(), \"]\");\n      }\n      getSpeechActivityScore(e) {\n        switch (e) {\n          case 0:\n            return this.immediateSpeechActivityScore;\n          case 1:\n            return this.mediumSpeechActivityScore;\n          case 2:\n            return this.longSpeechActivityScore;\n          default:\n            throw new Error(\"interval \" + e);\n        }\n      }\n      levelChanged(e, t) {\n        if (this.lastLevelChangedTime <= t) {\n          this.lastLevelChangedTime = t;\n          let i = e;\n          return e < 0 && (i = 0), e > pU && (i = pU), this.levels.unshift(i), this.levels.length > this.immediates.length && this.levels.pop(), this.updateMinLevel(i), i >= this.minLevel + EU ? i : i / 2;\n        }\n        return -1;\n      }\n      levelTimedOut() {\n        this.levelChanged(0, this.lastLevelChangedTime);\n      }\n      updateMinLevel(e) {\n        if (0 !== e) {\n          if (0 === this.minLevel || this.minLevel > e) return this.minLevel = e, this.nextMinLevel = 0, void (this.nextMinLevelWindowLength = 0);\n          if (0 === this.nextMinLevel) return this.nextMinLevel = e, void (this.nextMinLevelWindowLength = 1);\n          if (this.nextMinLevel > e && (this.nextMinLevel = e), this.nextMinLevelWindowLength++, this.nextMinLevelWindowLength >= 750) {\n            let e = Math.sqrt(this.minLevel * this.nextMinLevel);\n            e < 0 ? e = 0 : e > pU && (e = pU), this.minLevel = e, this.nextMinLevel = 0, this.nextMinLevelWindowLength = 0;\n          }\n        }\n      }\n    }\n    class RU {\n      constructor(e) {\n        sL(this, \"algorithm\", void 0), this.algorithm = e;\n      }\n      execute() {\n        let e = !this.algorithm;\n        if (!e) try {\n          const t = this.algorithm.runInDecisionMaker(this);\n          t <= 0 ? e = !0 : setTimeout(this.execute.bind(this), t);\n        } catch (t) {\n          e = !0;\n        }\n        e && this.algorithm && this.algorithm.decisionMakerExited(this);\n      }\n    }\n    class CU {\n      constructor(e, t, i) {\n        sL(this, \"isDominant\", void 0), sL(this, \"energyRanking\", void 0), sL(this, \"energyScore\", void 0), this.isDominant = e, this.energyRanking = t, this.energyScore = i;\n      }\n    }\n    class vU extends NO {\n      constructor(e) {\n        super(), sL(this, \"dominantId\", null), sL(this, \"lastDecisionTime\", 0), sL(this, \"lastLevelChangedTime\", 0), sL(this, \"lastLevelIdleTime\", 0), sL(this, \"relativeSpeechActivities\", []), sL(this, \"speakers\", new Map()), sL(this, \"enableSilence\", !1), sL(this, \"timeoutToSilenceInterval\", 0), sL(this, \"decisionMaker\", null), sL(this, \"loudest\", []), sL(this, \"numLoudestToTrack\", 3), sL(this, \"energyExpireTimeMs\", 250), sL(this, \"energyAlphaPct\", 50), this.timeoutToSilenceInterval = e, this.enableSilence = e > 0, this.relativeSpeechActivities.length = 3;\n      }\n      setLoudestConfig() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3,\n          t = arguments.length > 1 ? arguments[1] : void 0,\n          i = arguments.length > 2 ? arguments[2] : void 0;\n        this.numLoudestToTrack = e, null != t && (this.energyExpireTimeMs = t), null != i && (this.energyAlphaPct = i), this.loudest.length > e && this.loudest.splice(e);\n      }\n      getDominantSpeaker() {\n        return this.dominantId;\n      }\n      isAmongLoudest(e) {\n        return this.loudest.some(t => t.id === e);\n      }\n      levelChanged(e, t) {\n        const i = Date.now(),\n          n = this.getOrCreateSpeaker(e);\n        this.lastLevelChangedTime < i && (this.lastLevelChangedTime = i, this.maybeStartDecisionMaker());\n        const r = n.levelChanged(t, i);\n        return this.updateLoudestList(n, r, i);\n      }\n      runInDecisionMaker(e) {\n        return this.decisionMaker !== e || this.lastDecisionTime > 0 && this.lastDecisionTime - this.lastLevelChangedTime >= 15e3 ? -1 : this._runInDecisionMaker();\n      }\n      decisionMakerExited(e) {\n        this.decisionMaker === e && (this.decisionMaker = null);\n      }\n      destroy() {\n        this.decisionMaker = null, this.loudest.length = 0, this.speakers.clear(), this.removeAllListeners();\n      }\n      addSpeakers(e) {\n        e.forEach(e => {\n          this.speakers.has(e.id) || this.speakers.set(e.id, e);\n        });\n      }\n      removeSpeakers(e) {\n        e.forEach(e => {\n          this.speakers.delete(e.id);\n        });\n      }\n      getOrCreateSpeaker(e) {\n        let t = this.speakers.get(e);\n        return t || (t = new TU(e), this.speakers.set(e, t), this.maybeStartDecisionMaker()), t;\n      }\n      updateLoudestList(e, t, i) {\n        const n = e.id === this.dominantId;\n        if (t < 0) {\n          let t = 0;\n          for (; t < this.loudest.length && this.loudest[t] !== e;) ++t;\n          return new CU(n, t, e.energyScore);\n        }\n        if (e.energyScore = Math.floor((this.energyAlphaPct * t + (100 - this.energyAlphaPct) * e.energyScore + 50) / 100), 0 === this.numLoudestToTrack) return new CU(n, 0, e.energyScore);\n        const r = i - this.energyExpireTimeMs;\n        let o = 0;\n        for (; o < this.loudest.length;) {\n          const t = this.loudest[o];\n          if (t.getLastLevelChangedTime() < r && this.loudest.length >= this.numLoudestToTrack) this.loudest.splice(o, 1);else if (t.id !== e.id) ++o;else if (this.loudest.splice(o, 1), this.loudest.length < this.numLoudestToTrack) break;\n        }\n        let s = 0;\n        for (; s < this.loudest.length && !(this.loudest[s].energyScore < e.energyScore);) ++s;\n        return s < this.numLoudestToTrack && (this.loudest.splice(s, 0, e), this.loudest.length > this.numLoudestToTrack && this.loudest.splice(this.numLoudestToTrack, 1)), new CU(n, s, e.energyScore);\n      }\n      maybeStartDecisionMaker() {\n        !this.decisionMaker && this.speakers.size > 0 && (this.decisionMaker = new RU(this), this.decisionMaker.execute());\n      }\n      makeDecision(e) {\n        let t = null,\n          i = null;\n        const n = this.speakers.size;\n        let r = null;\n        if (0 === n) r = null;else if (1 === n) {\n          var o;\n          const t = pp(o = this.speakers).call(o).next().value;\n          this.enableSilence && t && (r = t.id, t.evaluateSpeechActivityScores(e), e - t.lastNonSilence > this.timeoutToSilenceInterval && (r = null));\n        } else {\n          let t = null == this.dominantId ? null : this.speakers.get(this.dominantId);\n          if (null == t) {\n            const e = this.speakers.entries().next();\n            e.value && (r = e.value[0], t = e.value[1]);\n          } else r = t.id;\n          null != t && t.evaluateSpeechActivityScores(e);\n          const i = this.relativeSpeechActivities;\n          let n = 2;\n          for (const o of this.speakers.entries()) {\n            const [s, a] = o;\n            if (a === t) continue;\n            a.evaluateSpeechActivityScores(e);\n            for (let e = 0; e < i.length; ++e) {\n              const n = null == t ? _U : t.getSpeechActivityScore(e);\n              i[e] = Math.log(a.getSpeechActivityScore(e) / n);\n            }\n            const c = i[0],\n              d = i[1],\n              l = i[2];\n            c > 3 && d > 2 && l > 0 && d > n && (n = d, r = s);\n          }\n          this.enableSilence && null != t && r === t.id && e - t.lastNonSilence > this.timeoutToSilenceInterval && (r = null);\n        }\n        null == r && !this.enableSilence || r === this.dominantId || (t = this.dominantId, this.dominantId = r, i = this.dominantId), null == i && !this.enableSilence || i === t || this.emit(\"ActiveSpeakerChanged\", i);\n      }\n      _runInDecisionMaker() {\n        const e = Date.now(),\n          t = 300 - (e - this.lastLevelIdleTime);\n        let i = 0;\n        t <= 0 ? (0 !== this.lastLevelIdleTime && this.timeoutIdleLevels(e), this.lastLevelIdleTime = e) : i = t;\n        let n = 300 - (e - this.lastDecisionTime);\n        return n <= 0 && (this.lastDecisionTime = e, this.makeDecision(e), n = 300 - (Date.now() - e)), n > 0 && i > n && (i = n), i;\n      }\n      timeoutIdleLevels(e) {\n        const t = [];\n        for (const n of pp(i = this.speakers).call(i)) {\n          var i;\n          const r = e - n.getLastLevelChangedTime();\n          36e5 < r && (null == this.dominantId || n.id !== this.dominantId) ? t.push(n.id) : 300 < r && n.levelTimedOut();\n        }\n        t.forEach(e => this.speakers.delete(e));\n      }\n    }\n    const yU = new Map();\n    let IU = null,\n      AU = null;\n    const bU = 3;\n    let wU = [];\n    const OU = new Map(),\n      NU = new Map();\n    class DU {\n      get samples() {\n        return this.actives + this.inactives;\n      }\n      get activeRate() {\n        return this.actives / this.samples;\n      }\n      constructor(e, t) {\n        sL(this, \"id\", void 0), sL(this, \"track\", void 0), sL(this, \"score\", 0), sL(this, \"active\", !0), sL(this, \"muted\", !1), sL(this, \"timer\", 0), sL(this, \"actives\", 0), sL(this, \"inactives\", 0), this.id = e, this.track = t, this.setActive(OU.size < 3);\n      }\n      autoCheckActive() {\n        this.autoSetActive(), this.autoAdjustActive(), this.resetTimer(), this.actives = 0, this.inactives = 0;\n      }\n      autoSetActive() {\n        const e = this.active;\n        this.active = this.activeRate >= .8;\n        const {\n          actives: t,\n          inactives: i\n        } = function () {\n          const e = [],\n            t = [];\n          return Array.from(pp(OU).call(OU)).forEach(i => {\n            i.active ? e.push(i) : t.push(i);\n          }), {\n            actives: e,\n            inactives: t\n          };\n        }();\n        if (t.length > 3) {\n          let e;\n          t.forEach(t => {\n            (!e || e.score > t.score) && (e = t);\n          }), e && e.setActive(!1);\n        }\n        if (t.length < 3 && i.length > 0) {\n          let t;\n          i.forEach(e => {\n            (!t || t.score < e.score) && e.id !== this.id && (t = e);\n          }), t && e && !this.active && (t.samples > 40 && t.activeRate - this.activeRate > .4 ? t.setActive(!0) : this.active = !0);\n        }\n        this.setMuted(!this.active);\n      }\n      setActive(e) {\n        this.active = e, this.resetTimer(), this.setMuted(!e);\n      }\n      autoAdjustActive() {\n        this.active ? this.autoSwitchToInactive() : this.autoSwitchToActive();\n      }\n      autoSwitchToActive() {\n        const e = function (e) {\n          let t;\n          return Array.from(pp(OU).call(OU)).forEach(i => {\n            !i.active || i.id === e || i.samples < 40 || (!t || i.score < t.score) && (t = i);\n          }), t;\n        }(this.id);\n        e && this.activeRate - e.activeRate > .4 && (e.setActive(!1), this.setActive(!0));\n      }\n      autoSwitchToInactive() {\n        const e = function (e) {\n          let t;\n          return Array.from(pp(OU).call(OU)).forEach(i => {\n            i.active || i.id === e || i.samples < 40 || (!t || i.score > t.score) && (t = i);\n          }), t;\n        }(this.id);\n        e && e.activeRate - this.activeRate > .4 && (e.setActive(!0), this.setActive(!1));\n      }\n      addSample(e) {\n        e ? this.actives += 1 : this.inactives += 1, this.samples > 66.66666666666667 && this.autoCheckActive();\n      }\n      setMuted(e) {\n        this.track && (this.track.enabled = !e, this.muted = e);\n      }\n      resetTimer() {\n        this.clearTimer(), this.timer = window.setTimeout(() => {\n          if (0 !== this.samples) return this.samples < 50 ? this.resetTimer() : void this.autoCheckActive();\n        }, 1e3);\n      }\n      clearTimer() {\n        this.timer && (clearTimeout(this.timer), this.timer = 0);\n      }\n    }\n    let PU;\n    function LU(e) {\n      const t = OU.get(e);\n      t && (OU.delete(e), t.clearTimer());\n    }\n    const kU = new Map(),\n      MU = new Map();\n    const UU = \"video/h264\",\n      VU = \"video/h265\";\n    function xU(e, t, i) {\n      let n = new Uint8Array(e, t, i),\n        r = [],\n        o = 0;\n      for (; r.length < i;) o + 3 < i && 0 === n[o] && 0 === n[o + 1] && 3 === n[o + 2] && (0 === n[o + 3] || 1 === n[o + 3] || 2 === n[o + 3] || 3 === n[o + 3]) ? (r.push(n[o], n[o + 1], n[o + 3]), o += 4) : (r.push(n[o]), o++);\n      return new Uint8Array(r);\n    }\n    function FU(e) {\n      const t = e.length;\n      let i = [],\n        n = 0;\n      for (; n < t;) n + 2 < t && 0 === e[n] && 0 === e[n + 1] && (0 === e[n + 2] || 1 === e[n + 2] || 2 === e[n + 2] || 3 === e[n + 2]) ? (i.push(e[n], e[n + 1], 3, e[n + 2]), n += 3) : (i.push(e[n]), n++);\n      return new Uint8Array(i);\n    }\n    function BU(e) {\n      if (e.length < 5) return \"\";\n      let t = -1;\n      for (let i = 0; i < e.length - 3; i++) {\n        if (0 === e[i] && 0 === e[i + 1] && 1 === e[i + 2]) {\n          t = i;\n          break;\n        }\n        if (i < e.length - 4 && 0 === e[i] && 0 === e[i + 1] && 0 === e[i + 2] && 1 === e[i + 3]) {\n          t = i;\n          break;\n        }\n      }\n      if (-1 === t) return \"\";\n      const i = t + (0 === e[t + 2] ? 4 : 3);\n      if (i >= e.length) return \"\";\n      const n = e[i];\n      return 128 & n ? \"\" : (n >> 1 & 63) >= 32 || i + 1 < e.length && 0 == (248 & e[i + 1]) ? VU : (31 & n) <= 31 ? UU : \"\";\n    }\n    const jU = new Map();\n    const GU = new Map();\n    !function () {\n      const e = Dw();\n      hP.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), hP.getStreamFromExtension = e.name === bw.CHROME && Number(e.version) > 34, hP.supportUnifiedPlan = function () {\n        if (!window.RTCRtpTransceiver) return !1;\n        if (!(\"currentDirection\" in RTCRtpTransceiver.prototype)) return !1;\n        const e = new RTCPeerConnection();\n        let t = !1;\n        try {\n          e.addTransceiver(\"audio\"), t = !0;\n        } catch (e) {}\n        return e.close(), t;\n      }(), hP.supportMinBitrate = e.name === bw.CHROME || e.name === bw.EDGE, hP.supportSetRtpSenderParameters = function () {\n        const e = Dw();\n        return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!sO() || !(!Vw() && !Mw()) || e.name === bw.FIREFOX && Number(e.version) >= 64);\n      }(), e.name === bw.SAFARI && (Number(e.version) >= 14 ? hP.supportDualStream = !0 : hP.supportDualStream = !1), hP.webAudioMediaStreamDest = function () {\n        const e = Dw();\n        return !(e.name === bw.SAFARI && Number(e.version) < 12);\n      }(), hP.supportReplaceTrack = !!window.RTCRtpSender && \"function\" == typeof RTCRtpSender.prototype.replaceTrack, hP.supportWebGL = \"undefined\" != typeof WebGLRenderingContext, hP.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, sO() || (hP.webAudioWithAEC = !0), hP.supportShareAudio = function () {\n        const e = Dw();\n        return (e.os === Aw.WIN_10 || e.os === Aw.WIN_81 || e.os === Aw.WIN_7 || e.os === Aw.LINUX || e.os === Aw.MAC_OS || e.os === Aw.CHROMIUM_OS) && e.name === bw.CHROME && Number(e.version) >= 74;\n      }(), hP.supportDataChannel = !!(Gw(76) || Yw(68) || zw(14)), hP.supportPCSetConfiguration = function () {\n        const e = window.RTCPeerConnection;\n        return !Bw() && !!e && e.prototype.setConfiguration instanceof Function;\n      }(), hP.supportWebRTCEncodedTransform = Gw(87) || xw() || Yw(117), hP.supportWebRTCInsertableStream = function () {\n        const e = Dw();\n        return (e.name === bw.CHROME || e.name === bw.EDGE) && Number(e.version) >= 94 && \"MediaStreamTrackGenerator\" in window && \"MediaStreamTrackProcessor\" in window;\n      }(), hP.supportRequestVideoFrameCallback = \"requestVideoFrameCallback\" in HTMLVideoElement.prototype, hP.supportWebCrypto = false && void 0 !== window.crypto && void 0 !== window.crypto.subtle, hP.supportSuppressLocalAudioPlayback = gP(), hP.supportRestrictOwnAudio = TP(), oN(() => {\n        hP.supportDualStreamEncoding = function () {\n          const e = Dw();\n          return !!CD(\"DISABLE_WEBAUDIO\") || \"Safari\" === e.name && Number(e.version) >= 14 || !!(\"Chrome\" === e.name && /Windows/i.test(e.os || \"\") && Number(e.version) >= 100 && CD(\"CHROME_DUAL_STREAM_USE_ENCODING\"));\n        }(), iP.debug(\"browser ua: \", navigator.userAgent), iP.info(\"browser info: \", e), iP.info(\"browser compatibility: \", hP);\n      });\n    }();\n    const WU = [\"CHINA\", \"GLOBAL\"];\n    const HU = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]],\n      KU = [],\n      YU = [];\n    function zU(e, t) {\n      return !!t && KU.some(i => i.uid === e && i.channelName === t);\n    }\n    function qU() {\n      return YU.length > 0;\n    }\n    var XU = Sv.forEach,\n      JU = Wn(\"forEach\") ? [].forEach : function (e) {\n        return XU(this, e, arguments.length > 1 ? arguments[1] : void 0);\n      };\n    Oi({\n      target: \"Array\",\n      proto: !0,\n      forced: [].forEach !== JU\n    }, {\n      forEach: JU\n    });\n    var QU = Zi(\"Array\", \"forEach\"),\n      ZU = En,\n      $U = $e,\n      eV = l,\n      tV = QU,\n      iV = Array.prototype,\n      nV = {\n        DOMTokenList: !0,\n        NodeList: !0\n      },\n      rV = function (e) {\n        var t = e.forEach;\n        return e === iV || eV(iV, e) && t === iV.forEach || $U(nV, ZU(e)) ? tV : t;\n      },\n      oV = i(rV),\n      sV = Je,\n      aV = ho;\n    Oi({\n      target: \"Object\",\n      stat: !0,\n      forced: n(function () {\n        aV(1);\n      })\n    }, {\n      keys: function (e) {\n        return aV(sV(e));\n      }\n    });\n    var cV = i($.Object.keys),\n      dV = i(ir),\n      lV = i(Er),\n      uV = Oi,\n      hV = or,\n      pV = Qc,\n      _V = Z,\n      EV = xi,\n      mV = Wi,\n      fV = J,\n      SV = qE,\n      gV = pt,\n      TV = sd,\n      RV = PC(\"slice\"),\n      CV = gV(\"species\"),\n      vV = Array,\n      yV = Math.max;\n    uV({\n      target: \"Array\",\n      proto: !0,\n      forced: !RV\n    }, {\n      slice: function (e, t) {\n        var i,\n          n,\n          r,\n          o = fV(this),\n          s = mV(o),\n          a = EV(e, s),\n          c = EV(void 0 === t ? s : t, s);\n        if (hV(o) && (i = o.constructor, (pV(i) && (i === vV || hV(i.prototype)) || _V(i) && null === (i = i[CV])) && (i = void 0), i === vV || void 0 === i)) return TV(o, a, c);\n        for (n = new (void 0 === i ? vV : i)(yV(c - a, 0)), r = 0; a < c; a++, r++) a in o && SV(n, r, o[a]);\n        return n.length = r, n;\n      }\n    });\n    var IV = Zi(\"Array\", \"slice\"),\n      AV = l,\n      bV = IV,\n      wV = Array.prototype,\n      OV = function (e) {\n        var t = e.slice;\n        return e === wV || AV(wV, e) && t === wV.slice ? bV : t;\n      },\n      NV = i(OV);\n    function DV(e, t, i, n, r) {\n      var o,\n        s,\n        a,\n        c = {};\n      return oV(o = cV(n)).call(o, function (e) {\n        c[e] = n[e];\n      }), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, (\"value\" in c || c.initializer) && (c.writable = !0), c = dV(s = lV(a = NV(i).call(i)).call(a)).call(s, function (i, n) {\n        return n(e, t, i) || i;\n      }, c), r && void 0 !== c.initializer && (c.value = c.initializer ? c.initializer.call(r) : void 0, c.initializer = void 0), void 0 === c.initializer ? (TC(e, t, c), null) : c;\n    }\n    let PV = function (e) {\n        return e[e.ACCESS_POINT = 101] = \"ACCESS_POINT\", e[e.UNILBS = 201] = \"UNILBS\", e[e.STRING_UID_ALLOCATOR = 901] = \"STRING_UID_ALLOCATOR\", e;\n      }({}),\n      LV = function (e) {\n        return e[e.IIIEGAL_APPID = 1] = \"IIIEGAL_APPID\", e[e.IIIEGAL_UID = 2] = \"IIIEGAL_UID\", e[e.INTERNAL_ERROR = 3] = \"INTERNAL_ERROR\", e;\n      }({}),\n      kV = function (e) {\n        return e[e.INVALID_VENDOR_KEY = 5] = \"INVALID_VENDOR_KEY\", e[e.INVALID_CHANNEL_NAME = 7] = \"INVALID_CHANNEL_NAME\", e[e.INTERNAL_ERROR = 8] = \"INTERNAL_ERROR\", e[e.NO_AUTHORIZED = 9] = \"NO_AUTHORIZED\", e[e.DYNAMIC_KEY_TIMEOUT = 10] = \"DYNAMIC_KEY_TIMEOUT\", e[e.NO_ACTIVE_STATUS = 11] = \"NO_ACTIVE_STATUS\", e[e.DYNAMIC_KEY_EXPIRED = 13] = \"DYNAMIC_KEY_EXPIRED\", e[e.STATIC_USE_DYNAMIC_KEY = 14] = \"STATIC_USE_DYNAMIC_KEY\", e[e.DYNAMIC_USE_STATIC_KEY = 15] = \"DYNAMIC_USE_STATIC_KEY\", e[e.USER_OVERLOAD = 16] = \"USER_OVERLOAD\", e[e.FORBIDDEN_REGION = 18] = \"FORBIDDEN_REGION\", e[e.CANNOT_MEET_AREA_DEMAND = 19] = \"CANNOT_MEET_AREA_DEMAND\", e[e.REQ_DOWNGRADE_FALLBACK = 27] = \"REQ_DOWNGRADE_FALLBACK\", e;\n      }({}),\n      MV = function (e) {\n        return e[e.NO_FLAG_SET = 100] = \"NO_FLAG_SET\", e[e.FLAG_SET_BUT_EMPTY = 101] = \"FLAG_SET_BUT_EMPTY\", e[e.INVALID_FALG_SET = 102] = \"INVALID_FALG_SET\", e[e.FLAG_SET_BUT_NO_RE = 103] = \"FLAG_SET_BUT_NO_RE\", e[e.INVALID_SERVICE_ID = 104] = \"INVALID_SERVICE_ID\", e[e.NO_SERVICE_AVAILABLE = 200] = \"NO_SERVICE_AVAILABLE\", e[e.NO_SERVICE_AVAILABLE_P2P = 201] = \"NO_SERVICE_AVAILABLE_P2P\", e[e.NO_SERVICE_AVAILABLE_VOICE = 202] = \"NO_SERVICE_AVAILABLE_VOICE\", e[e.NO_SERVICE_AVAILABLE_WEBRTC = 203] = \"NO_SERVICE_AVAILABLE_WEBRTC\", e[e.NO_SERVICE_AVAILABLE_CDS = 204] = \"NO_SERVICE_AVAILABLE_CDS\", e[e.NO_SERVICE_AVAILABLE_CDN = 205] = \"NO_SERVICE_AVAILABLE_CDN\", e[e.NO_SERVICE_AVAILABLE_TDS = 206] = \"NO_SERVICE_AVAILABLE_TDS\", e[e.NO_SERVICE_AVAILABLE_REPORT = 207] = \"NO_SERVICE_AVAILABLE_REPORT\", e[e.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = \"NO_SERVICE_AVAILABLE_APP_CENTER\", e[e.NO_SERVICE_AVAILABLE_ENV0 = 209] = \"NO_SERVICE_AVAILABLE_ENV0\", e[e.NO_SERVICE_AVAILABLE_VOET = 210] = \"NO_SERVICE_AVAILABLE_VOET\", e[e.NO_SERVICE_AVAILABLE_STRING_UID = 211] = \"NO_SERVICE_AVAILABLE_STRING_UID\", e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = \"NO_SERVICE_AVAILABLE_WEBRTC_UNILBS\", e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = \"NO_SERVICE_AVAILABLE_UNILBS_FLV\", e;\n      }({}),\n      UV = function (e) {\n        return e[e.K_TIMESTAMP_EXPIRED = 2] = \"K_TIMESTAMP_EXPIRED\", e[e.K_CHANNEL_PERMISSION_INVALID = 3] = \"K_CHANNEL_PERMISSION_INVALID\", e[e.K_CERTIFICATE_INVALID = 4] = \"K_CERTIFICATE_INVALID\", e[e.K_CHANNEL_NAME_EMPTY = 5] = \"K_CHANNEL_NAME_EMPTY\", e[e.K_CHANNEL_NOT_FOUND = 6] = \"K_CHANNEL_NOT_FOUND\", e[e.K_TICKET_INVALID = 7] = \"K_TICKET_INVALID\", e[e.K_CHANNEL_CONFLICTED = 8] = \"K_CHANNEL_CONFLICTED\", e[e.K_SERVICE_NOT_READY = 9] = \"K_SERVICE_NOT_READY\", e[e.K_SERVICE_TOO_HEAVY = 10] = \"K_SERVICE_TOO_HEAVY\", e[e.K_UID_BANNED = 14] = \"K_UID_BANNED\", e[e.K_IP_BANNED = 15] = \"K_IP_BANNED\", e[e.K_CHANNEL_BANNED = 16] = \"K_CHANNEL_BANNED\", e[e.DATASTREAM2_NOT_AVAILABLE = 27] = \"DATASTREAM2_NOT_AVAILABLE\", e[e.K_AUTO_REBALANCE = 28] = \"K_AUTO_REBALANCE\", e[e.K_VOS_FALLBACK = 30] = \"K_VOS_FALLBACK\", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = \"WARN_NO_AVAILABLE_CHANNEL\", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = \"WARN_LOOKUP_CHANNEL_TIMEOUT\", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = \"WARN_LOOKUP_CHANNEL_REJECTED\", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = \"WARN_OPEN_CHANNEL_TIMEOUT\", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = \"WARN_OPEN_CHANNEL_REJECTED\", e[e.WARN_REQUEST_DEFERRED = 108] = \"WARN_REQUEST_DEFERRED\", e[e.ERR_DYNAMIC_KEY_TIMEOUT = 109] = \"ERR_DYNAMIC_KEY_TIMEOUT\", e[e.ERR_NO_AUTHORIZED = 110] = \"ERR_NO_AUTHORIZED\", e[e.ERR_VOM_SERVICE_UNAVAILABLE = 111] = \"ERR_VOM_SERVICE_UNAVAILABLE\", e[e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = \"ERR_NO_CHANNEL_AVAILABLE_CODE\", e[e.ERR_MASTER_VOCS_UNAVAILABLE = 114] = \"ERR_MASTER_VOCS_UNAVAILABLE\", e[e.ERR_INTERNAL_ERROR = 115] = \"ERR_INTERNAL_ERROR\", e[e.ERR_NO_ACTIVE_STATUS = 116] = \"ERR_NO_ACTIVE_STATUS\", e[e.ERR_INVALID_UID = 117] = \"ERR_INVALID_UID\", e[e.ERR_DYNAMIC_KEY_EXPIRED = 118] = \"ERR_DYNAMIC_KEY_EXPIRED\", e[e.ERR_STATIC_USE_DYANMIC_KE = 119] = \"ERR_STATIC_USE_DYANMIC_KE\", e[e.ERR_DYNAMIC_USE_STATIC_KE = 120] = \"ERR_DYNAMIC_USE_STATIC_KE\", e[e.ERR_NO_VOCS_AVAILABLE = 2e3] = \"ERR_NO_VOCS_AVAILABLE\", e[e.ERR_NO_VOS_AVAILABLE = 2001] = \"ERR_NO_VOS_AVAILABLE\", e[e.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = \"ERR_JOIN_CHANNEL_TIMEOUT\", e[e.ERR_REPEAT_JOIN_CHANNEL = 2003] = \"ERR_REPEAT_JOIN_CHANNEL\", e[e.ERR_JOIN_BY_MULTI_IP = 2004] = \"ERR_JOIN_BY_MULTI_IP\", e[e.ERR_NOT_JOINED = 2011] = \"ERR_NOT_JOINED\", e[e.ERR_REPEAT_JOIN_REQUEST = 2012] = \"ERR_REPEAT_JOIN_REQUEST\", e[e.ERR_INVALID_VENDOR_KEY = 2013] = \"ERR_INVALID_VENDOR_KEY\", e[e.ERR_INVALID_CHANNEL_NAME = 2014] = \"ERR_INVALID_CHANNEL_NAME\", e[e.ERR_INVALID_STRINGUID = 2015] = \"ERR_INVALID_STRINGUID\", e[e.ERR_TOO_MANY_USERS = 2016] = \"ERR_TOO_MANY_USERS\", e[e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = \"ERR_SET_CLIENT_ROLE_TIMEOUT\", e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = \"ERR_SET_CLIENT_ROLE_NO_PERMISSION\", e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\", e[e.ERR_PUBLISH_REQUEST_INVALID = 2020] = \"ERR_PUBLISH_REQUEST_INVALID\", e[e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = \"ERR_SUBSCRIBE_REQUEST_INVALID\", e[e.ERR_NOT_SUPPORTED_MESSAGE = 2022] = \"ERR_NOT_SUPPORTED_MESSAGE\", e[e.ERR_ILLEAGAL_PLUGIN = 2023] = \"ERR_ILLEAGAL_PLUGIN\", e[e.ERR_REJOIN_TOKEN_INVALID = 2024] = \"ERR_REJOIN_TOKEN_INVALID\", e[e.ERR_REJOIN_USER_NOT_JOINED = 2025] = \"ERR_REJOIN_USER_NOT_JOINED\", e[e.ERR_INVALID_OPTIONAL_INFO = 2027] = \"ERR_INVALID_OPTIONAL_INFO\", e[e.ILLEGAL_AES_PASSWORD = 2028] = \"ILLEGAL_AES_PASSWORD\", e[e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = \"ILLEGAL_CLIENT_ROLE_LEVEL\", e[e.ERR_TOO_MANY_BROADCASTERS = 2031] = \"ERR_TOO_MANY_BROADCASTERS\", e[e.ERR_TOO_MANY_SUBSCRIBERS = 2032] = \"ERR_TOO_MANY_SUBSCRIBERS\", e[e.ERR_LICENSE_MISSING = 32769] = \"ERR_LICENSE_MISSING\", e[e.ERR_LICENSE_EXPIRED = 32771] = \"ERR_LICENSE_EXPIRED\", e[e.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = \"ERR_LICENSE_MINUTES_EXCEEDED\", e[e.ERR_LICENSE_PERIOD_INVALID = 32774] = \"ERR_LICENSE_PERIOD_INVALID\", e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\", e[e.ERR_LICENSE_ILLEGAL = 32783] = \"ERR_LICENSE_ILLEGAL\", e[e.ERR_TEST_RECOVER = 9e3] = \"ERR_TEST_RECOVER\", e[e.ERR_TEST_TRYNEXT = 9001] = \"ERR_TEST_TRYNEXT\", e[e.ERR_TEST_RETRY = 9002] = \"ERR_TEST_RETRY\", e;\n      }({}),\n      VV = function (e) {\n        return e.CONNECTING = \"connecting\", e.CONNECTED = \"connected\", e.RECONNECTING = \"reconnecting\", e.CLOSED = \"closed\", e;\n      }({}),\n      xV = function (e) {\n        return e.WS_CONNECTED = \"ws_connected\", e.WS_RECONNECTING = \"ws_reconnecting\", e.WS_CLOSED = \"ws_closed\", e.WS_RECONNECT_CREATE_CONNECTION = \"ws_reconnect_create_connection\", e.ON_BINARY_DATA = \"on_binary_data\", e.REQUEST_RECOVER = \"request_recover\", e.REQUEST_JOIN_INFO = \"request_join_info\", e.REQUEST_REJOIN_INFO = \"req_rejoin_info\", e.IS_P2P_DISCONNECTED = \"is_p2p_dis\", e.DISCONNECT_P2P = \"dis_p2p\", e.ABORT_P2P_EXECUTION = \"abort_p2p_execution\", e.NEED_RENEW_SESSION = \"need-sid\", e.REPORT_JOIN_GATEWAY = \"report_join_gateway\", e.REQUEST_TIMEOUT = \"request_timeout\", e.REQUEST_SUCCESS = \"request_success\", e.JOIN_RESPONSE = \"join_response\", e.PRE_CONNECT_PC = \"pre_connect_pc\", e.DATACHANNEL_PRECONNECT = \"datachannel_preconnect\", e.DATACHANNEL_CONNECTING = \"datachannel_connecting\", e.DATACHANNEL_FAILBACK = \"datachannel_failback\", e.P2P_CONNECTION = \"p2p_connection\", e.P2P_REMOTE_CANDIDATE_UPDATE = \"p2p_remote_candidate_update\", e.P2P_SUBSCRIBE = \"p2p_subscribe\", e.P2P_UNSUBSCRIBE = \"p2p_unsubscribe\", e.P2P_EXCHANGE_SDP = \"p2p_exchange_sdp\", e.P2P_ON_ADD_VIDEO_STREAM = \"p2p_on_add_video_stream\", e.P2P_ON_ADD_AUDIO_STREAM = \"p2p_on_add_audio_stream\", e.RECOVER_NOTIFICATION = \"recover_notification\", e.VOS_FALLBACK = \"vos_fallback\", e.VOS_FALLBACK_PROMISE = \"vos_fallback_promise\", e;\n      }({}),\n      FV = function (e) {\n        return e.PING = \"ping\", e.PING_BACK = \"ping_back\", e.JOIN = \"join_v3\", e.REJOIN = \"rejoin_v3\", e.LEAVE = \"leave\", e.SET_CLIENT_ROLE = \"set_client_role\", e.PUBLISH = \"publish\", e.PUBLISH_DATASTREAM = \"publish_datastream\", e.UNPUBLISH = \"unpublish\", e.UNPUBLISH_DATASTREAM = \"unpublish_datastream\", e.SUBSCRIBE = \"subscribe\", e.PRE_SUBSCRIBE = \"pre_subscribe\", e.SUBSCRIBE_DATASTREAM = \"subscribe_datastream\", e.SUBSCRIBE_STREAMS = \"subscribe_streams\", e.UNSUBSCRIBE = \"unsubscribe\", e.UNSUBSCRIBE_DATASTREAM = \"unsubscribe_datastream\", e.UNSUBSCRIBE_STREAMS = \"unsubscribe_streams\", e.SUBSCRIBE_CHANGE = \"subscribe_change\", e.TRAFFIC_STATS = \"traffic_stats\", e.RENEW_TOKEN = \"renew_token\", e.SET_DUAL_STREAM_MODE = \"set_dual_stream_mode\", e.SWITCH_VIDEO_STREAM = \"switch_video_stream\", e.DEFAULT_VIDEO_STREAM = \"default_video_stream\", e.SET_FALLBACK_OPTION = \"set_fallback_option\", e.CONFIGURE = \"configure\", e.GATEWAY_INFO = \"gateway_info\", e.CONTROL = \"control\", e.SEND_METADATA = \"send_metadata\", e.DATA_STREAM = \"data_stream\", e.PICK_SVC_LAYER = \"pick_svc_layer\", e.RESTART_ICE = \"restart_ice\", e.CONNECT_PC = \"connect_pc\", e.SET_VIDEO_PROFILE = \"set_video_profile\", e.SET_PARAMETER = \"set_parameter\", e.SET_RTM2_FLAG = \"set_rtm2_flag\", e.DOWNGRADE_CODEC = \"downgrade_codec\", e;\n      }({}),\n      BV = function (e) {\n        return e.WRTC_STATS = \"wrtc_stats\", e.WS_INFLATE_DATA_LENGTH = \"ws_inflate_data_length\", e.DENOISER_STATS = \"denoiser_stats\", e.EXTENSION_USAGE_STATS = \"extension_usage_stats\", e;\n      }({}),\n      jV = function (e) {\n        return e.ON_USER_ONLINE = \"on_user_online\", e.ON_USER_OFFLINE = \"on_user_offline\", e.ON_STREAM_FALLBACK_UPDATE = \"on_stream_fallback_update\", e.ON_PUBLISH_STREAM = \"on_publish_stream\", e.ON_UPLINK_STATS = \"on_uplink_stats\", e.ON_P2P_LOST = \"on_p2p_lost\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"on_token_privilege_will_expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"on_token_privilege_did_expire\", e.ON_USER_BANNED = \"on_user_banned\", e.ON_USER_LICENSE_BANNED = \"on_user_license_banned\", e.ON_NOTIFICATION = \"on_notification\", e.ON_CRYPT_ERROR = \"on_crypt_error\", e.MUTE_AUDIO = \"mute_audio\", e.MUTE_VIDEO = \"mute_video\", e.UNMUTE_AUDIO = \"unmute_audio\", e.UNMUTE_VIDEO = \"unmute_video\", e.ON_P2P_OK = \"on_p2p_ok\", e.RECEIVE_METADATA = \"receive_metadata\", e.ON_DATA_STREAM = \"on_data_stream\", e.ON_RTP_CAPABILITY_CHANGE = \"on_rtp_capability_change\", e.ON_REMOTE_DATASTREAM_UPDATE = \"on_remote_datastream_update\", e.ON_REMOTE_FULL_DATASTREAM_INFO = \"on_remote_full_datastream_info\", e.ENABLE_LOCAL_VIDEO = \"enable_local_video\", e.DISABLE_LOCAL_VIDEO = \"disable_local_video\", e.ENABLE_LOCAL_AUDIO = \"enable_local_audio\", e.DISABLE_LOCAL_AUDIO = \"disable_local_audio\", e.ON_PUBLISHED_USER_LIST = \"on_published_user_list\", e.ENABLE_MULTI_STREAM = \"enable_multi_stream\", e;\n      }({}),\n      GV = function (e) {\n        return e.SEND_ONLY = \"SEND_ONLY\", e.RECEIVE_ONLY = \"RECEIVE_ONLY\", e;\n      }({}),\n      WV = function (e) {\n        return e.CONNECTED = \"websocket:connected\", e.RECONNECTING = \"websocket:reconnecting\", e.WILL_RECONNECT = \"websocket:will_reconnect\", e.CLOSED = \"websocket:closed\", e.FAILED = \"websocket:failed\", e.ON_MESSAGE = \"websocket:on_message\", e.REQUEST_NEW_URLS = \"websocket:request_new_urls\", e.RECONNECT_CREATE_CONNECTION = \"websocket:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"websocket:on_token_privilege_did_expire\", e.ON_FALLBACK = \"websocket:on_fallback\", e;\n      }({});\n    function HV(e) {\n      if (\"string\" != typeof e || !/^[a-zA-Z0-9 \\!\\#\\$\\%\\&\\(\\)\\+\\-\\:\\;\\<\\=\\.\\>\\?\\@\\[\\]\\^\\_\\{\\}\\|\\~\\,]{1,64}$/.test(e)) throw iP.error(\"Invalid Channel Name \".concat(e)), new uP(hO.INVALID_PARAMS, \"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,\");\n    }\n    function KV(e) {\n      if (!(t = e, \"number\" == typeof t && Math.floor(t) === t && 0 <= t && t <= 4294967295 || RO(e, 1, 255))) throw new uP(hO.INVALID_PARAMS, \"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]\");\n      var t;\n      \"string\" == typeof e && iP.warn(\"You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.\");\n    }\n    let YV = function (e) {\n      return e.TRANSCODE = \"mix_streaming\", e.RAW = \"raw_streaming\", e;\n    }({});\n    const zV = {\n        alpha: 1,\n        height: 640,\n        width: 360,\n        x: 0,\n        y: 0,\n        zOrder: 0,\n        audioChannel: 0\n      },\n      qV = {\n        x: 0,\n        y: 0,\n        width: 160,\n        height: 160,\n        zOrder: 255,\n        alpha: 1\n      };\n    function XV(e, t) {\n      SO(e.url, \"\".concat(t, \".url\"), 1, 1e3, !1), TO(e.x) || mO(e.x, \"\".concat(t, \".x\"), 0, 1e4), TO(e.y) || mO(e.y, \"\".concat(t, \".y\"), 0, 1e4), TO(e.width) || mO(e.width, \"\".concat(t, \".width\"), 0, 1e4), TO(e.height) || mO(e.height, \"\".concat(t, \".height\"), 0, 1e4), TO(e.zOrder) || mO(e.zOrder, \"\".concat(t, \".zOrder\"), 0, 255), TO(e.alpha) || mO(e.alpha, \"\".concat(t, \".alpha\"), 0, 1, !1);\n    }\n    const JV = {\n      audioBitrate: 48,\n      audioChannels: 1,\n      audioSampleRate: 48e3,\n      backgroundColor: 0,\n      height: 360,\n      lowLatency: !1,\n      videoBitrate: 400,\n      videoCodecProfile: 100,\n      videoCodecType: 1,\n      videoFrameRate: 15,\n      videoGop: 30,\n      width: 640,\n      images: [],\n      userConfigs: [],\n      userConfigExtraInfo: \"\"\n    };\n    let QV = function (e) {\n        return e.WARNING = \"@live_uap-warning\", e.ERROR = \"@line_uap-error\", e.PUBLISH_STREAM_STATUS = \"@live_uap-publish-status\", e.WORKER_STATUS = \"@live_uap-worker-status\", e.REQUEST_NEW_ADDRESS = \"@live_uap-request-address\", e;\n      }({}),\n      ZV = function (e) {\n        return e.REQUEST_WORKER_MANAGER_LIST = \"@live_req_worker_manager\", e;\n      }({}),\n      $V = function (e) {\n        return e[e.LIVE_STREAM_RESPONSE_SUCCEED = 200] = \"LIVE_STREAM_RESPONSE_SUCCEED\", e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = \"LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM\", e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = \"LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = \"LIVE_STREAM_RESPONSE_BAD_STREAM\", e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = \"LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = \"LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST\", e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = \"LIVE_STREAM_RESPONSE_NOT_AUTHORIZED\", e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = \"LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE\", e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = \"LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN\", e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = \"LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH\", e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = \"LIVE_STREAM_RESPONSE_NOT_SUPPORTED\", e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = \"LIVE_STREAM_RESPONSE_MAX_STREAM_NUM\", e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = \"LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = \"LIVE_STREAM_RESPONSE_WORKER_LOST\", e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = \"LIVE_STREAM_RESPONSE_RESOURCE_LIMIT\", e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = \"LIVE_STREAM_RESPONSE_WORKER_QUIT\", e[e.ERROR_FAIL_SEND_MESSAGE = 504] = \"ERROR_FAIL_SEND_MESSAGE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH\", e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = \"PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN\", e;\n      }({});\n    function ex(e) {\n      if (!e.channelName) throw new uP(hO.INVALID_PARAMS, \"invalid channelName in info\");\n      if (\"number\" != typeof e.uid) throw new uP(hO.INVALID_PARAMS, \"invalid uid in info, uid must be a number\");\n      return e.token && SO(e.token, \"info.token\", 1, 2047), KV(e.uid), HV(e.channelName), !0;\n    }\n    let tx = function (e) {\n        return e[e.SetSdkProfile = 0] = \"SetSdkProfile\", e[e.SetSourceChannel = 1] = \"SetSourceChannel\", e[e.SetSourceUserId = 2] = \"SetSourceUserId\", e[e.SetDestChannel = 3] = \"SetDestChannel\", e[e.StartPacketTransfer = 4] = \"StartPacketTransfer\", e[e.StopPacketTransfer = 5] = \"StopPacketTransfer\", e[e.UpdateDestChannel = 6] = \"UpdateDestChannel\", e[e.Reconnect = 7] = \"Reconnect\", e[e.SetVideoProfile = 8] = \"SetVideoProfile\", e;\n      }({}),\n      ix = function (e) {\n        return e.NETWORK_DISCONNECTED = \"NETWORK_DISCONNECTED\", e.NETWORK_CONNECTED = \"NETWORK_CONNECTED\", e.PACKET_JOINED_SRC_CHANNEL = \"PACKET_JOINED_SRC_CHANNEL\", e.PACKET_JOINED_DEST_CHANNEL = \"PACKET_JOINED_DEST_CHANNEL\", e.PACKET_SENT_TO_DEST_CHANNEL = \"PACKET_SENT_TO_DEST_CHANNEL\", e.PACKET_RECEIVED_VIDEO_FROM_SRC = \"PACKET_RECEIVED_VIDEO_FROM_SRC\", e.PACKET_RECEIVED_AUDIO_FROM_SRC = \"PACKET_RECEIVED_AUDIO_FROM_SRC\", e.PACKET_UPDATE_DEST_CHANNEL = \"PACKET_UPDATE_DEST_CHANNEL\", e.PACKET_UPDATE_DEST_CHANNEL_REFUSED = \"PACKET_UPDATE_DEST_CHANNEL_REFUSED\", e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = \"PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE\", e;\n      }({}),\n      nx = function (e) {\n        return e.RELAY_STATE_IDLE = \"RELAY_STATE_IDLE\", e.RELAY_STATE_CONNECTING = \"RELAY_STATE_CONNECTING\", e.RELAY_STATE_RUNNING = \"RELAY_STATE_RUNNING\", e.RELAY_STATE_FAILURE = \"RELAY_STATE_FAILURE\", e;\n      }({}),\n      rx = function (e) {\n        return e.RELAY_OK = \"RELAY_OK\", e.SERVER_CONNECTION_LOST = \"SERVER_CONNECTION_LOST\", e.SRC_TOKEN_EXPIRED = \"SRC_TOKEN_EXPIRED\", e.DEST_TOKEN_EXPIRED = \"DEST_TOKEN_EXPIRED\", e;\n      }({}),\n      ox = function (e) {\n        return e.High = \"high\", e.Low = \"low\", e.Audio = \"audio\", e.Screen = \"screen\", e.ScreenLow = \"screen_low\", e;\n      }({}),\n      sx = function (e) {\n        return e.DISCONNECT = \"disconnect\", e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGE = \"stream-type-change\", e.IS_P2P_DISCONNECTED = \"is-p2p-dis\", e.DISCONNECT_P2P = \"dis-p2p\", e.REQUEST_NEW_GATEWAY_LIST = \"req-gate-url\", e.NEED_RENEW_SESSION = \"need-sid\", e.REQUEST_P2P_CONNECTION_PARAMS = \"request-p2p-connection-params\", e.JOIN_RESPONSE = \"join-response\", e.RESET_CONNECTION_EVENTS = \"reset-connection-events\", e.PRE_CONNECT_PC = \"pre-connect_pc\", e.UPDATE_GATEWAY_CONFIG = \"update-gateway-config\", e.VOS_FALLBACK = \"vos-fallback\", e.VOS_FALLBACK_PROMISE = \"vos-fallback-promise\", e.RESET_SIGNAL = \"reset-signal\", e.DATACHANNEL_FAILBACK = \"datachannel-failback\", e;\n      }({}),\n      ax = function (e) {\n        return e.P2P_DISCONNECTED = \"P2P_DISCONNECTED\", e.A_ROUND_WS_FAILED = \"A_ROUND_WS_FAILED\", e.TIMEOUT = \"TIMEOUT\", e.UNKNOWN_REASON = \"UNKNOWN_REASON\", e;\n      }({}),\n      cx = function (e) {\n        return e[e.Nothing = 0] = \"Nothing\", e[e.Audio = 1] = \"Audio\", e[e.LwoVideo = 2] = \"LwoVideo\", e[e.Video = 4] = \"Video\", e[e.Data = 8] = \"Data\", e[e.DataStream0 = 256] = \"DataStream0\", e[e.DataStream1 = 512] = \"DataStream1\", e[e.DataStream2 = 1024] = \"DataStream2\", e[e.DataStream3 = 2048] = \"DataStream3\", e[e.DataStream4 = 4096] = \"DataStream4\", e[e.DataStream5 = 8192] = \"DataStream5\", e[e.DataStream6 = 16384] = \"DataStream6\", e[e.DataStream7 = 32768] = \"DataStream7\", e;\n      }({}),\n      dx = function (e) {\n        return e.CHINA = \"CHINA\", e.ASIA = \"ASIA\", e.NORTH_AMERICA = \"NORTH_AMERICA\", e.EUROPE = \"EUROPE\", e.JAPAN = \"JAPAN\", e.INDIA = \"INDIA\", e.KOREA = \"KOREA\", e.HKMC = \"HKMC\", e.US = \"US\", e.OCEANIA = \"OCEANIA\", e.SOUTH_AMERICA = \"SOUTH_AMERICA\", e.AFRICA = \"AFRICA\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\", e.EXTENSIONS = \"EXTENSIONS\", e;\n      }({});\n    const lx = [dx.AFRICA, dx.ASIA, dx.CHINA, dx.EUROPE, dx.GLOBAL, dx.INDIA, dx.JAPAN, dx.NORTH_AMERICA, dx.OCEANIA, dx.OVERSEA, dx.SOUTH_AMERICA];\n    let ux = function (e) {\n      return e.CHINA = \"CN\", e.ASIA = \"AS\", e.NORTH_AMERICA = \"NA\", e.EUROPE = \"EU\", e.JAPAN = \"JP\", e.INDIA = \"IN\", e.KOREA = \"KR\", e.HKMC = \"HK\", e.US = \"US\", e.OCEANIA = \"OC\", e.SOUTH_AMERICA = \"SA\", e.AFRICA = \"AF\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\", e.EXTENSIONS = \"GLOBAL\", e;\n    }({});\n    const hx = {\n      CHINA: {},\n      ASIA: {\n        CODE: ux.ASIA,\n        WEBCS_DOMAIN: [\"ap-web-1-asia.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-asia.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-asia.agora.io\"],\n        CDS_AP: [\"cds-ap-web-asia.agora.io\", \"cds-ap-web-asia2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-asia.agora.io\", \"sua-ap-web-asia2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-asia.agora.io\", \"uap-ap-web-asia2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-asia.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-asia.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-asia.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"southeast-asia.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      NORTH_AMERICA: {\n        CODE: ux.NORTH_AMERICA,\n        WEBCS_DOMAIN: [\"ap-web-1-north-america.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-north-america.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-america.agora.io\"],\n        CDS_AP: [\"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-north-america.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-north-america.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-north-america.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"east-usa.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      EUROPE: {\n        CODE: ux.EUROPE,\n        WEBCS_DOMAIN: [\"ap-web-1-europe.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-europe.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-europe.agora.io\"],\n        CDS_AP: [\"cds-ap-web-europe.agora.io\", \"cds-ap-web-europe2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-europe.agora.io\", \"sua-ap-web-europe.agora.io\"],\n        UAP_AP: [\"uap-ap-web-europe.agora.io\", \"uap-ap-web-europe2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-europe.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-europe.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-europe.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"europe.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      JAPAN: {\n        CODE: ux.JAPAN,\n        WEBCS_DOMAIN: [\"ap-web-1-japan.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-japan.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-japan.agora.io\"],\n        CDS_AP: [\"cds-ap-web-japan.agora.io\", \"cds-ap-web-japan2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-japan.agora.io\", \"sua-ap-web-japan2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-japan.agora.io\", \"uap-ap-web-japan2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-japan.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-japan.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-japan.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"japan.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      INDIA: {\n        CODE: ux.INDIA,\n        WEBCS_DOMAIN: [\"ap-web-1-india.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-india.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-india.agora.io\"],\n        CDS_AP: [\"cds-ap-web-india.agora.io\", \"cds-ap-web-india2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-india.agora.io\", \"sua-ap-web-india2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-india.agora.io\", \"uap-ap-web-india2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-india.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-india.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-india.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"india.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      KOREA: {\n        CODE: ux.KOREA,\n        WEBCS_DOMAIN: [\"ap-web-1-korea.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-korea.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-korea.agora.io\"],\n        CDS_AP: [\"cds-ap-web-korea.agora.io\", \"cds-ap-web-korea2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-korea.agora.io\", \"sua-ap-web-korea2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-korea.agora.io\", \"uap-ap-web-korea2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-korea.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-korea.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-korea.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"korea.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      HKMC: {\n        CODE: ux.HKMC,\n        WEBCS_DOMAIN: [\"ap-web-1-hkmc.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-hkmc.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-hkmc.agora.io\"],\n        CDS_AP: [\"cds-ap-web-hkmc.agora.io\", \"cds-ap-web-hkmc2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-hkmc.agora.io\", \"sua-ap-web-hkmc2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-hkmc.agora.io\", \"uap-ap-web-hkmc2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-hkmc.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-hkmc.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-hkmc.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"hkmc.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      US: {\n        CODE: ux.US,\n        WEBCS_DOMAIN: [\"ap-web-1-us.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-us.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-us.agora.io\"],\n        CDS_AP: [\"cds-ap-web-us.agora.io\", \"cds-ap-web-us2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-us.agora.io\", \"sua-ap-web-us2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-us.agora.io\", \"uap-ap-web-us2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-us.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-us.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-us.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"us.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      OVERSEA: {\n        CODE: ux.OVERSEA,\n        WEBCS_DOMAIN: [\"ap-web-1-oversea.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oversea.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-oversea.agora.io\"],\n        CDS_AP: [\"cds-ap-web-oversea.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-oversea.agora.io\"],\n        UAP_AP: [\"uap-ap-web-oversea.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-oversea.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oversea.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-oversea.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.agora.io\"]\n      },\n      GLOBAL: {\n        CODE: ux.GLOBAL,\n        WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\"],\n        PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n        CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-ap-web-3.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-ap-web-3.agora.io\"],\n        UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-ap-web-3.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      OCEANIA: {\n        CODE: ux.OCEANIA,\n        WEBCS_DOMAIN: [\"ap-web-1-oceania.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oceania.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-oceania.agora.io\"],\n        CDS_AP: [\"cds-ap-web-oceania.agora.io\", \"cds-ap-web-oceania2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-oceania.agora.io\", \"sua-ap-web-oceania2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-oceania.agora.io\", \"uap-ap-web-oceania2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-oceania.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oceania.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-oceania.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"oceania.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      SOUTH_AMERICA: {\n        CODE: ux.SOUTH_AMERICA,\n        WEBCS_DOMAIN: [\"ap-web-1-south-america.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-south-america.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-south-america.agora.io\"],\n        CDS_AP: [\"cds-ap-web-south-america.agora.io\", \"cds-ap-web-south-america2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-south-america.agora.io\", \"sua-ap-web-south-america2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-south-america.agora.io\", \"uap-ap-web-south-america2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-south-america.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-south-america.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-south-america.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"south-america.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      AFRICA: {\n        CODE: ux.AFRICA,\n        WEBCS_DOMAIN: [\"ap-web-1-africa.agora.io\"],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-africa.agora.io\"],\n        PROXY_CS: [\"proxy-ap-web-africa.agora.io\"],\n        CDS_AP: [\"cds-ap-web-africa.agora.io\", \"cds-ap-web-africa2.agora.io\"],\n        ACCOUNT_REGISTER: [\"sua-ap-web-africa.agora.io\", \"sua-ap-web-africa2.agora.io\"],\n        UAP_AP: [\"uap-ap-web-africa.agora.io\", \"uap-ap-web-africa2.agora.io\"],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-africa.agora.io\"],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-africa.agora.io\"],\n        LOG_UPLOAD_SERVER: [\"logservice-south-africa.agora.io\"],\n        PROXY_SERVER_TYPE3: [\"africa.webrtc-cloud-proxy.sd-rtn.com\"]\n      },\n      EXTENSIONS: {}\n    };\n    pD && (hx.CHINA = {\n      CODE: ux.CHINA,\n      WEBCS_DOMAIN: [\"webrtc2-2.ap.sd-rtn.com\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-4.ap.sd-rtn.com\"],\n      PROXY_CS: [\"proxy-web.ap.sd-rtn.com\"],\n      CDS_AP: [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"],\n      ACCOUNT_REGISTER: [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"],\n      UAP_AP: [\"uap-web-2.ap.sd-rtn.com\", \"uap-web-4.ap.sd-rtn.com\"],\n      EVENT_REPORT_DOMAIN: [\"web-3.statscollector.sd-rtn.com\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"web-4.statscollector.sd-rtn.com\"],\n      LOG_UPLOAD_SERVER: [\"logservice-china.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"east-cn.webrtc-cloud-proxy.sd-rtn.com\"]\n    });\n    let px = function (e) {\n      return e.UPDATE_BITRATE_LIMIT = \"update_bitrate_limit\", e.UPDATE_CLIENT_ROLE_OPTIONS = \"update_client_role_options\", e.UPDATE_REMOTE_VIDEO_STREAM_TYPE = \"update_remote_video_stream_type\", e.FALLBACK_TO_HLS = \"fallback_to_hls\", e.UPDATE_VOS_CONFIGURE = \"update_vos_configure\", e;\n    }({});\n    function _x(e) {\n      return !!e && !(!e.uplink || !e.id) && void 0 !== e.uplink.max_bitrate && void 0 !== e.uplink.min_bitrate;\n    }\n    class Ex extends NO {\n      constructor(e, t) {\n        super(), iA(this, \"onICEConnectionStateChange\", void 0), iA(this, \"onConnectionStateChange\", void 0), iA(this, \"onDTLSTransportStateChange\", void 0), iA(this, \"onDTLSTransportError\", void 0), iA(this, \"onICETransportStateChange\", void 0), iA(this, \"onFirstAudioReceived\", void 0), iA(this, \"onFirstVideoReceived\", void 0), iA(this, \"onFirstAudioDecoded\", void 0), iA(this, \"onFirstVideoDecoded\", void 0), iA(this, \"onFirstVideoRender\", void 0), iA(this, \"onFirstVideoBufferReady\", void 0), iA(this, \"onFirstVideoDecodedTimeout\", void 0), iA(this, \"onSelectedLocalCandidateChanged\", void 0), iA(this, \"onSelectedRemoteCandidateChanged\", void 0), iA(this, \"onICECandidateError\", void 0), iA(this, \"getLocalVideoStats\", void 0);\n      }\n    }\n    class mx extends Ex {\n      constructor(e, t) {\n        super(e, t), iA(this, \"establishPromise\", void 0);\n      }\n    }\n    let fx = function (e) {\n        return e.VIDEO = \"video\", e.AUDIO = \"audio\", e;\n      }({}),\n      Sx = function (e) {\n        return e.UDP_RELAY = \"udp_relay\", e.UDP_TCP_RELAY = \"udp_tcp_relay\", e.TCP_RELAY = \"tcp_relay\", e.RELAY = \"relay\", e;\n      }({}),\n      gx = function (e) {\n        return e[e.FIRST_CONNECTION = 0] = \"FIRST_CONNECTION\", e[e.UDP_TCP_RESTART = 1] = \"UDP_TCP_RESTART\", e[e.RELAY_RESTART = 2] = \"RELAY_RESTART\", e[e.TCP_RESTART = 3] = \"TCP_RESTART\", e[e.OLD_FIRST_CONNECTION = 10] = \"OLD_FIRST_CONNECTION\", e[e.OLD_RESTART = 11] = \"OLD_RESTART\", e[e.DISCONNECTED_OR_FAILED = 20] = \"DISCONNECTED_OR_FAILED\", e;\n      }({});\n    const Tx = [\"disconnected\", \"failed\"];\n    let Rx = function (e) {\n        return e.LocalVideoTrack = \"videoTrack\", e.LocalAudioTrack = \"audioTrack\", e.LocalVideoLowTrack = \"videoLowTrack\", e;\n      }({}),\n      Cx = function (e) {\n        return e.New = \"new\", e.Connected = \"connected\", e.Reconnecting = \"reconnecting\", e.Disconnected = \"disconnected\", e;\n      }({}),\n      vx = function (e) {\n        return e.AudioMetadata = \"audioMetadata\", e.AudioPts = \"audioPts\", e.StateChange = \"stateChange\", e.IceConnectionStateChange = \"iceConnectionStateChange\", e.RequestMuteLocal = \"requestMuteLocal\", e.RequestUnmuteLocal = \"requestUnmuteLocal\", e.RequestRePublish = \"requestRePublish\", e.RequestRePublishDataChannel = \"requestRePublishDataChannel\", e.RequestReSubscribe = \"requestReSubscribe\", e.RequestUploadStats = \"requestUploadStats\", e.RequestUpload = \"requestUpload\", e.MediaReconnectStart = \"MediaReconnectStart\", e.MediaReconnectEnd = \"MediaReconnectEnd\", e.NeedSignalRTT = \"NeedSignalRTT\", e.RequestRestartICE = \"RequestRestartIce\", e.PeerConnectionStateChange = \"PeerConnectionStateChange\", e.RequestReconnect = \"RequestReconnect\", e.RequestReconnectPC = \"RequestReconnectPC\", e.RequestUnpublishForReconnectPC = \"RequestUnpublishForReconnectPC\", e.P2PLost = \"P2PLost\", e.UpdateVideoEncoder = \"UpdateVideoEncoder\", e.ConnectionTypeChange = \"ConnectionTypeChange\", e.RequestLowStreamParameter = \"RequestLowStreamParameter\", e.QueryClientConnectionState = \"QueryClientConnectionState\", e.LocalCandidate = \"LocalCandidate\", e.RequestP2PMuteLocal = \"requestP2PMuteLocal\", e.RequestP2PUnPublish = \"RequestP2PUnPublish\", e.RequestP2PUnmuteRemote = \"RequestP2PUnmuteRemote\", e.RequestP2PMuteRemote = \"RequestP2PMuteRemote\", e.RequestP2PRestartICE = \"RequestP2PRestartICE\", e.FirstVideoPreRender = \"FirstVideoPreRender\", e.FirstVideoBufferReady = \"FirstVideoBufferReady\", e;\n      }({}),\n      yx = function (e) {\n        return e.CONNECTING = \"CONNECTING\", e.RECONNECTING = \"RECONNECTING\", e.CONNECTED = \"CONNECTED\", e.CLOSED = \"CLOSED\", e;\n      }({}),\n      Ix = function (e) {\n        return e[e.CONNECT_AP = 0] = \"CONNECT_AP\", e[e.AP_CONNECTED = 1] = \"AP_CONNECTED\", e[e.CONNECT_WORKER_MANAGER = 2] = \"CONNECT_WORKER_MANAGER\", e[e.WORKER_MANAGER_CONNECTED = 3] = \"WORKER_MANAGER_CONNECTED\", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = \"GET_WORKER_MANAGER_RESPONSE\", e[e.CONNECT_WORKER = 5] = \"CONNECT_WORKER\", e[e.WORKER_CONNECTED = 6] = \"WORKER_CONNECTED\", e[e.CLOSED = 7] = \"CLOSED\", e;\n      }({}),\n      Ax = function (e) {\n        return e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.STATE_CHANGE = \"state-change\", e.INSPECT_RESULT = \"inspect-result\", e.CLIENT_LOCAL_VIDEO_TRACK = \"client-local-video-track\", e.REQUEST_NEW_WORKER_URL = \"request-new-worker-url\", e;\n      }({}),\n      bx = function (e) {\n        return e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\", e;\n      }({}),\n      wx = function (e) {\n        return e.CONNECTED = \"transmitter:connected\", e.RECONNECTING = \"transmitter:reconnecting\", e.WILL_RECONNECT = \"transmitter:will_reconnect\", e.CLOSED = \"transmitter:closed\", e.FAILED = \"transmitter:failed\", e.ON_MESSAGE = \"transmitter:on_message\", e.REQUEST_NEW_URLS = \"transmitter:request_new_urls\", e.RECONNECT_CREATE_CONNECTION = \"transmitter:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"transmitter:on_token_privilege_did_expire\", e.TO_CONNECT_DATACHANNEL = \"transmitter:to_connect_datachannel\", e.FAILBACK = \"transmitter:failback\", e.PRE_CONNECT_PC = \"transmitter:pre_connect_pc\", e;\n      }({}),\n      Ox = function (e) {\n        return e.CAMERA_CHANGED = \"camera-changed\", e.MICROPHONE_CHANGED = \"microphone-changed\", e.PLAYBACK_DEVICE_CHANGED = \"playback-device-changed\", e.AUDIO_AUTOPLAY_FAILED = \"audio-autoplay-failed\", e.AUTOPLAY_FAILED = \"autoplay-failed\", e.AUDIO_CONTEXT_STATE_CHANGED = \"audio-context-state-changed\", e.SECURITY_POLICY_VIOLATION = \"security-policy-violation\", e;\n      }({}),\n      Nx = function (e) {\n        return e.CONNECTING = \"CONNECTING\", e.RECONNECTING = \"RECONNECTING\", e.CONNECTED = \"CONNECTED\", e.CLOSED = \"CLOSED\", e;\n      }({}),\n      Dx = function (e) {\n        return e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.STATE_CHANGE = \"state-change\", e.INSPECT_RESULT = \"inspect-result\", e.CLIENT_LOCAL_VIDEO_TRACK = \"client-local-video-track\", e.REQUEST_NEW_WORKER_URL = \"request-new-worker-url\", e;\n      }({}),\n      Px = function (e) {\n        return e[e.CONNECT_AP = 0] = \"CONNECT_AP\", e[e.AP_CONNECTED = 1] = \"AP_CONNECTED\", e[e.CONNECT_WORKER_MANAGER = 2] = \"CONNECT_WORKER_MANAGER\", e[e.WORKER_MANAGER_CONNECTED = 3] = \"WORKER_MANAGER_CONNECTED\", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = \"GET_WORKER_MANAGER_RESPONSE\", e[e.CONNECT_WORKER = 5] = \"CONNECT_WORKER\", e[e.WORKER_CONNECTED = 6] = \"WORKER_CONNECTED\", e[e.CLOSED = 7] = \"CLOSED\", e;\n      }({}),\n      Lx = function (e) {\n        return e.CALL = \"call\", e.CANDIDATE = \"candidate\", e.PUBLISH = \"publish\", e.UNPUBLISH = \"unpublish\", e.CONTROL = \"control\", e.RESTART_ICE = \"restart_ice\", e.ACK = \"ack\", e.RESPONSE = \"response\", e.JOIN = \"join\", e.CHECK = \"check\", e;\n      }({}),\n      kx = function (e) {\n        return e.ABORT = \"abort\", e;\n      }({}),\n      Mx = function (e) {\n        return e.MUTE_LOCAL_AUDIO = \"mute_local_audio\", e.MUTE_LOCAL_VIDEO = \"mute_local_video\", e.UNMUTE_LOCAL_AUDIO = \"unmute_local_audio\", e.UNMUTE_LOCAL_VIDEO = \"unmute_local_video\", e;\n      }({}),\n      Ux = function (e) {\n        return e.P2P_TOKEN_TIMEOUT = \"p2p_token_timeout\", e.P2P_TOKEN_CHANGED = \"p2p_token_changed\", e;\n      }({});\n    const Vx = {\n      [PV.ACCESS_POINT]: {\n        [MV.NO_FLAG_SET]: {\n          desc: \"flag is zero\",\n          retry: !1\n        },\n        [MV.FLAG_SET_BUT_EMPTY]: {\n          desc: \"flag is empty\",\n          retry: !1\n        },\n        [MV.INVALID_FALG_SET]: {\n          desc: \"invalid flag\",\n          retry: !1\n        },\n        [MV.FLAG_SET_BUT_NO_RE]: {\n          desc: \"flag set unilbs but no request\",\n          retry: !1\n        },\n        [MV.INVALID_SERVICE_ID]: {\n          desc: \"invalid service id\",\n          retry: !1\n        },\n        [MV.NO_SERVICE_AVAILABLE]: {\n          desc: \"no service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_P2P]: {\n          desc: \"no unilbs p2p service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_VOICE]: {\n          desc: \"no unilbs voice service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_WEBRTC]: {\n          desc: \"no unilbs webrtc service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_CDS]: {\n          desc: \"no cds service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_CDN]: {\n          desc: \"no cdn dispatcher service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_TDS]: {\n          desc: \"no tds service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_REPORT]: {\n          desc: \"no unilbs report service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_APP_CENTER]: {\n          desc: \"no app center service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_ENV0]: {\n          desc: \"no unilbs sig env0 service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_VOET]: {\n          desc: \"no unilbs voet service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_STRING_UID]: {\n          desc: \"no string uid service available\",\n          retry: !0\n        },\n        [MV.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {\n          desc: \"no webrtc unilbs service available\",\n          retry: !0\n        }\n      },\n      [PV.UNILBS]: {\n        [kV.INVALID_VENDOR_KEY]: {\n          desc: \"invalid vendor key, can not find appid\",\n          retry: !1\n        },\n        [kV.INVALID_CHANNEL_NAME]: {\n          desc: \"invalid channel name\",\n          retry: !1\n        },\n        [kV.INTERNAL_ERROR]: {\n          desc: \"unilbs internal error\",\n          retry: !1\n        },\n        [kV.NO_AUTHORIZED]: {\n          desc: \"invalid token, authorized failed\",\n          retry: !1\n        },\n        [kV.DYNAMIC_KEY_TIMEOUT]: {\n          desc: \"dynamic key or token timeout\",\n          retry: !1\n        },\n        [kV.NO_ACTIVE_STATUS]: {\n          desc: \"no active status\",\n          retry: !1\n        },\n        [kV.DYNAMIC_KEY_EXPIRED]: {\n          desc: \"dynamic key expired\",\n          retry: !1\n        },\n        [kV.STATIC_USE_DYNAMIC_KEY]: {\n          desc: \"static use dynamic key\",\n          retry: !1\n        },\n        [kV.DYNAMIC_USE_STATIC_KEY]: {\n          desc: \"dynamic use static key\",\n          retry: !1\n        },\n        [kV.USER_OVERLOAD]: {\n          desc: \"amount of users over load\",\n          retry: !1\n        },\n        [kV.FORBIDDEN_REGION]: {\n          desc: \"the request is forbidden in this area\",\n          retry: !1\n        },\n        [kV.CANNOT_MEET_AREA_DEMAND]: {\n          desc: \"unable to allocate services in this area\",\n          retry: !1\n        },\n        [kV.REQ_DOWNGRADE_FALLBACK]: {\n          desc: \"request downgrade fallback\",\n          retry: !1\n        }\n      },\n      [PV.STRING_UID_ALLOCATOR]: {\n        [LV.IIIEGAL_APPID]: {\n          desc: \"invalid appid\",\n          retry: !1\n        },\n        [LV.IIIEGAL_UID]: {\n          desc: \"invalid string uid\",\n          retry: !1\n        },\n        [LV.INTERNAL_ERROR]: {\n          desc: \"string uid allocator internal error\",\n          retry: !0\n        }\n      }\n    };\n    function xx(e) {\n      const t = Vx[Math.floor(e / 1e4)];\n      if (!t) return {\n        desc: \"unknown error\",\n        retry: !1\n      };\n      const i = t[e % 1e4];\n      if (!i) {\n        if (Math.floor(e / 1e4) === PV.ACCESS_POINT) {\n          const t = e % 1e4;\n          if (\"1\" === t.toString()[0]) return {\n            desc: e.toString(),\n            retry: !1\n          };\n          if (\"2\" === t.toString()[0]) return {\n            desc: e.toString(),\n            retry: !0\n          };\n        }\n        return {\n          desc: \"unknown error\",\n          retry: !1\n        };\n      }\n      return i;\n    }\n    const Fx = {\n      [UV.K_TIMESTAMP_EXPIRED]: {\n        desc: \"K_TIMESTAMP_EXPIRED\",\n        action: \"failed\"\n      },\n      [UV.K_CHANNEL_PERMISSION_INVALID]: {\n        desc: \"K_CHANNEL_PERMISSION_INVALID\",\n        action: \"failed\"\n      },\n      [UV.K_CERTIFICATE_INVALID]: {\n        desc: \"K_CERTIFICATE_INVALID\",\n        action: \"failed\"\n      },\n      [UV.K_CHANNEL_NAME_EMPTY]: {\n        desc: \"K_CHANNEL_NAME_EMPTY\",\n        action: \"failed\"\n      },\n      [UV.K_CHANNEL_NOT_FOUND]: {\n        desc: \"K_CHANNEL_NOT_FOUND\",\n        action: \"failed\"\n      },\n      [UV.K_TICKET_INVALID]: {\n        desc: \"K_TICKET_INVALID\",\n        action: \"failed\"\n      },\n      [UV.K_CHANNEL_CONFLICTED]: {\n        desc: \"K_CHANNEL_CONFLICTED\",\n        action: \"failed\"\n      },\n      [UV.K_SERVICE_NOT_READY]: {\n        desc: \"K_SERVICE_NOT_READY\",\n        action: \"tryNext\"\n      },\n      [UV.K_SERVICE_TOO_HEAVY]: {\n        desc: \"K_SERVICE_TOO_HEAVY\",\n        action: \"tryNext\"\n      },\n      [UV.K_UID_BANNED]: {\n        desc: \"K_UID_BANNED\",\n        action: \"failed\"\n      },\n      [UV.K_IP_BANNED]: {\n        desc: \"K_IP_BANNED\",\n        action: \"failed\"\n      },\n      [UV.DATASTREAM2_NOT_AVAILABLE]: {\n        desc: \"DATASTREAM2_NOT_AVAILABLE\",\n        action: \"quit\"\n      },\n      [UV.K_AUTO_REBALANCE]: {\n        desc: \"k_AUTO_REBALANCE\",\n        action: \"recover\"\n      },\n      [UV.K_VOS_FALLBACK]: {\n        desc: \"K_VOS_FALLBACK\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_INVALID_VENDOR_KEY]: {\n        desc: \"ERR_INVALID_VENDOR_KEY\",\n        action: \"failed\"\n      },\n      [UV.ERR_INVALID_CHANNEL_NAME]: {\n        desc: \"ERR_INVALID_CHANNEL_NAME\",\n        action: \"failed\"\n      },\n      [UV.WARN_NO_AVAILABLE_CHANNEL]: {\n        desc: \"WARN_NO_AVAILABLE_CHANNEL\",\n        action: \"failed\"\n      },\n      [UV.WARN_LOOKUP_CHANNEL_TIMEOUT]: {\n        desc: \"WARN_LOOKUP_CHANNEL_TIMEOUT\",\n        action: \"tryNext\"\n      },\n      [UV.WARN_LOOKUP_CHANNEL_REJECTED]: {\n        desc: \"WARN_LOOKUP_CHANNEL_REJECTED\",\n        action: \"failed\"\n      },\n      [UV.WARN_OPEN_CHANNEL_TIMEOUT]: {\n        desc: \"WARN_OPEN_CHANNEL_TIMEOUT\",\n        action: \"tryNext\"\n      },\n      [UV.WARN_OPEN_CHANNEL_REJECTED]: {\n        desc: \"WARN_OPEN_CHANNEL_REJECTED\",\n        action: \"failed\"\n      },\n      [UV.WARN_REQUEST_DEFERRED]: {\n        desc: \"WARN_REQUEST_DEFERRED\",\n        action: \"failed\"\n      },\n      [UV.ERR_DYNAMIC_KEY_TIMEOUT]: {\n        desc: \"ERR_DYNAMIC_KEY_TIMEOUT\",\n        action: \"failed\"\n      },\n      [UV.ERR_NO_AUTHORIZED]: {\n        desc: \"ERR_NO_AUTHORIZED\",\n        action: \"failed\"\n      },\n      [UV.ERR_VOM_SERVICE_UNAVAILABLE]: {\n        desc: \"ERR_VOM_SERVICE_UNAVAILABLE\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_NO_CHANNEL_AVAILABLE_CODE]: {\n        desc: \"ERR_NO_CHANNEL_AVAILABLE_CODE\",\n        action: \"failed\"\n      },\n      [UV.ERR_MASTER_VOCS_UNAVAILABLE]: {\n        desc: \"ERR_MASTER_VOCS_UNAVAILABLE\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_INTERNAL_ERROR]: {\n        desc: \"ERR_INTERNAL_ERROR\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_NO_ACTIVE_STATUS]: {\n        desc: \"ERR_NO_ACTIVE_STATUS\",\n        action: \"failed\"\n      },\n      [UV.ERR_INVALID_UID]: {\n        desc: \"ERR_INVALID_UID\",\n        action: \"failed\"\n      },\n      [UV.ERR_DYNAMIC_KEY_EXPIRED]: {\n        desc: \"ERR_DYNAMIC_KEY_EXPIRED\",\n        action: \"failed\"\n      },\n      [UV.ERR_STATIC_USE_DYANMIC_KE]: {\n        desc: \"ERR_STATIC_USE_DYANMIC_KE\",\n        action: \"failed\"\n      },\n      [UV.ERR_DYNAMIC_USE_STATIC_KE]: {\n        desc: \"ERR_DYNAMIC_USE_STATIC_KE\",\n        action: \"failed\"\n      },\n      [UV.ERR_NO_VOCS_AVAILABLE]: {\n        desc: \"ERR_NO_VOCS_AVAILABLE\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_NO_VOS_AVAILABLE]: {\n        desc: \"ERR_NO_VOS_AVAILABLE\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_JOIN_CHANNEL_TIMEOUT]: {\n        desc: \"ERR_JOIN_CHANNEL_TIMEOUT\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_JOIN_BY_MULTI_IP]: {\n        desc: \"ERR_JOIN_BY_MULTI_IP\",\n        action: \"recover\"\n      },\n      [UV.ERR_NOT_JOINED]: {\n        desc: \"ERR_NOT_JOINED\",\n        action: \"failed\"\n      },\n      [UV.ERR_REPEAT_JOIN_REQUEST]: {\n        desc: \"ERR_REPEAT_JOIN_REQUEST\",\n        action: \"quit\"\n      },\n      [UV.ERR_REPEAT_JOIN_CHANNEL]: {\n        desc: \"ERR_REPEAT_JOIN_CHANNEL\",\n        action: \"quit\"\n      },\n      [UV.ERR_INVALID_STRINGUID]: {\n        desc: \"ERR_INVALID_STRINGUID\",\n        action: \"failed\"\n      },\n      [UV.ERR_TOO_MANY_USERS]: {\n        desc: \"ERR_TOO_MANY_USERS\",\n        action: \"tryNext\"\n      },\n      [UV.ERR_SET_CLIENT_ROLE_TIMEOUT]: {\n        desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n        action: \"failed\"\n      },\n      [UV.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {\n        desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n        action: \"failed\"\n      },\n      [UV.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {\n        desc: \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\",\n        action: \"success\"\n      },\n      [UV.ERR_PUBLISH_REQUEST_INVALID]: {\n        desc: \"ERR_PUBLISH_REQUEST_INVALID\",\n        action: \"failed\"\n      },\n      [UV.ERR_SUBSCRIBE_REQUEST_INVALID]: {\n        desc: \"ERR_SUBSCRIBE_REQUEST_INVALID\",\n        action: \"failed\"\n      },\n      [UV.ERR_NOT_SUPPORTED_MESSAGE]: {\n        desc: \"ERR_NOT_SUPPORTED_MESSAGE\",\n        action: \"failed\"\n      },\n      [UV.ERR_ILLEAGAL_PLUGIN]: {\n        desc: \"ERR_ILLEAGAL_PLUGIN\",\n        action: \"failed\"\n      },\n      [UV.ILLEGAL_CLIENT_ROLE_LEVEL]: {\n        desc: \"ILLEGAL_CLIENT_ROLE_LEVEL\",\n        action: \"failed\"\n      },\n      [UV.ERR_REJOIN_TOKEN_INVALID]: {\n        desc: \"ERR_REJOIN_TOKEN_INVALID\",\n        action: \"failed\"\n      },\n      [UV.ERR_REJOIN_USER_NOT_JOINED]: {\n        desc: \"ERR_REJOIN_NOT_JOINED\",\n        action: \"failed\"\n      },\n      [UV.ERR_INVALID_OPTIONAL_INFO]: {\n        desc: \"ERR_INVALID_OPTIONAL_INFO\",\n        action: \"quit\"\n      },\n      [UV.ERR_TEST_RECOVER]: {\n        desc: \"ERR_TEST_RECOVER\",\n        action: \"recover\"\n      },\n      [UV.ERR_TEST_TRYNEXT]: {\n        desc: \"ERR_TEST_TRYNEXT\",\n        action: \"recover\"\n      },\n      [UV.ERR_TEST_RETRY]: {\n        desc: \"ERR_TEST_RETRY\",\n        action: \"recover\"\n      },\n      [UV.ILLEGAL_AES_PASSWORD]: {\n        desc: \"ERR_TEST_RETRY\",\n        action: \"failed\"\n      },\n      [UV.ERR_TOO_MANY_BROADCASTERS]: {\n        desc: \"ERR_TOO_MANY_BROADCASTERS\",\n        action: \"failed\"\n      },\n      [UV.ERR_TOO_MANY_SUBSCRIBERS]: {\n        desc: \"ERR_TOO_MANY_SUBSCRIBERS\",\n        action: \"failed\"\n      },\n      [UV.ERR_LICENSE_ILLEGAL]: {\n        desc: \"ERR_LICENSE_ILLEGAL\",\n        action: \"quit\"\n      },\n      [UV.ERR_LICENSE_MISSING]: {\n        desc: \"ERR_LICENSE_MISSING\",\n        action: \"quit\"\n      },\n      [UV.ERR_LICENSE_EXPIRED]: {\n        desc: \"ERR_LICENSE_EXPIRED\",\n        action: \"quit\"\n      },\n      [UV.ERR_LICENSE_MINUTES_EXCEEDED]: {\n        desc: \"ERR_LICENSE_MINUTES_EXCEEDED\",\n        action: \"quit\"\n      },\n      [UV.ERR_LICENSE_PERIOD_INVALID]: {\n        desc: \"ERR_LICENSE_PERIOD_INVALID\",\n        action: \"quit\"\n      },\n      [UV.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: {\n        desc: \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\",\n        action: \"quit\"\n      }\n    };\n    function Bx(e) {\n      const t = Fx[e];\n      return t || {\n        desc: \"UNKNOWN_ERROR_\".concat(e),\n        action: \"failed\"\n      };\n    }\n    function jx(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function Gx(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? jx(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : jx(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    function Wx(e, t) {\n      if (\"string\" == typeof e) return e;\n      const {\n        proxy: i,\n        host: n,\n        port: r\n      } = e;\n      if (t) {\n        const e = CD(\"JOIN_GATEWAY_FALLBACK_PORT\") || 443;\n        return 443 === e ? \"wss://\".concat(n, \"/ws/?p=\").concat(Number(r) + 150) : \"wss://\".concat(n, \":\").concat(e, \"/ws/?p=\").concat(Number(r) + 150);\n      }\n      return i ? \"wss://\".concat(i, \"/ws/?h=\").concat(n, \"&p=\").concat(r) : \"wss://\".concat(n, \":\").concat(r);\n    }\n    const Hx = /wss:\\/\\/(.+)\\/ws\\/\\?h=(.+)&p=([0-9]+)\\/?/,\n      Kx = /wss:\\/\\/(.+)\\/ws\\/\\?p=([0-9]+)\\/?/,\n      Yx = /wss:\\/\\/(.+):([0-9]+)\\/?/,\n      zx = /wss:\\/\\/(.[^\\/]+)\\/?/;\n    let qx = 0;\n    class Xx {\n      constructor(e, t) {\n        iA(this, \"id\", 0), iA(this, \"store\", void 0), iA(this, \"recordIndex\", void 0), iA(this, \"websockets\", []), iA(this, \"try443PortDuration\", 2e3), iA(this, \"forceCloseWSDuration\", 5e3), iA(this, \"try443PortTimeout\", null), iA(this, \"forceCloseTimeout\", null), iA(this, \"isTry443PortFailed\", !1), iA(this, \"isNormalPortFailed\", !1), iA(this, \"useDoubleDomain\", !1), iA(this, \"useProxy\", !1), iA(this, \"startTime\", Date.now()), this.id = ++qx, this.try443PortDuration = CD(\"JOIN_GATEWAY_TRY_443PORT_DURATION\") || 2e3, this.forceCloseWSDuration = e || 5e3, this.store = t;\n      }\n      closeAllWebsockets() {\n        this.websockets.forEach(e => {\n          e.onopen = null, e.onclose = null, e.onmessage = null, e.close();\n        }), this.websockets.length = 0;\n      }\n      clearTimeout() {\n        this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout), this.forceCloseTimeout = null, this.try443PortTimeout = null;\n      }\n      logger() {\n        var e;\n        const t = Date.now() - this.startTime;\n        for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++) n[r] = arguments[r];\n        iP.debug(\"[choose-best-ws \".concat(null === (e = this.store) || void 0 === e ? void 0 : e.clientId, \" \").concat(this.id, \"] \").concat(t, \"ms:\"), ...n);\n      }\n      createWebSocket(e, t, i) {\n        this.logger(\"createWebSocket:\", e, {\n          isTry443Port: t,\n          hasTimeoutDetection: i\n        });\n        const n = CD(\"GATEWAY_DOMAINS\"),\n          r = Date.now(),\n          o = [],\n          s = n.find(t => {\n            var i;\n            return Ln(i = e.host).call(i, t);\n          });\n        s || (this.useDoubleDomain = !1);\n        const a = [];\n        if (this.useDoubleDomain) n.forEach(i => {\n          a.push(Wx(Gx(Gx({}, e), {}, {\n            host: e.host.replace(s, i)\n          }), t));\n        });else {\n          const i = Gx({}, e);\n          if (t && s) {\n            const e = n.find(e => e !== s);\n            e && (i.host = i.host.replace(s, e));\n          }\n          a.push(Wx(i, t));\n        }\n        try {\n          a.forEach(e => {\n            const t = new WebSocket(e);\n            t.binaryType = \"arraybuffer\", o.push(t), this.logger(\"ws is connecting:\", t.url);\n          });\n        } catch (n) {\n          if (this.logger(\"ws create failed\"), o.forEach(e => e.close()), o.length = 0, this.useDoubleDomain) return this.useDoubleDomain = !1, this.createWebSocket(e, t, i);\n          if (!t && 443 !== Number(e.port)) return this.createWebSocket(e, !0, i);\n          throw new uP(hO.WS_ERR, \"init websocket failed! Error: \".concat(n.toString()));\n        }\n        const c = Cw();\n        this.store && this.store.recordJoinChannelService({\n          urls: o.map(e => e.url),\n          service: \"gateway\"\n        }, this.recordIndex), o.forEach(e => {\n          e.onopen = () => {\n            this.logger(\"onopen: ws \".concat(e.url, \" open cost \").concat(Date.now() - r, \"ms\")), this.websockets.forEach(t => {\n              t !== e && (t.onopen = null, t.onclose = null, t.onmessage = null, t.close(), this.logger(\"close backup websocket: \".concat(t.url)));\n            }), this.websockets.length = 0, c.resolve(e);\n          }, e.onclose = i => {\n            this.logger(\"onclose: ws \".concat(e.url, \" closed cost \").concat(Date.now() - r, \"ms state: \").concat(e.readyState));\n            const n = o.every(e => e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING);\n            this.logger(\"\".concat(t ? \"443\" : \"47xx\", \" websocket closed, all failed: \").concat(n)), n && (t || this.isTry443PortFailed || this.useProxy) ? (this.logger(\"onclose: all websocket is closed, \".concat(i.reason)), c.reject({\n              code: i.code,\n              reason: ax.A_ROUND_WS_FAILED\n            })) : !t && n && !this.isNormalPortFailed && this.try443PortTimeout && (this.logger(\"all 47xx websocket is closed, try 443 port\"), this.clearTimeout(), l()), t ? this.isTry443PortFailed = n : this.isNormalPortFailed = n;\n          }, e.onmessage = t => this.logger(\"\".concat(e.url, \" onmessage: \").concat(t.data));\n        }), this.websockets.push(...o);\n        const d = () => {\n            this.websockets.forEach(e => e.readyState !== WebSocket.OPEN && e.close());\n          },\n          l = () => {\n            if (c.isResolved) return d();\n            Dw().os === Aw.MAC_OS && Bw() && d(), this.createWebSocket(e, !0, !0).then(e => {\n              c.resolve(e);\n            }).catch(e => {\n              this.isNormalPortFailed && c.reject(e), this.logger(\"try 443 port to create ws failed\");\n            }), this.forceCloseTimeout = window.setTimeout(() => {\n              this.logger(\"5s timeout close un-opens, isWebsocket created: \", c.isResolved), this.forceCloseTimeout = null, d();\n            }, this.forceCloseWSDuration);\n          };\n        return i || (() => {\n          if (t || this.useProxy) return this.logger(\"add 5s timeout at \".concat(t ? \"try-443\" : \"proxy\", \" condition\")), this.forceCloseTimeout = window.setTimeout(() => {\n            this.forceCloseTimeout = null, d();\n          }, this.forceCloseWSDuration);\n          this.try443PortTimeout = window.setTimeout(() => {\n            this.logger(\"2s timeout, isWebsocket created: \", c.isResolved), this.try443PortTimeout = null, l();\n          }, this.try443PortDuration);\n        })(), c.promise;\n      }\n      chooseBestWebsocket(e, t, i, n) {\n        return this.useDoubleDomain = !!t, \"string\" == typeof e && (e = function (e) {\n          let t, i, n;\n          return [, t, i, n] = e.match(Hx) || [], t || ([, i, n] = e.match(Kx) || []), i && n || ([, i, n] = e.match(Yx) || []), i && n || ([, i] = e.match(zx) || []), i || iP.warning(\"un-destructible url: \", e), {\n            proxy: t,\n            host: i,\n            port: n || \"443\"\n          };\n        }(e)), this.recordIndex = n, this.useProxy = !!e.proxy, i && this.useProxy && (iP.warn(\"cannot use 443 only when use proxy\"), i = !1), this.createWebSocket(e, !!i, !1).finally(() => this.clearTimeout());\n      }\n    }\n    function Jx(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    class Qx extends NO {\n      get url() {\n        return this.websocket && this.websocket.url || this._websocketUrl;\n      }\n      get reconnectMode() {\n        return this._reconnectMode;\n      }\n      set reconnectMode(e) {\n        var t;\n        Ln(t = [\"tryNext\", \"recover\"]).call(t, e) && this.resetReconnectCount(e), this._reconnectMode = e;\n      }\n      get state() {\n        return this._state;\n      }\n      set state(e) {\n        e !== this._state && (this._state = e, \"reconnecting\" === this._state ? this.emit(WV.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(WV.CONNECTED) : \"closed\" === this._state ? this.emit(WV.CLOSED) : \"failed\" === this._state && this.emit(WV.FAILED));\n      }\n      resetReconnectCount(e) {\n        iP.debug(\"websocket reset reconnect count, reason: \" + e), this.reconnectCount = 0;\n      }\n      constructor(e, t) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],\n          r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],\n          o = arguments.length > 5 ? arguments[5] : void 0;\n        super(), iA(this, \"_websocketUrl\", null), iA(this, \"connectionID\", 0), iA(this, \"currentURLIndex\", 0), iA(this, \"urls\", []), iA(this, \"_reconnectMode\", \"tryNext\"), iA(this, \"reconnectReason\", void 0), iA(this, \"_initMutex\", void 0), iA(this, \"name\", void 0), iA(this, \"_state\", \"closed\"), iA(this, \"reconnectInterrupter\", void 0), iA(this, \"websocket\", void 0), iA(this, \"retryConfig\", void 0), iA(this, \"reconnectCount\", 0), iA(this, \"forceCloseTimeout\", 5e3), iA(this, \"onlineReconnectListener\", void 0), iA(this, \"useCompress\", void 0), iA(this, \"tryDoubleDomain\", !1), iA(this, \"use443PortOnly\", !1), iA(this, \"wsInflateLength\", 0), iA(this, \"wsDeflateLength\", 0), iA(this, \"closeEstablishingWs\", () => {}), iA(this, \"store\", void 0), iA(this, \"joinGatewayRecordIndex\", void 0), this.store = o, this.name = e, this.retryConfig = function (e) {\n          for (var t = 1; t < arguments.length; t++) {\n            var i = null != arguments[t] ? arguments[t] : {};\n            t % 2 ? Jx(Object(i), !0).forEach(function (t) {\n              iA(e, t, i[t]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Jx(Object(i)).forEach(function (t) {\n              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n            });\n          }\n          return e;\n        }({}, t), this.useCompress = i, this.tryDoubleDomain = n, this.use443PortOnly = r, this._initMutex = new PN(\"websocket\", o ? o.clientId : void 0);\n        const {\n            timeout: s,\n            timeoutFactor: a\n          } = t,\n          c = Math.max(300, Math.floor(3 * s / 5)),\n          d = Math.max(1.2, Math.floor(8 * a) / 10);\n        KO.ONLINE && (this.retryConfig.timeout = c, this.retryConfig.timeoutFactor = d), QO.on(YO.NETWORK_STATE_CHANGE, (e, t) => {\n          e !== t && (this.resetReconnectCount(\"network state change: \".concat(t, \" -> \").concat(e)), e === KO.ONLINE ? (this.retryConfig.timeout = c, this.retryConfig.timeoutFactor = d) : (this.retryConfig.timeout = s, this.retryConfig.timeoutFactor = a));\n        });\n      }\n      getConnection() {\n        return this.websocket || void 0;\n      }\n      async init(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n        const i = await this._initMutex.lock();\n        this._reconnectMode = \"tryNext\", this.forceCloseTimeout = t, this.urls = e, this.state = \"connecting\";\n        try {\n          var n;\n          const e = Cw(),\n            t = this.urls[this.currentURLIndex];\n          null === (n = this.store) || void 0 === n || n.beforeConnect(), function (e) {\n            return !(EP() || CD(\"USE_NEW_TOKEN\") || !CD(\"ENABLE_PREALLOC_PC\") && (null == e || !e.autoSubscribe || CD(\"FORCE_DISABLE_AUTO_SUB\")));\n          }(this.store) && this.emit(wx.PRE_CONNECT_PC), this.createWebSocketConnection(t).then(e.resolve).catch(e.reject), this.once(WV.CLOSED, () => {\n            e.reject(new pO(hO.WS_DISCONNECT));\n          }), this.once(WV.CONNECTED, e.resolve), await e.promise;\n        } catch (e) {} finally {\n          i();\n        }\n      }\n      close(e, t) {\n        if (this.currentURLIndex = 0, this.resetReconnectCount(\"close\"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {\n          this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;\n          const e = this.websocket;\n          t ? setTimeout(() => e.close(), 500) : e.close(), this.websocket = void 0, this._websocketUrl = null;\n        }\n        this.state = e ? \"failed\" : \"closed\", this.closeEstablishingWs && this.closeEstablishingWs();\n      }\n      reconnect(e, t) {\n        if (!this.websocket) return void iP.warning(\"[\".concat(this.name, \"] can not reconnect, no websocket\"));\n        void 0 !== e && (this.reconnectMode = e), iP.debug(\"[\".concat(this.name, \"] reconnect is triggered initiative\")), \"number\" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({\n          status: \"error\",\n          errors: [new Error(t)]\n        }, this.joinGatewayRecordIndex);\n        const i = this.websocket.onclose;\n        this.websocket.onclose = null, this.websocket.close(), i && i.bind(this.websocket)({\n          code: 9999,\n          reason: t\n        });\n      }\n      sendMessage(e) {\n        let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new pO(hO.WS_ABORT, \"websocket is not ready\");\n        try {\n          t || (e = JSON.stringify(e)), this.websocket.send(e);\n        } catch (e) {\n          throw new pO(hO.WS_ERR, \"send websocket message error\" + e.toString());\n        }\n      }\n      setWsInflateData(e) {\n        this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength;\n      }\n      getWsInflateData() {\n        const e = this.wsInflateLength,\n          t = this.wsDeflateLength;\n        return this.clearWsInflateData(), {\n          wsInflateLength: e,\n          wsDeflateLength: t\n        };\n      }\n      clearWsInflateData() {\n        this.wsInflateLength = 0, this.wsDeflateLength = 0;\n      }\n      async createWebSocketConnection(e) {\n        var t;\n        const i = Cw();\n        this.connectionID += 1, this.joinGatewayRecordIndex = void 0;\n        const n = e => {\n            var t;\n            null === (t = this.store) || void 0 === t || t.signalChannelOpen(), iP.debug(\"[\".concat(this.name, \"] websocket opened:\"), e), this.reconnectMode = \"retry\", this.state = \"connected\", this.resetReconnectCount(\"opened\"), i.resolve();\n          },\n          r = async e => {\n            var t;\n            if (iP.debug(\"[\".concat(this.name, \"] websocket close \").concat(null === (t = this.websocket) || void 0 === t ? void 0 : t.url, \", code: \").concat(e.code, \", reason: \").concat(e.reason, \", current mode: \").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i.reject(new pO(hO.WS_DISCONNECT, \"websocket close: \".concat(e.code))), this.close();else {\n              \"connected\" === this.state && (this.reconnectReason = e.reason, this.state = \"reconnecting\");\n              const t = XO(this, WV.WILL_RECONNECT, this.reconnectMode, e.reason) || this.reconnectMode,\n                n = await this.reconnectWithAction(t);\n              if (\"closed\" === this.state) return void iP.debug(\"[\".concat(this.connectionID, \"] ws is closed, no need to reconnect\"));\n              if (!n) return i.reject(new pO(hO.WS_DISCONNECT, \"websocket reconnect failed: \".concat(e.code))), this.close(!0);\n              i.resolve();\n            }\n          },\n          o = e => {\n            this.emit(WV.ON_MESSAGE, e);\n          },\n          s = e => {\n            iP.warn(\"[\".concat(this.connectionID, \"] ws open error \").concat(e));\n          };\n        this.websocket && (this.websocket.onclose = null, this.websocket.close()), CD(\"GATEWAY_WSS_ADDRESS\") && this.name.startsWith(\"gateway\") && (e = CD(\"GATEWAY_WSS_ADDRESS\")), iP.debug(\"[\".concat(this.name, \"] start connect, url:\"), e);\n        const a = null === (t = this.store) || void 0 === t ? void 0 : t.recordJoinChannelService({\n          startTs: Date.now(),\n          status: \"pending\",\n          service: \"gateway\"\n        });\n        try {\n          var c;\n          this._websocketUrl = Wx(e);\n          const t = await this.chooseBestWebsocketConnection(e);\n          this.websocket = t, n && n(this.websocket.url), this.websocket.onclose = r, this.websocket.onmessage = o, this.websocket.onerror = s, null === (c = this.store) || void 0 === c || c.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, a), this.joinGatewayRecordIndex = a;\n        } catch (e) {\n          const t = \"closed\" === this.state,\n            n = e instanceof pO,\n            o = n && e.code === hO.WS_ABORT,\n            s = n && e.code === hO.WS_ERR,\n            c = n ? e.message : e && (e.reason || e.toString());\n          iP.warning(\"[choose-best-ws] chooseBestWebsocket error: \".concat(c)), this.store && this.store.recordJoinChannelService({\n            endTs: Date.now(),\n            status: o ? \"aborted\" : \"error\",\n            errors: [e]\n          }, a), t || s ? (i.reject(t ? new pO(hO.WS_DISCONNECT, \"websocket is closed: \".concat(c)) : new pO(hO.WS_ERR, \"init websocket failed: \".concat(c))), s && iP.error(\"[\".concat(this.name, \"] init websocket failed: \").concat(c))) : r && r(e);\n        }\n        return i.promise;\n      }\n      async reconnectWithAction(e) {\n        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1;\n        if (0 === this.urls.length) return !1;\n        if (\"closed\" === this.state) return !1;\n        iP.warning(\"[choose-best-ws] action: =>\", e), this.onlineReconnectListener || QO.isOnline || !QO.onlineWaiter || (this.onlineReconnectListener = QO.onlineWaiter.then(() => {\n          this.onlineReconnectListener = void 0;\n        }));\n        let i = !0;\n        if (this.reconnectInterrupter = () => i = !1, t) {\n          const t = MN(this.reconnectCount, this.retryConfig);\n          iP.debug(\"[\".concat(this.name, \"] wait \").concat(t, \"ms to reconnect websocket, mode: \").concat(e)), await rp.race([fN(t), this.onlineReconnectListener || new rp(() => {})]);\n        }\n        if (\"closed\" === this._state || !i) return !1;\n        this.reconnectCount += 1;\n        const n = async (e, t) => {\n          this.emit(WV.RECONNECT_CREATE_CONNECTION, t), await this.createWebSocketConnection(e);\n        };\n        try {\n          if (\"retry\" === e) await n(this.urls[this.currentURLIndex], e);else if (\"tryNext\" === e) {\n            if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction(\"recover\", !1);\n            iP.debug(\"[\".concat(this.name, \"] websocket url length: \").concat(this.urls.length, \" current index: \").concat(this.currentURLIndex)), await n(this.urls[this.currentURLIndex], e);\n          } else \"recover\" === e && (iP.debug(\"[\".concat(this.name, \"] request new urls\")), this.resetReconnectCount(\"recover mode\"), this.urls = await zO(this, WV.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n(this.urls[this.currentURLIndex], e));\n        } catch (i) {\n          var r;\n          iP.error(\"[\".concat(this.name, \"] reconnect failed \").concat(i && i.toString()));\n          const n = null == i || null === (r = i.data) || void 0 === r ? void 0 : r.desc;\n          if (Array.isArray(n)) {\n            if (Ln(n).call(n, \"dynamic key expired\")) return this.emit(WV.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1;\n            if (Ln(n).call(n, \"request downgrade fallback\")) return this.emit(WV.ON_FALLBACK), !1;\n          }\n          return this.reconnectWithAction(e, t);\n        }\n        return !0;\n      }\n    }\n    class Zx extends Qx {\n      constructor(e, t) {\n        super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);\n      }\n      async chooseBestWebsocketConnection(e, t) {\n        const i = Cw(),\n          n = function (e, t) {\n            return new Xx(e, t);\n          }(this.forceCloseTimeout, this.store);\n        this.closeEstablishingWs = () => {\n          iP.debug(\"[choose-best-ws] close establishing websockets\"), n.closeAllWebsockets(), i.reject(new pO(hO.WS_ABORT, \"choose best websocket aborted\"));\n        };\n        const r = CD(\"GATEWAY_DOMAINS\");\n        return iP.debug(\"[choose-best-ws] currentDomain: \", e, \", domains: \", r, \"total: \".concat(this.urls.length), \"current: \".concat(this.currentURLIndex + 1)), n.chooseBestWebsocket(e, this.tryDoubleDomain, this.use443PortOnly, t).then(i.resolve).catch(i.reject), i.promise.finally(() => {\n          this.closeEstablishingWs = void 0;\n        });\n      }\n    }\n    class $x extends Qx {\n      constructor(e, t) {\n        super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);\n      }\n      async chooseBestWebsocketConnection(e, t) {\n        return new rp((i, n) => {\n          let r = !1;\n          const o = [];\n          this.closeEstablishingWs = () => {\n            iP.debug(\"[choose-best-ws] close establishing websockets\"), o.forEach(e => {\n              e.onclose = null, e.onopen = null, e.onmessage = null, e.close();\n            }), n(new pO(hO.WS_ABORT, \"choose best websocket aborted\"));\n          };\n          const s = CD(\"GATEWAY_DOMAINS\");\n          let a;\n          const c = e.indexOf(\"?h=\"),\n            d = s.find(t => -1 !== c ? Ln(e).call(e, t, c) : Ln(e).call(e, t));\n          iP.debug(\"[choose-best-ws] currentDomain: \", d, \", domains: \", s);\n          let l = !this.tryDoubleDomain || !d;\n          if (!l && d) {\n            var u;\n            const h = Date.now();\n            try {\n              s.forEach(t => {\n                const i = -1 === c ? e.replace(d, t) : e.substr(0, c) + e.substr(c).replace(d, t),\n                  n = new WebSocket(i);\n                n.binaryType = \"arraybuffer\", o.push(n), iP.debug(\"[choose-best-ws] ws is connecting:\", n.url);\n              });\n            } catch (e) {\n              for (iP.debug(\"[choose-best-ws] ws create failed, fallback to single url\"), o.forEach(e => e.close()); o.length;) o.pop();\n              l = !0;\n            }\n            null === (u = this.store) || void 0 === u || u.recordJoinChannelService({\n              urls: o.map(e => e.url),\n              service: \"gateway\"\n            }, t), o.forEach(e => {\n              e.onopen = () => {\n                if (r) return;\n                const t = Date.now() - h;\n                iP.debug(\"[choose-best-ws] ws open cost \".concat(t, \"ms\")), o.filter(t => t !== e).forEach(e => {\n                  iP.debug(\"[choose-best-ws]close backup websocket: \".concat(e.url)), e.close();\n                }), r = !0, i(e);\n              }, e.onclose = e => {\n                if (a = e, r) return;\n                o.find(e => !(e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING)) || (iP.debug(\"[choose-best-ws] all websocket is closed\"), r = !0, n(a));\n              }, e.onmessage = t => {\n                iP.debug(\"[choose-best-ws]\".concat(e.url, \" onmessage: \").concat(t.data));\n              };\n            }), fN(this.forceCloseTimeout).then(() => {\n              o.forEach(e => {\n                e.readyState !== WebSocket.OPEN && e.close();\n              });\n            });\n          }\n          if (l) {\n            var h;\n            let r;\n            iP.debug(\"[choose-best-ws] use single url: \", e), null === (h = this.store) || void 0 === h || h.recordJoinChannelService({\n              urls: [e],\n              service: \"gateway\"\n            }, t);\n            try {\n              r = new WebSocket(e), o.push(r), r.binaryType = \"arraybuffer\";\n            } catch (e) {\n              const t = new pO(hO.WS_ERR, \"init websocket failed! Error: \".concat(e.toString()));\n              return iP.error(\"[\".concat(this.name, \"]\").concat(t)), void n(t);\n            }\n            r.onopen = () => {\n              i(r);\n            }, r.onclose = e => {\n              n(e);\n            }, r.onmessage = e => {\n              iP.debug(\"[choose-best-ws]\".concat(r.url, \" onmessage: \").concat(e.data));\n            }, fN(this.forceCloseTimeout).then(() => {\n              r && r.readyState !== WebSocket.OPEN && r.close();\n            });\n          }\n        }).then(e => (this.closeEstablishingWs = void 0, e)).catch(e => {\n          throw this.closeEstablishingWs = void 0, e;\n        });\n      }\n    }\n    class eF extends NO {\n      get connectionState() {\n        return this._connectionState;\n      }\n      set connectionState(e) {\n        e !== this._connectionState && (this._connectionState = e, e === VV.CONNECTED ? this.emit(xV.WS_CONNECTED) : e === VV.RECONNECTING ? this.emit(xV.WS_RECONNECTING, this._websocketReconnectReason) : e === VV.CLOSED && this.emit(xV.WS_CLOSED, this._disconnectedReason));\n      }\n      get currentURLIndex() {\n        return this.websocket.currentURLIndex;\n      }\n      get url() {\n        return this.websocket && this.websocket.url || null;\n      }\n      get rtt() {\n        return this.rttRolling.mean();\n      }\n      constructor(e, t) {\n        super(), iA(this, \"__name__\", \"AgoraRTCSignal\"), iA(this, \"_disconnectedReason\", void 0), iA(this, \"_websocketReconnectReason\", void 0), iA(this, \"_connectionState\", VV.CLOSED), iA(this, \"reconnectToken\", void 0), iA(this, \"websocket\", void 0), iA(this, \"openConnectionTime\", void 0), iA(this, \"clientId\", void 0), iA(this, \"lastMsgTime\", Date.now()), iA(this, \"uploadCache\", []), iA(this, \"uploadCacheInterval\", void 0), iA(this, \"rttRolling\", new xN(5)), iA(this, \"pingpongTimer\", void 0), iA(this, \"wsInflateDataTimer\", void 0), iA(this, \"pingpongTimeoutCount\", 0), iA(this, \"ortc\", void 0), iA(this, \"joinResponse\", void 0), iA(this, \"multiIpOption\", void 0), iA(this, \"initError\", void 0), iA(this, \"spec\", void 0), iA(this, \"store\", void 0), iA(this, \"onWebsocketMessage\", e => {\n          if (e.data instanceof ArrayBuffer) return void this.emit(xV.ON_BINARY_DATA, e.data);\n          const t = JSON.parse(e.data);\n          if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n            const e = \"res-@\".concat(t._id);\n            this.emit(e, t._result, t._message);\n          } else if (Object.prototype.hasOwnProperty.call(t, \"_type\")) {\n            if (this.emit(t._type, t._message), t._type === jV.ON_NOTIFICATION && this.handleNotification(t._message), t._type === jV.ON_USER_BANNED) switch (t._message.error_code) {\n              case 14:\n                this.close(VO.UID_BANNED);\n                break;\n              case 15:\n                this.close(VO.IP_BANNED);\n                break;\n              case 16:\n                this.close(VO.CHANNEL_BANNED);\n            }\n            if (t._type === jV.ON_USER_LICENSE_BANNED) switch (t._message.error_code) {\n              case UV.ERR_LICENSE_MISSING:\n                this.close(VO.LICENSE_MISSING);\n                break;\n              case UV.ERR_LICENSE_EXPIRED:\n                this.close(VO.LICENSE_EXPIRED);\n                break;\n              case UV.ERR_LICENSE_MINUTES_EXCEEDED:\n                this.close(VO.LICENSE_MINUTES_EXCEEDED);\n                break;\n              case UV.ERR_LICENSE_PERIOD_INVALID:\n                this.close(VO.LICENSE_PERIOD_INVALID);\n                break;\n              case UV.ERR_LICENSE_MULTIPLE_SDK_SERVICE:\n                this.close(VO.LICENSE_MULTIPLE_SDK_SERVICE);\n                break;\n              case UV.ERR_LICENSE_ILLEGAL:\n                this.close(VO.LICENSE_ILLEGAL);\n                break;\n              default:\n                this.close();\n            }\n          }\n        }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new Zx(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, CD(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\"), CD(\"JOIN_GATEWAY_USE_443PORT_ONLY\"), t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n          this.connectionState === VV.CONNECTED && this.reconnect(\"retry\", HO.OFFLINE);\n        });\n      }\n      async request(e, t, i, n) {\n        const r = SN(6, \"\"),\n          o = {\n            _id: r,\n            _type: e,\n            _message: t\n          },\n          s = this.websocket.connectionID,\n          a = () => new rp((t, i) => {\n            if (this.connectionState === VV.CONNECTED) return t();\n            const n = () => {\n                this.off(xV.WS_CLOSED, r), t();\n              },\n              r = () => {\n                this.off(xV.WS_CONNECTED, n), i(new uP(hO.WS_ABORT));\n              };\n            this.once(xV.WS_CONNECTED, n), this.once(xV.WS_CLOSED, r), e !== FV.PUBLISH && e !== FV.PUBLISH_DATASTREAM && e !== FV.SUBSCRIBE && e !== FV.SUBSCRIBE_DATASTREAM && e !== FV.UNSUBSCRIBE && e !== FV.UNSUBSCRIBE_DATASTREAM && e !== FV.UNPUBLISH && e !== FV.UNPUBLISH_DATASTREAM && e !== FV.CONTROL && e !== FV.RESTART_ICE || this.once(xV.DISCONNECT_P2P, () => {\n              i(new uP(hO.DISCONNECT_P2P));\n            }), e !== FV.PUBLISH && e !== FV.RESTART_ICE || this.once(xV.ABORT_P2P_EXECUTION, () => {\n              i(new uP(hO.DISCONNECT_P2P));\n            });\n          });\n        if (this.connectionState !== VV.CONNECTING && this.connectionState !== VV.RECONNECTING || e === FV.JOIN || e === FV.REJOIN || (await a()), this.websocket.sendMessage(o, !0), n) return;\n        const c = new rp((i, n) => {\n          let o = !1;\n          const a = (n, r) => {\n            o = !0, i({\n              isSuccess: \"success\" === n,\n              message: r || {}\n            }), this.off(xV.WS_CLOSED, c), this.off(xV.WS_RECONNECTING, c), this.emit(xV.REQUEST_SUCCESS, e, t);\n          };\n          this.once(\"res-@\".concat(r), a);\n          const c = () => {\n            n(new uP(hO.WS_ABORT, \"type: \".concat(e))), this.off(xV.WS_CLOSED, c), this.off(xV.WS_RECONNECTING, c), this.off(\"res-@\".concat(r), a);\n          };\n          this.once(xV.WS_CLOSED, c), this.once(xV.WS_RECONNECTING, c), fN(CD(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n            this.websocket.connectionID !== s || o || (iP.warning(\"[\".concat(this.clientId, \"] ws request timeout, type: \").concat(e)), this.emit(xV.REQUEST_TIMEOUT, e, t));\n          });\n        });\n        let d = null;\n        try {\n          d = await c;\n        } catch (n) {\n          if (this.connectionState === VV.CLOSED || e === FV.LEAVE) throw new uP(hO.WS_ABORT);\n          return !this.spec.forceWaitGatewayResponse || i ? n.throw() : e === FV.JOIN || e === FV.REJOIN ? null : (await a(), await this.request(e, t));\n        }\n        if (d.isSuccess) return d.message;\n        const l = Number(d.message.error_code || d.message.code),\n          u = Bx(l),\n          h = new uP(hO.UNEXPECTED_RESPONSE, \"\".concat(u.desc, \": \").concat(d.message.error_str), {\n            code: l,\n            data: d.message,\n            desc: u.desc\n          });\n        return \"success\" === u.action ? d.message : (iP.warning(\"[\".concat(this.clientId, \"] [\").concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(l, \", message: \").concat(u.desc, \", action: \").concat(u.action)), l === UV.ERR_TOO_MANY_BROADCASTERS ? e === FV.JOIN || e === FV.REJOIN ? (this.initError = h, this.close(), h.throw()) : h.throw() : \"failed\" === u.action ? h.throw() : \"quit\" === u.action ? (this.initError = h, this.close(), h.throw()) : (l === UV.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, iP.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", HO.MULTI_IP)) : this.reconnect(u.action, HO.SERVER_ERROR), e === FV.JOIN || e === FV.REJOIN ? null : await this.request(e, t)));\n      }\n      waitMessage(e, t) {\n        return new rp(i => {\n          const n = r => {\n            (!t || t(r)) && (this.off(e, n), i(r));\n          };\n          this.on(e, n);\n        });\n      }\n      uploadWRTCStats(e) {\n        if (!this.store.sessionId) return void iP.warn(\"[\".concat(this.clientId, \"] no session id when upload wrtc stats\"));\n        const t = {\n          lts: Date.now(),\n          sid: this.store.sessionId,\n          uid: this.store.intUid,\n          stats: e\n        };\n        this.upload(BV.WRTC_STATS, t);\n      }\n      upload(e, t) {\n        const i = {\n          _type: e,\n          _message: t\n        };\n        try {\n          this.websocket.sendMessage(i);\n        } catch (e) {\n          const t = CD(\"MAX_UPLOAD_CACHE\") || 50;\n          this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n            if (this.connectionState !== VV.CONNECTED) return;\n            const e = this.uploadCache.splice(0, 1)[0];\n            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n          }, CD(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n        }\n      }\n      send(e, t) {\n        const i = {\n          _type: e,\n          _message: t\n        };\n        this.websocket.sendMessage(i);\n      }\n      init(e) {\n        return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new rp((t, i) => {\n          this.once(xV.WS_CONNECTED, () => t(this.joinResponse)), this.once(xV.WS_CLOSED, e => i(this.initError || new uP(hO.WS_ABORT, e))), this.connectionState = VV.CONNECTING, this.websocket.init(e).catch(i), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {\n            this.handleWsInflateData();\n          }, 2e4);\n        });\n      }\n      close(e) {\n        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || VO.LEAVE, this.connectionState = VV.CLOSED, iP.debug(\"[\".concat(this.clientId, \"] \") + \"will close websocket in signal\"), this.websocket.close();\n      }\n      async join() {\n        if (!this.joinResponse) {\n          this.emit(xV.ABORT_P2P_EXECUTION), this.store.signalConnected();\n          const e = await zO(this, xV.REQUEST_JOIN_INFO);\n          this.store.joinReq();\n          const t = await this.request(FV.JOIN, e);\n          if (this.ortc = null == e ? void 0 : e.ortc, this.store.joinRep(), !t) return this.emit(xV.REPORT_JOIN_GATEWAY, ax.TIMEOUT, this.url || \"\"), !1;\n          this.joinResponse = t, this.emit(xV.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n        }\n        return this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n      }\n      async rejoin() {\n        if (!this.reconnectToken) throw new uP(hO.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n        const e = JO(this, xV.REQUEST_REJOIN_INFO);\n        e.token = this.reconnectToken;\n        const t = await this.request(FV.REJOIN, e);\n        return !!t && (this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {\n          this.emit(jV.ON_USER_ONLINE, {\n            uid: e.uid\n          }), e.audio && this.emit(jV.ON_ADD_AUDIO_STREAM, {\n            uid: e.uid,\n            uint_id: e.uint_id,\n            audio: !0,\n            ssrcId: e.audio_ssrc\n          }), e.video && this.emit(jV.ON_ADD_VIDEO_STREAM, {\n            uid: e.uid,\n            uint_id: e.uint_id,\n            video: !0,\n            ssrcId: e.video_ssrc\n          }), e.audio_mute ? this.emit(jV.MUTE_AUDIO, {\n            uid: e.uid\n          }) : this.emit(jV.UNMUTE_AUDIO, {\n            uid: e.uid\n          }), e.video_mute ? this.emit(jV.MUTE_VIDEO, {\n            uid: e.uid\n          }) : this.emit(jV.UNMUTE_VIDEO, {\n            uid: e.uid\n          }), e.audio_enable_local ? this.emit(jV.ENABLE_LOCAL_AUDIO, {\n            uid: e.uid\n          }) : this.emit(jV.DISABLE_LOCAL_AUDIO, {\n            uid: e.uid\n          }), e.video_enable_local ? this.emit(jV.ENABLE_LOCAL_VIDEO, {\n            uid: e.uid\n          }) : this.emit(jV.DISABLE_LOCAL_VIDEO, {\n            uid: e.uid\n          }), e.audio || e.video || this.emit(jV.ON_REMOVE_STREAM, {\n            uid: e.uid,\n            uint_id: e.uint_id\n          });\n        }), !0);\n      }\n      reconnect(e, t) {\n        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n      }\n      async downgradeCodec(e) {\n        if (!this.ortc) return !1;\n        const t = {\n          downgrade_codec: e,\n          ortc: this.ortc\n        };\n        return !!(await this.request(FV.DOWNGRADE_CODEC, t));\n      }\n      handleNotification(e) {\n        iP.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n        const t = Bx(e.code);\n        if (28 === e.code && \"detail\" in e && (iP.info(\"[\".concat(this.clientId, \"] receive recover notification: \"), e.detail), this.emit(xV.RECOVER_NOTIFICATION, e.detail)), \"success\" !== t.action) {\n          if (\"failed\" !== t.action) return \"quit\" === t.action ? e.code === UV.ERR_REPEAT_JOIN_CHANNEL && CD(\"IGNORE_UID_CHECK\") ? void this.close(VO.UID_CONFLICT) : (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(VO.UID_BANNED), void this.close()) : e.code === UV.K_VOS_FALLBACK && \"detail\" in e ? (iP.info(\"[\".concat(this.clientId, \"] receive vos fallback notification: \"), e.detail), \"FALLBACKCN\" === e.detail && CD(\"ENABLE_QUALITY_FALLBACK\") ? void zO(this, xV.VOS_FALLBACK_PROMISE, e.detail).then(() => {\n            this.reconnect(\"recover\", t.desc);\n          }).catch(e => {\n            iP.debug(\"[\".concat(this.clientId, \"] cancel vos fallback cn, error: \"), e);\n          }) : \"fallback_hls\" === e.detail && CD(\"ENABLE_FALLBACK_TO_HLS\") ? (this.emit(xV.VOS_FALLBACK, e.detail), void this.close(VO.FALLBACK_TO_HLS)) : this.reconnect(t.action, t.desc)) : void this.reconnect(t.action, HO.SERVER_ERROR);\n          iP.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n        }\n      }\n      handlePingPong() {\n        if (!this.websocket || \"connected\" !== this.websocket.state) return;\n        this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n        const e = CD(\"PING_PONG_TIME_OUT\"),\n          t = Date.now();\n        this.pingpongTimeoutCount >= e && (iP.warning(\"[\".concat(this.clientId, \"] PING-PONG Timeout. Last Socket Message: \").concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > CD(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", HO.TIMEOUT) : this.request(FV.PING, void 0, !0).then(() => {\n          this.pingpongTimeoutCount = 0;\n          const e = Date.now() - t;\n          this.rttRolling.add(e), CD(\"REPORT_STATS\") && this.send(FV.PING_BACK, {\n            pingpongElapse: e\n          });\n        }).catch(e => {});\n      }\n      handleWsInflateData() {\n        const {\n          wsInflateLength: e,\n          wsDeflateLength: t\n        } = this.websocket.getWsInflateData();\n        0 !== e && 0 !== t && this.upload(BV.WS_INFLATE_DATA_LENGTH, {\n          ws_deflate_length: t,\n          ws_inflate_length: e\n        });\n      }\n      handleWebsocketEvents() {\n        this.websocket.on(WV.RECONNECT_CREATE_CONNECTION, e => {\n          this.emit(xV.WS_RECONNECT_CREATE_CONNECTION, e);\n        }), this.websocket.on(WV.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(WV.CLOSED, () => {\n          this.connectionState = VV.CLOSED;\n        }), this.websocket.on(WV.FAILED, () => {\n          this._disconnectedReason = VO.NETWORK_ERROR, this.connectionState = VV.CLOSED;\n        }), this.websocket.on(WV.RECONNECTING, e => {\n          this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === VV.CONNECTED ? this.connectionState = VV.RECONNECTING : this.connectionState = VV.CONNECTING;\n        }), this.websocket.on(WV.WILL_RECONNECT, (e, t, i) => {\n          const n = JO(this, xV.IS_P2P_DISCONNECTED),\n            r = n || \"retry\" !== e;\n          n && \"retry\" === e && (iP.debug(\"\".concat(this.clientId, \" reconnect mode is retry, but p2p lost, change to tryNext\")), e = \"tryNext\", t = ax.P2P_DISCONNECTED), r && (iP.debug(\"\".concat(this.clientId, \" will renewSession, reconnect mode: \").concat(e)), this.emit(xV.REPORT_JOIN_GATEWAY, t || ax.UNKNOWN_REASON, this.url || \"\"), this.reconnectToken = void 0, this.emit(xV.DISCONNECT_P2P)), i(e);\n        }), this.websocket.on(WV.CONNECTED, () => {\n          this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {\n            iP.warning(\"[\".concat(this.clientId, \"] rejoin failed \").concat(e)), this.reconnect(\"tryNext\", HO.SERVER_ERROR);\n          }) : this.join().catch(e => {\n            if (this.emit(xV.REPORT_JOIN_GATEWAY, e, this.url || \"\"), e instanceof uP) {\n              if (e.code === hO.UNEXPECTED_RESPONSE && e.data.code === UV.ERR_NO_AUTHORIZED) return this.initError = new uP(hO.TOKEN_EXPIRE, \"dynamic key expired\"), void this.close(VO.TOKEN_EXPIRE);\n              iP.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", HO.SERVER_ERROR) : (this.initError = e, this.close());\n            }\n          });\n        }), this.websocket.on(WV.REQUEST_NEW_URLS, (e, t) => {\n          zO(this, xV.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n        }), this.websocket.on(WV.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n          this.emit(jV.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n        }), this.websocket.on(wx.PRE_CONNECT_PC, () => {\n          this.emit(xV.PRE_CONNECT_PC);\n        }), this.websocket.on(WV.ON_FALLBACK, () => {\n          CD(\"ENABLE_FALLBACK_TO_HLS\") && this.emit(xV.VOS_FALLBACK, \"fallback_hls\");\n        });\n      }\n    }\n    let tF = function (e) {\n        return e.NATIVE_RTC = \"native_rtc\", e.NATIVE_RTM = \"native_rtm\", e.WEB_RTC = \"web_rtc\", e.WEB_RTM = \"web_rtm\", e;\n      }({}),\n      iF = function (e) {\n        return e[e.CHOOSE_SERVER = 11] = \"CHOOSE_SERVER\", e[e.CLOUD_PROXY = 18] = \"CLOUD_PROXY\", e[e.CLOUD_PROXY_5 = 20] = \"CLOUD_PROXY_5\", e[e.CLOUD_PROXY_FALLBACK = 26] = \"CLOUD_PROXY_FALLBACK\", e;\n      }({});\n    function nF(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function rF(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? nF(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : nF(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    let oF = 0;\n    function sF(e) {\n      const t = CD(\"TURN_DOMAINS\");\n      oF = (oF + 1) % t.length;\n      const i = t[oF] || \"edge.agora.io\";\n      return e.match(/^[\\.\\:\\d]+$/) ? \"\".concat(e.replace(/[^\\d]/g, \"-\"), \".\").concat(i) : (iP.debug(\"Cannot recognized as ip address: \".concat(e, \", use as host2\")), e);\n    }\n    function aF(e) {\n      try {\n        const t = CD(\"TURN_DOMAINS\"),\n          i = CD(\"GATEWAY_DOMAINS\").concat(t).find(t => Ln(e).call(e, t));\n        if (i) {\n          return e.split(\".\".concat(i))[0].replace(/-/g, \".\");\n        }\n        return e;\n      } catch (t) {\n        return iP.debug(\"serverUrlToIp error, fallback to url\", e), e;\n      }\n    }\n    function cF(e, t) {\n      e.addresses || (e.addresses = []);\n      const i = function (e, t) {\n          if (CD(\"CONNECT_GATEWAY_WITHOUT_DOMAIN\")) return e.map(e => {\n            let {\n              ip: t,\n              port: i\n            } = e;\n            return {\n              address: \"\".concat(t, \":\").concat(i)\n            };\n          });\n          const i = CD(\"GATEWAY_DOMAINS\");\n          let n = i[1] && Ln(t).call(t, i[1]) ? 1 : 0;\n          return e.map(e => {\n            let {\n              domain_prefix: t,\n              port: r,\n              ip: o\n            } = e;\n            if (t) return {\n              address: \"\".concat(t, \".\").concat(i[n++ % i.length], \":\").concat(r)\n            };\n            const s = /^[\\.\\:\\d]+$/.test(o),\n              a = s ? \"\".concat(o.replace(/[^\\d]/g, \"-\"), \".\").concat(i[n++ % i.length], \":\").concat(r) : \"\".concat(o, \":\").concat(r);\n            return s || iP.debug(\"Cannot recognized as ip address: \".concat(o, \", use as host3\")), {\n              ip: o,\n              port: r,\n              address: a\n            };\n          });\n        }(e.addresses, t),\n        n = Array.isArray(e.detail) && e.detail[18];\n      if (n && \"string\" == typeof n) {\n        const e = n.split(\";\");\n        for (let t = 0; t < e.length; t++) {\n          var r;\n          const n = kg(r = e[t]).call(r);\n          i[t] && n && (i[t].ip6 = n);\n        }\n      }\n      const o = e.detail && e.detail.candidate;\n      let s;\n      if (o) {\n        const [e, t] = o.split(\":\");\n        e && t && (s = {\n          port: Number(t),\n          ip: e,\n          address: \"\".concat(e, \":\").concat(t)\n        });\n      }\n      return {\n        gatewayAddrs: i,\n        apGatewayAddress: s,\n        uid: e.uid,\n        cid: e.cid,\n        cert: e.cert,\n        vid: e.detail && e.detail[8],\n        uni_lbs_ip: e.detail && e.detail[1],\n        res: e,\n        csIp: e.detail && e.detail[502]\n      };\n    }\n    function dF(e) {\n      return \"number\" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;\n    }\n    function lF(e) {\n      const t = e._encoderConfig;\n      if (!t) return {};\n      const i = {\n        resolution: t.width && t.height ? \"\".concat(dF(t.width), \"x\").concat(dF(t.height)) : void 0,\n        maxVideoBW: t.bitrateMax,\n        minVideoBW: t.bitrateMin\n      };\n      return \"number\" == typeof t.frameRate ? (i.maxFrameRate = t.frameRate, i.minFrameRate = t.frameRate) : t.frameRate && (i.maxFrameRate = t.frameRate.max || t.frameRate.ideal || t.frameRate.exact || t.frameRate.min, i.minFrameRate = t.frameRate.min || t.frameRate.ideal || t.frameRate.exact || t.frameRate.max), i;\n    }\n    function uF(e) {\n      return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0;\n    }\n    function hF(e, t) {\n      let i, n, r;\n      switch (t) {\n        case iF.CHOOSE_SERVER:\n          n = 4096, r = \"choose server\";\n          break;\n        case iF.CLOUD_PROXY:\n          n = 1048576, r = \"proxy\";\n          break;\n        case iF.CLOUD_PROXY_5:\n          n = 4194304, r = \"proxy5\";\n          break;\n        case iF.CLOUD_PROXY_FALLBACK:\n          n = 4194310, r = \"proxy fallback\";\n          break;\n        default:\n          throw new uP(hO.UNEXPECTED_ERROR, \"multi unlibs response transformer get unknown service id\", {\n            csIp: e.detail && e.detail[502],\n            retry: !1\n          });\n      }\n      if (e.response_body.forEach(t => {\n        t.buffer && t.buffer.flag === n && (i = {\n          code: t.buffer.code,\n          addresses: (t.buffer.edges_services || []).map(e => rF(rF({}, e), {}, {\n            ticket: t.buffer.cert\n          })),\n          server_ts: e.enter_ts,\n          uid: t.buffer.uid,\n          cid: t.buffer.cid,\n          cname: t.buffer.cname,\n          detail: rF(rF({}, t.buffer.detail), e.detail),\n          flag: t.buffer.flag,\n          opid: e.opid,\n          cert: t.buffer.cert\n        });\n      }), !i) throw new uP(hO.MULTI_UNILBS_RESPONSE_ERROR, \"cannot parse response \".concat(r, \" from multi unilbs response\"), {\n        csIp: e.detail && e.detail[502]\n      });\n      return i;\n    }\n    async function pF(e, t) {\n      return await rp.all(e.addresses.map(async e => ({\n        address: sF(e.ip),\n        tcpport: e.port,\n        udpport: e.port,\n        username: t && CD(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? t.toString() : ED.username,\n        password: t && CD(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? await OO(t.toString()) : ED.password\n      })));\n    }\n    function _F(e, t) {\n      const i = t.getMediaStreamTrack(!0).getSettings(),\n        n = t.videoHeight || i.height,\n        r = t.videoWidth || i.width;\n      return n && r ? Math.max(Math.min(n, r) / Math.min(dF(e.height), dF(e.width)), 1) : (iP.warning(\"can't get ori-track's height, default scale down 4 times for low stream\"), 4);\n    }\n    function EF(e) {\n      let {\n        candidateType: t,\n        relayProtocol: i,\n        type: n,\n        address: r,\n        port: o,\n        protocol: s\n      } = e;\n      const a = {\n        candidateType: t,\n        relayProtocol: i,\n        protocol: s\n      };\n      if (\"local-candidate\" !== n) {\n        const e = r.split(\".\");\n        e.length >= 4 && (e[1] = \"*\", e[2] = \"*\"), a.address = e.join(\".\"), a.port = o;\n      }\n      return a;\n    }\n    function mF(e) {\n      const t = e.split(\":\"),\n        i = e.split(/[-.]/),\n        n = Ln(e).call(e, \"-\") ? \"-\" : \".\";\n      let r = e;\n      return t.length > 1 ? i.length > 1 ? (i[1] = \"**\", r = i[0] + n + \"**:\" + t[t.length - 1]) : r = t.length > 2 ? t[0] + n + \"**:\" + t[t.length - 1] : \"**:\" + t[t.length - 1] : i.length > 1 && (r = i[0] + n + \"**\"), r;\n    }\n    function fF(e, t) {\n      return e.getTransceivers().find(e => e.sender.track === t || e.receiver.track === t);\n    }\n    function SF() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CD(\"SVC_MODE\");\n      if (CD(\"ENABLE_SVC\")) return function (e) {\n        return e in iD;\n      }(e) ? e : iD.L1T3;\n    }\n    const gF = {\n      [fx.VIDEO]: [{\n        key: \"abs-send-time\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\"\n      }, {\n        key: \"video-orientation\",\n        extensionName: \"urn:3gpp:video-orientation\"\n      }, {\n        key: \"draft-holmer-rmcat-transport-wide-cc-extensions-01\",\n        extensionName: \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\"\n      }, {\n        key: \"playout-delay\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\"\n      }, {\n        key: \"video-content-type\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/video-content-type\"\n      }, {\n        key: \"color-space\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/color-space\"\n      }, {\n        key: \"video-timing\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/video-timing\"\n      }],\n      [fx.AUDIO]: [{\n        key: \"ssrc-audio-level\",\n        extensionName: \"urn:ietf:params:rtp-hdrext:ssrc-audio-level\"\n      }, {\n        key: \"draft-holmer-rmcat-transport-wide-cc-extensions-01\",\n        extensionName: \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\"\n      }, {\n        key: \"abs-send-time\",\n        extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\"\n      }]\n    };\n    function TF(e) {\n      e.send && (vF(fx.VIDEO, e.send.videoExtensions), vF(fx.AUDIO, e.send.audioExtensions)), e.recv && (vF(fx.VIDEO, e.recv.videoExtensions), vF(fx.AUDIO, e.recv.audioExtensions)), e.sendrecv && (vF(fx.VIDEO, e.sendrecv.videoExtensions), vF(fx.AUDIO, e.sendrecv.audioExtensions));\n    }\n    function RF(e, t) {\n      e.send && (CF(fx.VIDEO, e.send.videoExtensions, t.send.videoExtensions), CF(fx.AUDIO, e.send.audioExtensions, t.send.audioExtensions)), e.recv && (CF(fx.VIDEO, e.recv.videoExtensions, t.recv.videoExtensions), CF(fx.AUDIO, e.recv.audioExtensions, t.recv.audioExtensions));\n    }\n    function CF(e, t, i) {\n      t.forEach(t => {\n        var n;\n        const r = gF[e].find(e => {\n          var i;\n          let {\n            key: n\n          } = e;\n          return Ln(i = t.extensionName).call(i, n);\n        });\n        if (!r) return;\n        const o = i.find(e => {\n          let {\n            extensionName: t\n          } = e;\n          return Ln(t).call(t, r.key);\n        });\n        o && Ln(n = o.extensionName).call(n, \"gdpr_forbidden\") && (t.extensionName = o.extensionName);\n      });\n    }\n    function vF(e, t) {\n      t.forEach(t => {\n        var i;\n        const n = gF[e].find(e => {\n          var i;\n          let {\n            key: n\n          } = e;\n          return Ln(i = t.extensionName).call(i, n);\n        });\n        Ln(i = t.extensionName).call(i, \"gdpr_forbidden\") && n && (t.extensionName = n.extensionName);\n      });\n    }\n    function yF(e) {\n      return \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e || Ln(e).call(e, \"abs-send-time\");\n    }\n    function IF(e) {\n      return \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e || Ln(e).call(e, \"draft-holmer-rmcat-transport-wide-cc-extensions-01\");\n    }\n    function AF(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function bF(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? AF(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : AF(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    function wF(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n        n = arguments.length > 3 ? arguments[3] : void 0;\n      const {\n          filterRTX: r,\n          filterVideoFec: o,\n          filterAudioFec: s,\n          filterAudioCodec: a,\n          filterVideoCodec: c,\n          unsupportedVideoUplinkCodec: d,\n          unsupportedVideoDownlinkCodec: l\n        } = t,\n        {\n          useXR: u\n        } = i;\n      let h = [],\n        p = [],\n        _ = [],\n        E = [],\n        m = !1,\n        f = !1;\n      if (LD(e).mediaDescriptions.forEach(e => {\n        n && n !== e.attributes.direction || (\"video\" !== e.media.mediaType || m || (p = e.attributes.payloads, E = e.attributes.extmaps, m = !0), \"audio\" !== e.media.mediaType || f || (h = e.attributes.payloads, _ = e.attributes.extmaps, f = !0));\n      }), !E || 0 === p.length) throw new Error(\"Cannot get video capabilities from SDP.\");\n      if (!_ || 0 === h.length) throw new Error(\"Cannot get audio capabilities from SDP.\");\n      if (p.forEach(e => {\n        var t;\n        null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)), u && e.rtcpFeedbacks.push({\n          type: \"rrtr\"\n        });\n      }), h.forEach(e => {\n        var t;\n        null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)), u && e.rtcpFeedbacks.push({\n          type: \"rrtr\"\n        });\n      }), r && (h = h.filter(e => {\n        var t;\n        return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n      }), p = p.filter(e => {\n        var t;\n        return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n      })), o) {\n        const e = p.filter(e => {\n            var t;\n            return /(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n          }),\n          t = zF(e, p).map(e => e.payloadType),\n          i = [...e.map(e => e.payloadType), ...t];\n        p = p.filter(e => !Ln(i).call(i, e.payloadType));\n      }\n      if (s && (h = h.filter(e => {\n        var t;\n        return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n      })), a && (null == a ? void 0 : a.length) > 0 && (h = h.filter(e => {\n        var t;\n        return Ln(a).call(a, (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n      })), c && (null == c ? void 0 : c.length) > 0) {\n        const e = p.filter(e => {\n          var t;\n          return Ln(c).call(c, (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n        });\n        p = e.concat(r ? [] : zF(e, p));\n      }\n      const S = CD(\"UNSUPPORTED_VIDEO_CODEC\");\n      if (S && S.length > 0) {\n        const e = p.filter(e => e.rtpMap && Ln(S).call(S, e.rtpMap.encodingName.toLowerCase())),\n          t = zF(e, p),\n          i = e.concat(t).map(e => e.payloadType);\n        p = p.filter(e => !Ln(i).call(i, e.payloadType)), iP.debug(\"unsupportedVideoCodec: \".concat(S, \", toBeRemoved: \").concat(i));\n      }\n      if (d && d.length > 0 && \"sendonly\" === n) {\n        const e = p.filter(e => e.rtpMap && Ln(d).call(d, e.rtpMap.encodingName.toLowerCase())),\n          t = zF(e, p),\n          i = e.concat(t).map(e => e.payloadType);\n        p = p.filter(e => !Ln(i).call(i, e.payloadType)), iP.debug(\"unsupportedVideoUplinkCodec: \".concat(d, \", toBeRemoved: \").concat(i));\n      }\n      if (l && l.length > 0 && \"recvonly\" === n) {\n        const e = p.filter(e => e.rtpMap && Ln(l).call(l, e.rtpMap.encodingName.toLowerCase())),\n          t = zF(e, p),\n          i = e.concat(t).map(e => e.payloadType);\n        p = p.filter(e => !Ln(i).call(i, e.payloadType)), iP.debug(\"unsupportedVideoDownlinkCodec: \".concat(l, \", toBeRemoved: \").concat(i));\n      }\n      return {\n        audioCodecs: h,\n        videoCodecs: p,\n        audioExtensions: _,\n        videoExtensions: E\n      };\n    }\n    function OF(e) {\n      const t = LD(e);\n      let i, n;\n      for (const e of t.mediaDescriptions) {\n        if (!i) {\n          const t = e.attributes.iceUfrag,\n            n = e.attributes.icePwd;\n          if (!t || !n) throw new Error(\"Cannot get iceUfrag or icePwd from SDP.\");\n          i = {\n            iceUfrag: t,\n            icePwd: n\n          };\n        }\n        if (!n) {\n          const t = e.attributes.fingerprints;\n          t.length > 0 && (n = {\n            fingerprints: t\n          });\n        }\n      }\n      if (!n && t.attributes.fingerprints.length > 0 && (n = {\n        fingerprints: t.attributes.fingerprints\n      }), !n || !i) throw new Error(\"Cannot get iceParameters or dtlsParameters from SDP.\");\n      return {\n        iceParameters: i,\n        dtlsParameters: n\n      };\n    }\n    function NF(e, t) {\n      const i = [],\n        n = e.attributes.ssrcGroups.filter(e => \"FID\" === e.semantic),\n        r = e.attributes.ssrcGroups.find(e => \"SIM\" === e.semantic),\n        o = e.attributes.ssrcs;\n      if (r) r.ssrcIds.forEach(e => {\n        var r;\n        const o = null === (r = n.find(t => t.ssrcIds[0] === e)) || void 0 === r ? void 0 : r.ssrcIds[1];\n        i.push({\n          ssrcId: e,\n          rtx: t ? o : void 0\n        });\n      });else if (n.length > 0) {\n        const e = n[0].ssrcIds[0],\n          r = n[0].ssrcIds[1];\n        i.push({\n          ssrcId: e,\n          rtx: t ? r : void 0\n        });\n      } else {\n        if (0 === o.length) throw new Error(\"No ssrcs found on local media description.\");\n        i.push({\n          ssrcId: o[0].ssrcId\n        });\n      }\n      return i;\n    }\n    function DF(e, t, i) {\n      const {\n        cname: n\n      } = e;\n      let r = [];\n      t && (r = PF(t)), 0 === r.length && (r = e.iceParameters.candidates.map(e => ({\n        foundation: e.foundation,\n        componentId: \"1\",\n        transport: e.protocol,\n        priority: e.priority.toString(),\n        connectionAddress: e.ip,\n        port: e.port.toString(),\n        type: e.type,\n        extension: {}\n      })), iP.debug(\"Using candidates from gateway.\"));\n      const o = {\n          fingerprints: e.dtlsParameters.fingerprints.map(e => ({\n            hashFunction: e.algorithm,\n            fingerprint: e.fingerprint\n          }))\n        },\n        s = {\n          iceUfrag: e.iceParameters.iceUfrag,\n          icePwd: e.iceParameters.icePwd\n        };\n      let a;\n      switch (e.dtlsParameters.role) {\n        case \"server\":\n          a = \"passive\";\n          break;\n        case \"client\":\n          a = \"active\";\n          break;\n        case \"auto\":\n          a = \"actpass\";\n      }\n      const c = HF(e.rtpCapabilities),\n        d = [];\n      return Array.isArray(i) && i.length > 0 && i.forEach(e => {\n        d.push({\n          kind: fx.VIDEO,\n          ssrcMsg: [{\n            ssrcId: e.v,\n            rtx: e.v_rtx\n          }],\n          mslabel: \"\".concat(e.v, \"_\").concat(e.a)\n        }, {\n          kind: fx.AUDIO,\n          ssrcMsg: [{\n            ssrcId: e.a\n          }],\n          mslabel: \"\".concat(e.v, \"_\").concat(e.a)\n        });\n      }), {\n        dtlsParameters: o,\n        iceParameters: s,\n        candidates: r,\n        rtpCapabilities: c,\n        setup: a,\n        cname: n,\n        preSSRCs: d\n      };\n    }\n    function PF(e) {\n      let t = [];\n      return e.ip && \"number\" == typeof e.port && (t = [{\n        foundation: \"udpcandidate\",\n        componentId: \"1\",\n        transport: \"udp\",\n        priority: \"2103266323\",\n        connectionAddress: e.ip,\n        port: e.port.toString(),\n        type: \"host\",\n        extension: {}\n      }], iP.debug(\"Using remote candidate from AP \".concat(mF(e.ip), \":\").concat(e.port)), e.ip6 && (t.push({\n        foundation: \"udpcandidate\",\n        componentId: \"1\",\n        transport: \"udp\",\n        priority: \"2103266323\",\n        connectionAddress: e.ip6,\n        port: e.port.toString(),\n        type: \"host\",\n        extension: {}\n      }), iP.debug(\"Using IPV6 remote candidate from AP \".concat(mF(e.ip6), \":\").concat(e.port)))), t;\n    }\n    function LF(e, t, i) {\n      const n = [],\n        r = [];\n      return e.forEach(e => {\n        let {\n          ssrcId: o,\n          rtx: s\n        } = e;\n        const a = SN(8, \"track-\"),\n          c = {\n            ssrcId: o,\n            attributes: bF({\n              label: a,\n              mslabel: i = i || SN(10, \"\"),\n              msid: \"\".concat(i, \" \").concat(a)\n            }, t && {\n              cname: t\n            })\n          };\n        if (n.push(c), void 0 !== s) {\n          const e = {\n            ssrcId: s,\n            attributes: bF({\n              label: a,\n              mslabel: i,\n              msid: \"\".concat(i, \" \").concat(a)\n            }, t && {\n              cname: t\n            })\n          };\n          n.push(e), r.push({\n            semantic: \"FID\",\n            ssrcIds: [o, s]\n          });\n        }\n      }), e.length > 1 && r.push({\n        semantic: \"SIM\",\n        ssrcIds: e.map(e => {\n          let {\n            ssrcId: t\n          } = e;\n          return t;\n        })\n      }), {\n        ssrcs: n,\n        ssrcGroups: r\n      };\n    }\n    function kF(e, t) {\n      t instanceof Bk && e.attributes.payloads.forEach(e => {\n        var i;\n        const n = null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase();\n        if (!n || -1 === [\"opus\", \"pcmu\", \"pcma\", \"g722\"].indexOf(n)) return;\n        e.fmtp || (e.fmtp = {\n          parameters: {}\n        }), \"opus\" === n && \"number\" == typeof CD(\"OPUS_PTIME\") ? e.fmtp.parameters.ptime = CD(\"OPUS_PTIME\") : e.fmtp.parameters.minptime = \"10\", e.fmtp.parameters.useinbandfec = \"1\";\n        const r = t._encoderConfig;\n        r && (\"pcmu\" !== n && \"pcma\" !== n && \"g722\" !== n && (r.bitrate && !Bw() && (e.fmtp.parameters.maxaveragebitrate = \"\".concat(Math.floor(1e3 * r.bitrate))), r.sampleRate && (e.fmtp.parameters.maxplaybackrate = \"\".concat(r.sampleRate), e.fmtp.parameters[\"sprop-maxcapturerate\"] = \"\".concat(r.sampleRate)), r.stereo && (e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\")), t instanceof jk && \"opus\" === n && t._config.DTX && (e.fmtp.parameters.usedtx = \"1\"));\n      });\n    }\n    function MF(e) {\n      const t = e.attributes.unrecognized.findIndex(e => \"x-google-flag\" === e.attField && \"conference\" === e.attValue);\n      -1 !== t && e.attributes.unrecognized.splice(t, 1);\n    }\n    function UF(e, t) {\n      var i;\n      if (e.attributes.payloads.forEach(e => {\n        var t;\n        \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) && e.fmtp && e.fmtp.parameters && CD(\"ENABLE_UP_SPS_PPS\") && (e.fmtp.parameters[\"sps-pps-idr-in-keyframe\"] = \"1\");\n      }), !(t instanceof kM && t._encoderConfig && -1 === t._hints.indexOf(VP.SCREEN_TRACK))) return;\n      const n = t._encoderConfig;\n      pP().supportMinBitrate && n.bitrateMin && e.attributes.payloads.forEach(e => {\n        var t, i;\n        Ln(t = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\"]).call(t, (null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n          parameters: {}\n        }), e.fmtp.parameters[\"x-google-min-bitrate\"] = \"\".concat(n.bitrateMin));\n      }), pP().supportMinBitrate && !Ln(i = t._hints).call(i, VP.LOW_STREAM) && n.bitrateMax && e.attributes.payloads.forEach(e => {\n        var t, i;\n        Ln(t = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\"]).call(t, (null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n          parameters: {}\n        }), e.fmtp.parameters[\"x-google-start-bitrate\"] = \"\".concat(CD(\"X_GOOGLE_START_BITRATE\") || Math.floor(n.bitrateMax)));\n      });\n    }\n    function VF(e) {\n      if (\"video\" !== e.media.mediaType) return;\n      const t = Dw();\n      if (t.name !== bw.SAFARI && t.os !== Aw.IOS) return;\n      const i = e.attributes.extmaps.findIndex(e => /video-orientation/g.test(e.extensionName));\n      -1 !== i && e.attributes.extmaps.splice(i, 1);\n    }\n    function xF(e, t, i) {\n      if (!t) return;\n      let n, r;\n      if (\"video\" === e.media.mediaType ? (n = i.videoExtensions, r = i.videoCodecs) : (n = i.audioExtensions, r = i.audioCodecs), !0 === t.twcc) {\n        const t = n.find(e => IF(e.extensionName));\n        if (t) {\n          const i = t.extensionName;\n          e.attributes.extmaps.find(e => IF(e.extensionName)) || e.attributes.extmaps.push({\n            entry: t.entry,\n            extensionName: i\n          });\n          const n = function (e, t) {\n            return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type)));\n          }(r, e.attributes.payloads);\n          n.forEach(e => {\n            e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type) || e.rtcpFeedbacks.push({\n              type: \"transport-cc\"\n            });\n          });\n        }\n      } else if (!1 === t.twcc) {\n        const t = e.attributes.extmaps.findIndex(e => IF(e.extensionName));\n        -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n          const t = e.rtcpFeedbacks.findIndex(e => \"transport-cc\" === e.type);\n          -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n        });\n      }\n      if (!0 === t.remb) {\n        const t = n.find(e => yF(e.extensionName));\n        if (t) {\n          const i = t.extensionName;\n          e.attributes.extmaps.find(e => e.extensionName === i) || e.attributes.extmaps.push({\n            entry: t.entry,\n            extensionName: i\n          });\n          const n = function (e, t) {\n            return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type)));\n          }(r, e.attributes.payloads);\n          n.forEach(e => {\n            e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type) || e.rtcpFeedbacks.push({\n              type: \"goog-remb\"\n            });\n          });\n        }\n      } else if (!1 === t.remb) {\n        const t = e.attributes.extmaps.findIndex(e => yF(e.extensionName));\n        -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n          const t = e.rtcpFeedbacks.findIndex(e => \"goog-remb\" === e.type);\n          -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n        });\n      }\n    }\n    function FF(e, t, i) {\n      if (Bw()) return;\n      if (\"video\" !== e.media.mediaType) return;\n      if (!(t instanceof kM)) return;\n      if (\"vp9\" !== i && \"vp8\" !== i) return;\n      if (\"vp8\" === i && !CD(\"SIMULCAST\")) return;\n      if (\"vp9\" === i && CD(\"ENABLE_SVC\")) return;\n      if (void 0 === t._scalabilityMode || t._scalabilityMode.numSpatialLayers <= 1) return;\n      const n = \"vp8\" === i ? 2 : t._scalabilityMode.numSpatialLayers,\n        r = e.attributes.ssrcs[0],\n        o = e.attributes.ssrcGroups.find(e => \"FID\" === e.semantic && e.ssrcIds[0] === r.ssrcId),\n        s = {\n          semantic: \"SIM\",\n          ssrcIds: [r.ssrcId]\n        };\n      for (let t = 1; t < n; t++) e.attributes.ssrcs.push({\n        ssrcId: r.ssrcId + t,\n        attributes: sN(r.attributes)\n      }), s.ssrcIds.push(r.ssrcId + t), o && (e.attributes.ssrcs.push({\n        ssrcId: o.ssrcIds[1] + t,\n        attributes: sN(r.attributes)\n      }), e.attributes.ssrcGroups.push({\n        semantic: \"FID\",\n        ssrcIds: [r.ssrcId + t, o.ssrcIds[1] + t]\n      }));\n      e.attributes.ssrcGroups.unshift(s);\n    }\n    async function BF() {\n      try {\n        const e = new RTCPeerConnection();\n        e.addTransceiver(\"video\", {\n          direction: \"sendonly\",\n          sendEncodings: [{\n            scalabilityMode: iD.L1T3\n          }]\n        });\n        const t = await e.createOffer();\n        if (!t.sdp) return void e.close();\n        const i = LD(t.sdp).mediaDescriptions[0];\n        if (!i) return;\n        const n = i.attributes.extmaps.find(e => \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\" === e.extensionName);\n        return e.close(), n;\n      } catch (e) {\n        return;\n      }\n    }\n    async function jF() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      const i = new RTCPeerConnection();\n      i.addTransceiver(\"video\", {\n        direction: \"sendonly\"\n      }), i.addTransceiver(\"audio\", {\n        direction: \"sendonly\"\n      }), i.addTransceiver(\"video\", {\n        direction: \"recvonly\"\n      }), i.addTransceiver(\"audio\", {\n        direction: \"recvonly\"\n      });\n      const n = (await i.createOffer()).sdp,\n        {\n          send: r,\n          recv: o,\n          sendrecv: s\n        } = function () {\n          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            i = arguments.length > 2 ? arguments[2] : void 0;\n          const n = wF(i, e, t, \"sendonly\"),\n            r = wF(i, e, t, \"recvonly\"),\n            o = {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            s = {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            a = {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            };\n          if (WF(n, r, \"videoExtensions\", o, s, a), WF(n, r, \"videoCodecs\", o, s, a), WF(n, r, \"audioExtensions\", o, s, a), WF(n, r, \"audioCodecs\", o, s, a), CD(\"RAISE_H264_BASELINE_PRIORITY\")) {\n            const e = [],\n              t = [];\n            if (a.videoCodecs.forEach((i, n) => {\n              var r;\n              if (\"h264\" === (null === (r = i.rtpMap) || void 0 === r ? void 0 : r.encodingName.toLocaleLowerCase())) {\n                var o, s;\n                const r = a.videoCodecs[n + 1],\n                  c = r && $F(i, r),\n                  d = null === (o = i.fmtp) || void 0 === o ? void 0 : o.parameters[\"profile-level-id\"],\n                  l = null === (s = i.fmtp) || void 0 === s ? void 0 : s.parameters[\"packetization-mode\"];\n                !d || d !== CD(\"FIRST_H264_PROFILE_LEVEL_ID\") || CD(\"FIRST_PACKETIZATION_MODE\") && l !== CD(\"FIRST_PACKETIZATION_MODE\") ? c ? t.push([i, r]) : t.push([i]) : c ? e.push([i, r]) : e.push([i]);\n              }\n            }), e.length > 0 && t.length > 0) {\n              iP.debug(\"raising H264 baseline profile priority\"), a.videoCodecs.forEach((i, n) => {\n                var r;\n                if (\"h264\" === (null === (r = i.rtpMap) || void 0 === r ? void 0 : r.encodingName.toLocaleLowerCase())) {\n                  const r = $F(i, a.videoCodecs[n + 1]),\n                    o = e.shift() || t.shift() || [];\n                  o.length > 0 && (r ? a.videoCodecs.splice(n, 2, ...o) : a.videoCodecs.splice(n, 1, ...o));\n                }\n              });\n              const i = s.videoCodecs.filter(e => {\n                var t, i;\n                return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]) !== CD(\"FIRST_H264_PROFILE_LEVEL_ID\");\n              });\n              if (i.length > 0) {\n                const e = zF(i, s.videoCodecs).map(e => e.payloadType),\n                  t = [...i.map(e => e.payloadType), ...e];\n                s.videoCodecs = s.videoCodecs.filter(e => !Ln(t).call(t, e.payloadType));\n              }\n              CD(\"FILTER_SEND_H264_BASELINE\") && (o.videoCodecs = o.videoCodecs.filter(e => {\n                var t, i;\n                return !(\"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]) !== CD(\"FIRST_H264_PROFILE_LEVEL_ID\"));\n              }));\n            }\n            return {\n              send: o,\n              recv: s,\n              sendrecv: a\n            };\n          }\n          return {\n            send: o,\n            recv: s,\n            sendrecv: a\n          };\n        }(e, t, n);\n      try {\n        i.close();\n      } catch (e) {}\n      return {\n        send: r,\n        recv: o,\n        sendrecv: s\n      };\n    }\n    function GF() {\n      const e = {\n          audioCodecs: [],\n          videoCodecs: [],\n          audioExtensions: [],\n          videoExtensions: []\n        },\n        t = wF(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, \"recvonly\"),\n        i = {\n          audioCodecs: [],\n          audioExtensions: [],\n          videoCodecs: [],\n          videoExtensions: []\n        },\n        n = {\n          audioCodecs: [],\n          audioExtensions: [],\n          videoCodecs: [],\n          videoExtensions: []\n        },\n        r = {\n          audioCodecs: [],\n          audioExtensions: [],\n          videoCodecs: [],\n          videoExtensions: []\n        };\n      if (WF(e, t, \"videoExtensions\", i, n, r), WF(e, t, \"videoCodecs\", i, n, r), WF(e, t, \"audioExtensions\", i, n, r), WF(e, t, \"audioCodecs\", i, n, r), CD(\"RAISE_H264_BASELINE_PRIORITY\")) {\n        const e = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" === e.fmtp.parameters[\"profile-level-id\"]);\n        if (-1 !== e) {\n          const t = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase());\n          if (t < e) {\n            iP.debug(\"raising H264 baseline profile priority\");\n            const i = r.videoCodecs[e];\n            r.videoCodecs.splice(e, 1), r.videoCodecs.splice(t, 0, i);\n          }\n          -1 !== t && (n.videoCodecs = n.videoCodecs.filter(e => !(e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" !== e.fmtp.parameters[\"profile-level-id\"])));\n        }\n      }\n      return {\n        send: i,\n        recv: n,\n        sendrecv: r\n      };\n    }\n    function WF(e, t, i, n, r, o) {\n      if (\"videoExtensions\" === i || \"audioExtensions\" === i) {\n        const s = [];\n        return e[i].forEach(e => {\n          t[i].some((t, i) => {\n            if (e.entry === t.entry && e.extensionName === t.extensionName) return s.push(i), !0;\n          }) ? o[i].push(e) : n[i].push(e);\n        }), void t[i].forEach((e, t) => {\n          -1 === s.indexOf(t) && r[i].push(e);\n        });\n      }\n      if (\"videoCodecs\" === i || \"audioCodecs\" === i) {\n        const s = [];\n        return e[i].forEach(e => {\n          t[i].some((t, i) => {\n            if (e.payloadType === t.payloadType && JSON.stringify(e) === JSON.stringify(t)) return s.push(i), !0;\n          }) ? o[i].push(e) : n[i].push(e);\n        }), void t[i].forEach((e, t) => {\n          -1 === s.indexOf(t) && r[i].push(e);\n        });\n      }\n    }\n    function HF(e) {\n      const {\n        send: t,\n        recv: i,\n        sendrecv: n\n      } = e;\n      if (!n) {\n        if (!t || !i) throw new Error(\"cannot merge rtp capabilities because one of send or recv is empty!\");\n        return {\n          send: t,\n          recv: i\n        };\n      }\n      let r, o;\n      return t ? (r = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      }, r.audioCodecs = [...t.audioCodecs, ...n.audioCodecs], r.videoCodecs = [...t.videoCodecs, ...n.videoCodecs], r.audioExtensions = [...t.audioExtensions, ...n.audioExtensions], r.videoExtensions = [...t.videoExtensions, ...n.videoExtensions]) : r = sN(n), i ? (o = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      }, o.audioCodecs = [...i.audioCodecs, ...n.audioCodecs], o.videoCodecs = [...i.videoCodecs, ...n.videoCodecs], o.audioExtensions = [...i.audioExtensions, ...n.audioExtensions], o.videoExtensions = [...i.videoExtensions, ...n.videoExtensions]) : o = sN(n), {\n        send: r,\n        recv: o\n      };\n    }\n    function KF(e) {\n      if (\"audio\" !== e.media.mediaType) return;\n      e.attributes.payloads.filter(e => {\n        var t;\n        return \"opus\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n      }).forEach(e => {\n        e.fmtp || (e.fmtp = {\n          parameters: {}\n        }), e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\";\n      });\n    }\n    function YF(e, t, i, n) {\n      let r = [];\n      if (e === fx.VIDEO) {\n        if (CD(\"H264_PROFILE_LEVEL_ID\") && \"h264\" === n && (r = t.videoCodecs.filter(e => {\n          var t;\n          return Ln(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, n) && e && e.fmtp && e.fmtp.parameters[\"profile-level-id\"] === CD(\"H264_PROFILE_LEVEL_ID\");\n        })), !Array.isArray(r) || 0 === r.length) {\n          let e = [];\n          const o = [],\n            s = [],\n            a = [];\n          if (i.videoCodecs.forEach(t => {\n            const i = t.rtpMap && t.rtpMap.encodingName.toLowerCase() || \"\";\n            Ln(i).call(i, n) ? e.push(t) : Ln(i).call(i, \"vp9\") ? o.push(t) : Ln(i).call(i, \"vp8\") ? s.push(t) : Ln(i).call(i, \"h264\") && a.push(t);\n          }), 0 === e.length) {\n            let t = \"\";\n            0 !== o.length ? (e = o, t = \"vp9\") : 0 !== s.length ? (e = s, t = \"vp8\") : 0 !== a.length && (e = a, t = \"h264\"), iP.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to default payloads: \").concat(t));\n          }\n          0 !== e.length && (r = t.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)));\n        }\n        if (0 === r.length && (iP.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to default payloads: \").concat(t.videoCodecs[0].rtpMap && t.videoCodecs[0].rtpMap.encodingName)), r = t.videoCodecs), CD(\"USE_PUB_RTX\") || CD(\"USE_SUB_RTX\")) {\n          const e = zF(r, t.videoCodecs);\n          r = [...r, ...e];\n        }\n      } else {\n        r = t.audioCodecs.filter(e => {\n          var t;\n          return Ln(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, n);\n        });\n        const e = t.audioCodecs.filter(e => {\n          var t;\n          return Ln(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, \"red\");\n        });\n        0 === r.length && (iP.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to opus\")), r = t.audioCodecs.filter(e => {\n          var t;\n          return Ln(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, \"opus\");\n        })), CD(\"ENABLE_AUDIO_RED\") && 0 !== e.length && (r = [...e, ...r]);\n      }\n      return r;\n    }\n    function zF(e, t) {\n      const i = e.map(e => e.payloadType.toString());\n      return t.filter(e => e.rtpMap && \"rtx\" === e.rtpMap.encodingName && e.fmtp && e.fmtp.parameters.apt && Ln(i).call(i, e.fmtp && e.fmtp.parameters.apt));\n    }\n    async function qF(e, t, i) {\n      const n = t.toString(),\n        r = JF(n, \"offer\", \"remote\", \"exchangeSDP\");\n      await e.setRemoteDescription({\n        type: \"offer\",\n        sdp: n\n      });\n      const o = await e.createAnswer();\n      if (!o.sdp) throw new Error(\"cannot get answer sdp\");\n      let s = o.sdp;\n      s = XF(s, i || {}), null == r || r(s || \"\"), await e.setLocalDescription({\n        type: \"answer\",\n        sdp: s\n      });\n    }\n    function XF(e, t, i) {\n      if (CD(\"FORBID_MODIFY_LOCAL_OFFER_SDP\")) return e;\n      const n = LD(e),\n        {\n          useXR: r\n        } = t;\n      return n.mediaDescriptions.forEach(e => {\n        var t;\n        e.attributes.mid && (Array.isArray(i) && !Ln(i).call(i, e.attributes.mid) || (\"audio\" === e.media.mediaType && KF(e), \"video\" === e.media.mediaType && function (e) {\n          if (\"video\" !== e.media.mediaType) return;\n          if (!CD(\"ENABLE_DOWN_SPS_PPS\")) return;\n          e.attributes.payloads.filter(e => {\n            var t;\n            return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n          }).forEach(e => {\n            e.fmtp || (e.fmtp = {\n              parameters: {}\n            }), e.fmtp.parameters[\"sps-pps-idr-in-keyframe\"] = \"1\";\n          });\n        }(e), r && Ln(t = [\"audio\", \"video\"]).call(t, e.media.mediaType) && e.attributes.payloads.forEach(e => {\n          -1 === e.rtcpFeedbacks.findIndex(e => \"rrtr\" === e.type) && e.rtcpFeedbacks.push({\n            type: \"rrtr\"\n          });\n        })));\n      }), kD(n);\n    }\n    function JF(e, t, i, n) {\n      if (CD(\"SDP_LOGGING\")) return iP.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during P2PConnection.\").concat(n, \"\\n\"), e), \"offer\" === t ? e => {\n        JF(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", n);\n      } : void 0;\n    }\n    async function QF(e, t, i) {\n      try {\n        var n;\n        if (!pP().supportSetRtpSenderParameters) return;\n        if (!function (e) {\n          return \"vp9\" === e || \"av1\" === e;\n        }(e) || !CD(\"ENABLE_SVC\")) return;\n        const r = {},\n          o = {},\n          s = t.getParameters(),\n          a = null === (n = s.encodings) || void 0 === n ? void 0 : n[0];\n        o.scalabilityMode = SF(i), a && Object.assign(a, o), Object.assign(s, r), await t.setParameters(s), iP.debug(\"[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: \".concat(JSON.stringify(s.encodings)));\n      } catch (e) {\n        iP.debug(\"[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed\", e);\n      }\n    }\n    function ZF(e) {\n      const t = CD(\"COMPATIBLE_SDP_EXTENSION\");\n      return !!(Array.isArray(t) && t.length > 0) && t.some(t => Ln(e).call(e, t));\n    }\n    function $F(e, t) {\n      try {\n        var i;\n        return (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters.apt) === t.payloadType.toString();\n      } catch (e) {\n        return !1;\n      }\n    }\n    function eB(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function tB(e, t) {\n      return typeof CD(e) === t ? CD(e) : void 0;\n    }\n    function iB() {\n      try {\n        const e = CD(\"EXPERIMENTS\") || {};\n        return \"string\" == typeof e || Array.isArray(e) ? {} : function (e) {\n          for (var t = 1; t < arguments.length; t++) {\n            var i = null != arguments[t] ? arguments[t] : {};\n            t % 2 ? eB(Object(i), !0).forEach(function (t) {\n              iA(e, t, i[t]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : eB(Object(i)).forEach(function (t) {\n              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n            });\n          }\n          return e;\n        }({}, e);\n      } catch (e) {\n        return iP.debug(\"handle gateway attributes failed: \", e), {};\n      }\n    }\n    const nB = {};\n    function rB(e) {\n      (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && iP.debug(\"install service \".concat(e.name)), nB[e.name] = e;\n    }\n    function oB(e) {\n      const t = nB[e];\n      if (!t) throw new pO(hO.INVALID_OPERATION, \"\".concat(e, \" not found, please use AgoraRTC.use(\").concat(e, \"Service) to load it first\"));\n      return t;\n    }\n    function sB(e, t) {\n      return oB(\"DataStream\").create(e, t);\n    }\n    function aB() {\n      return oB(\"InterceptFrame\").create();\n    }\n    function cB(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function dB(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? cB(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : cB(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    const lB = new Map();\n    class uB extends NO {\n      get state() {\n        return this._state;\n      }\n      set state(e) {\n        if (e === this._state) return;\n        const t = this._state;\n        this._state = e, \"DISCONNECTED\" === e && this._disconnectedReason ? this.emit(sx.CONNECTION_STATE_CHANGE, e, t, this._disconnectedReason) : this.emit(sx.CONNECTION_STATE_CHANGE, e, t);\n      }\n      get joinGatewayStartTime() {\n        return this._joinGatewayStartTime;\n      }\n      set joinGatewayStartTime(e) {\n        iP.debug(\"[\".concat(this.store.clientId, \"] set joinGatewayStartTime at \").concat(e)), this._joinGatewayStartTime = e;\n      }\n      constructor(e, t) {\n        var i, n, r;\n        super(), iA(this, \"store\", void 0), iA(this, \"joinInfo\", void 0), iA(this, \"key\", void 0), iA(this, \"ntpOffset\", 0), iA(this, \"usingProxy\", !1), iA(this, \"signal\", void 0), iA(this, \"role\", void 0), iA(this, \"isPreallocation\", void 0), iA(this, \"isPreSub\", void 0), iA(this, \"inChannelInfo\", {\n          joinAt: null,\n          duration: 0\n        }), iA(this, \"spec\", void 0), iA(this, \"_state\", \"DISCONNECTED\"), iA(this, \"_statsCollector\", void 0), iA(this, \"_disconnectedReason\", void 0), iA(this, \"isSignalRecover\", !1), iA(this, \"hasChangeBGPAddress\", !1), iA(this, \"trafficStatsInterval\", void 0), iA(this, \"networkQualityInterval\", void 0), iA(this, \"_joinGatewayStartTime\", 0), iA(this, \"_signalTimeout\", !1), iA(this, \"_clientRoleOptions\", void 0), iA(this, \"_isProactiveJoin\", !1), this.store = e, this.spec = t, this.signal = this.store.useP2P ? (i = {\n          spec: dB(dB({}, t), {}, {\n            retryConfig: t.websocketRetryConfig\n          }),\n          store: e\n        }, null === (n = (r = oB(\"P2PChannel\")).createSubmodule) || void 0 === n ? void 0 : n.call(r, i)) : this.store.useDcSignal ? function (e) {\n          return oB(\"DataChannelSignal\").create(e);\n        }({\n          spec: dB(dB({}, t), {}, {\n            retryConfig: t.websocketRetryConfig\n          }),\n          store: e\n        }) : new eF(dB(dB({}, t), {}, {\n          retryConfig: t.websocketRetryConfig\n        }), e), this._statsCollector = t.statsCollector, this.role = t.role || \"audience\", this._clientRoleOptions = t.clientRoleOptions, this.handleSignalEvents();\n      }\n      setUsingProxy(e) {\n        this.usingProxy = e;\n      }\n      async join(e, t, i) {\n        if (this.store.useDcSignal) {\n          let t = !1;\n          \"disabled\" !== e.cloudProxyServer ? (iP.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because cloudProxyServer are not supported (\").concat(e.cloudProxyServer, \")\")), t = !0) : \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length > 255 || \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length < 22 ? (iP.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255\")), t = !0) : e.apResponse.addresses.some(e => e.fingerprint) || CD(\"FINGERPRINT\") || (iP.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because fingerprint does not exist\")), t = !0), t && this.resetSignal();\n        }\n        this.store.joinGatewayStart(), \"disabled\" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0);\n        const n = Date.now();\n        let r = lB.get(e.cname);\n        if (r || (r = new Map(), lB.set(e.cname, r)), this._isProactiveJoin = !0, r.has(e.uid)) {\n          const t = new uP(hO.UID_CONFLICT);\n          throw lP.joinGateway(e.sid, {\n            lts: n,\n            succ: !1,\n            ec: t.code,\n            addr: null,\n            uid: e.uid,\n            cid: e.cid,\n            firstSuccess: this._isProactiveJoin,\n            isProxy: !!e.proxyServer || this.usingProxy,\n            signalChannel: this.store.useDcSignal ? \"1\" : \"0\",\n            preload: e.preload\n          }), t;\n        }\n        r.set(e.uid, !0), this.joinInfo = e, this.key = t;\n        let o = 0;\n        this.joinGatewayStartTime = n;\n        const s = e.proxyServer,\n          a = this.store.useDcSignal ? \"datachannel\" : \"websocket\";\n        try {\n          iP.debug(\"[\".concat(this.store.clientId, \"] use \").concat(a, \" join uid \").concat(o));\n          const t = e.gatewayAddrs.map(t => {\n            let {\n              address: i\n            } = t;\n            const [n, r] = i.split(\":\"),\n              o = {\n                host: n,\n                port: r\n              };\n            return e.proxyServer && (o.proxy = e.proxyServer), o;\n          });\n          let i;\n          i = this.store.useDcSignal ? await this.signal.init(e.apResponse.addresses) : await this.signal.init(t), o = i.uid, iP.debug(\"[\".concat(this.store.clientId, \"] \").concat(a, \" join uid \").concat(o, \" cost \").concat(Date.now() - this.joinGatewayStartTime));\n        } catch (t) {\n          var c;\n          if (t.code === hO.INIT_DATACHANNEL_TIMEOUT && \"AgoraRTCSignal\" === this.signal.__name__) ;else lP.joinGateway(e.sid, {\n            lts: n,\n            succ: !1,\n            ec: (null === (c = t.data) || void 0 === c ? void 0 : c.desc) || t.code,\n            errorMsg: t.message,\n            addr: this.signal.url,\n            uid: e.uid,\n            cid: e.cid,\n            firstSuccess: this._isProactiveJoin,\n            isProxy: !!s || this.usingProxy,\n            signalChannel: \"DataChannelSignal\" === this.signal.__name__ ? \"1\" : \"0\",\n            preload: e.preload\n          });\n          if (t && t.code === hO.INIT_DATACHANNEL_TIMEOUT) throw iP.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\"), t.toString()), this.resetSignal(), t;\n          throw iP.error(\"[\".concat(this.store.clientId, \"] User join failed\"), t.toString()), r.delete(e.uid), this.signal.close(), t;\n        }\n        return this.state = \"CONNECTED\", this.inChannelInfo.joinAt = Date.now(), iP.debug(\"[\".concat(this.store.clientId, \"] Connected to gateway server\")), this.trafficStatsInterval = window.setInterval(() => {\n          this.updateTrafficStats().catch(e => {\n            iP.warning(\"[\".concat(this.store.clientId, \"] get traffic stats error\"), e.toString());\n          });\n        }, 3e3), this.networkQualityInterval = window.setInterval(() => {\n          navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(sx.NETWORK_QUALITY, {\n            downlinkNetworkQuality: 6,\n            uplinkNetworkQuality: 6\n          }) : this._signalTimeout ? this.emit(sx.NETWORK_QUALITY, {\n            downlinkNetworkQuality: 5,\n            uplinkNetworkQuality: 5\n          }) : \"CONNECTED\" === this.state && this._statsCollector.trafficStats ? this.emit(sx.NETWORK_QUALITY, {\n            uplinkNetworkQuality: uF(this._statsCollector.trafficStats.B_unq),\n            downlinkNetworkQuality: uF(this._statsCollector.trafficStats.B_dnq)\n          }) : this.emit(sx.NETWORK_QUALITY, {\n            uplinkNetworkQuality: 0,\n            downlinkNetworkQuality: 0\n          });\n        }, 2e3), this.store.joinGatewayEnd(), o;\n      }\n      async leave() {\n        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n          t = arguments.length > 1 ? arguments[1] : void 0;\n        if (\"DISCONNECTED\" !== this.state) {\n          t !== VO.FALLBACK && (this.state = \"DISCONNECTING\");\n          try {\n            e || this.signal.connectionState !== VV.CONNECTED || (await function (e, t) {\n              return t === 1 / 0 ? e : rp.race([e, mN(t)]);\n            }(this.signal.request(FV.LEAVE, void 0, !0), 3e3));\n          } catch (e) {\n            iP.warning(\"[\".concat(this.store.clientId, \"] leave request failed, ignore\"), e);\n          }\n          this.signal.close(t), t !== VO.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n        }\n      }\n      async publish(e, t, i) {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        const n = {\n          state: \"offer\",\n          p2p_id: this.store.p2pId,\n          ortc: t,\n          mode: this.spec.mode,\n          extend: CD(\"PUB_EXTEND\"),\n          twcc: !!CD(\"PUBLISH_TWCC\"),\n          rtx: !!CD(\"USE_PUB_RTX\")\n        };\n        try {\n          return (await this.signal.request(FV.PUBLISH, n, !0))._message;\n        } catch (n) {\n          if (i && n.data && n.data.code === UV.ERR_PUBLISH_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] receive publish error code, retry\"), n.toString()), await this.tryUnpubBeforeRepub(e, t), this.publish(e, t, !1);\n          throw n;\n        }\n      }\n      async publishDataChannel(e, t, i) {\n        var n;\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        const r = {\n          stream_id: t.streamId,\n          ordered: t.ordered ? 1 : 0,\n          max_retrans_times: null !== (n = t.maxRetransmits) && void 0 !== n ? n : 10,\n          channel_id: t.channelId,\n          metadata: t.metadata\n        };\n        try {\n          await this.signal.request(FV.PUBLISH_DATASTREAM, r, !0);\n        } catch (n) {\n          if (i && n.data && n.data.code === UV.ERR_PUBLISH_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] receive publish datachannels error code, retry\"), n.toString()), await this.tryUnpubDataChannelBeforeRepub(e, t), this.publishDataChannel(e, t, !1);\n          throw n;\n        }\n      }\n      async unpublish(e, t) {\n        try {\n          if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n          await this.signal.request(FV.UNPUBLISH, {\n            stream_id: t,\n            ortc: e\n          }, !0);\n        } catch (e) {\n          iP.warning(\"[\".concat(this.store.clientId, \"] unpublish warning: \"), e);\n        }\n      }\n      async unpublishDataChannel(e) {\n        try {\n          if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n          await rp.all(e.map(e => this.signal.request(FV.UNPUBLISH_DATASTREAM, {\n            channel_id: e\n          }, !0)));\n        } catch (e) {\n          iP.warning(\"unpublish datachannels warning: \", e);\n        }\n      }\n      async presubscribe(e, t, i) {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not presubscribe when connection state is \".concat(this.state));\n        const n = {\n          stream_id: e,\n          stream_type: t,\n          mode: this.spec.mode,\n          codec: this.spec.codec,\n          p2p_id: this.store.p2pId,\n          twcc: !!CD(\"SUBSCRIBE_TWCC\"),\n          rtx: !!CD(\"USE_SUB_RTX\") || void 0,\n          extend: CD(\"SUB_EXTEND\"),\n          svc: Array.isArray(CD(\"SVC\")) && 0 !== CD(\"SVC\").length ? CD(\"SVC\") : void 0\n        };\n        try {\n          return await this.signal.request(FV.PRE_SUBSCRIBE, n, !0);\n        } catch (n) {\n          if (i && n.data && n.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] pre-subscribe error, retry\"), n.toString()), this.presubscribe(e, t, !1);\n          throw n;\n        }\n      }\n      async subscribe(e, t, i) {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not subscribe when connection state is \".concat(this.state));\n        const n = {\n          stream_id: e,\n          stream_type: t.stream_type,\n          mode: this.spec.mode,\n          codec: this.spec.codec,\n          p2p_id: this.store.p2pId,\n          twcc: !!CD(\"SUBSCRIBE_TWCC\"),\n          rtx: !!CD(\"USE_SUB_RTX\"),\n          extend: CD(\"SUB_EXTEND\"),\n          ssrcId: t.ssrcId,\n          svc: Array.isArray(CD(\"SVC\")) && 0 !== CD(\"SVC\").length ? CD(\"SVC\") : void 0\n        };\n        try {\n          return (await this.signal.request(FV.SUBSCRIBE, n, !0))._message;\n        } catch (n) {\n          if (i && n.data && n.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] receiver subscribe error code, retry\"), n.toString()), await this.tryUnsubBeforeResub(e, t), await this.subscribe(e, t, !1);\n          throw n;\n        }\n      }\n      async subscribeDataChannel(e, t, i) {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not subscribe datachannel when connection state is \".concat(this.state));\n        const n = {\n          uid: e,\n          stream_id: t.id,\n          channel_id: t.datachannelId\n        };\n        try {\n          return void (await this.signal.request(FV.SUBSCRIBE_DATASTREAM, n, !0));\n        } catch (n) {\n          if (i && n.data && n.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] receiver subscribe datachannel error code, retry\"), n.toString()), await this.tryUnsubDataChannelBeforeResub(e, t), await this.subscribeDataChannel(e, t, !1);\n          throw n;\n        }\n      }\n      async subscribeAll(e, t) {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not massSubscribe when connection state is \".concat(this.state));\n        const i = {\n          p2p_id: this.store.p2pId,\n          users: e,\n          dtx: !1,\n          rtx: !!CD(\"USE_SUB_RTX\"),\n          twcc: !!CD(\"SUBSCRIBE_TWCC\"),\n          svc: Array.isArray(CD(\"SVC\")) && 0 !== CD(\"SVC\").length ? CD(\"SVC\") : void 0\n        };\n        try {\n          return await this.signal.request(FV.SUBSCRIBE_STREAMS, i, !0);\n        } catch (i) {\n          if (t && i.data && i.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning(\"[\".concat(this.store.clientId, \"] receiver massSubscribe error code, retry\"), i.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, !1);\n          throw i;\n        }\n      }\n      async setVideoProfile(e) {\n        const t = function (e) {\n          if (!(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)) return;\n          let t = e.frameRate,\n            i = e.width,\n            n = e.height,\n            r = !0;\n          return \"number\" != typeof t && (t = t.exact || t.ideal || t.max || t.min || 0, t || (r = !1)), \"number\" != typeof i && (i = i.exact || i.ideal || i.max || i.min || 0, i || (r = !1)), \"number\" != typeof n && (n = n.exact || n.ideal || n.max || n.min || 0, t || (r = !1)), r ? {\n            stream_type: 0,\n            width: i,\n            height: n,\n            fps: t,\n            start_bps: 1e3 * e.bitrateMax,\n            min_bps: 1e3 * e.bitrateMin,\n            target_bps: 1e3 * e.bitrateMax\n          } : void 0;\n        }(e);\n        if (t) return this.signal.request(FV.SET_VIDEO_PROFILE, t);\n        iP.debug(\"[\".concat(this.store.clientId, \"] encoder config is not complete, do not report to gateway\"));\n      }\n      async unsubscribe(e, t) {\n        try {\n          await this.signal.request(FV.UNSUBSCRIBE, {\n            p2p_id: this.store.p2pId,\n            ortc: e,\n            stream_id: t\n          }, !0);\n        } catch (e) {\n          iP.warning(\"[\".concat(this.store.clientId, \"] unsubscribe warning: \"), e);\n        }\n      }\n      async unsubscribeDataChannel(e, t) {\n        try {\n          if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new uP(hO.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n          await rp.all(e.map(e => this.signal.request(FV.UNSUBSCRIBE_DATASTREAM, {\n            stream_id: e,\n            uid: t\n          }, !0)));\n        } catch (e) {\n          iP.warning(\"unsubscribeDataChannel warning: \", e);\n        }\n      }\n      async massUnsubscribe(e) {\n        try {\n          await this.signal.request(FV.UNSUBSCRIBE_STREAMS, e, !0);\n        } catch (e) {\n          iP.warning(\"[\".concat(this.store.clientId, \"] massUnsubscribeAll warning: \"), e);\n        }\n      }\n      async reconnectPC(e) {\n        const {\n          iceParameters: t,\n          dtlsParameters: i,\n          rtpCapabilities: n\n        } = e;\n        return {\n          gatewayEstablishParams: await this.signal.request(FV.CONNECT_PC, {\n            p2p_id: this.store.p2pId,\n            stream_id: this.store.uid,\n            ortc: {\n              iceParameters: t,\n              dtlsParameters: i,\n              rtpCapabilities: n\n            }\n          }, !0),\n          gatewayAddress: this.getCurrentGatewayAddress()\n        };\n      }\n      getGatewayInfo() {\n        return this.signal.request(FV.GATEWAY_INFO);\n      }\n      async renewToken(e) {\n        await this.signal.request(FV.RENEW_TOKEN, e), this.key = e.token;\n      }\n      updateClientRole(e, t) {\n        t && (this._clientRoleOptions = Object.assign({}, t)), CD(\"CLIENT_ROLE_OPTIONS\") && (iP.debug(\"[\".concat(this.store.clientId, \"] Set roleOptions for \").concat(JSON.stringify(CD(\"CLIENT_ROLE_OPTIONS\")), \" instead of \").concat(JSON.stringify(this._clientRoleOptions), \" \")), this._clientRoleOptions = Object.assign({}, CD(\"CLIENT_ROLE_OPTIONS\"))), this.role = e;\n      }\n      async setClientRole(e, t) {\n        if (t && (this._clientRoleOptions = Object.assign({}, t)), CD(\"CLIENT_ROLE_OPTIONS\") && (this._clientRoleOptions = Object.assign({}, CD(\"CLIENT_ROLE_OPTIONS\")), iP.debug(\"[\".concat(this.store.clientId, \"] Set roleOptions for \").concat(JSON.stringify(CD(\"CLIENT_ROLE_OPTIONS\")), \" instead of \").concat(JSON.stringify(this._clientRoleOptions), \" \"))), \"CONNECTED\" !== this.state) return void (this.role = e);\n        let i,\n          n = 0;\n        \"audience\" === e ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i = this._clientRoleOptions.delay, n = 1) : n = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n = 0;\n        const r = Object.assign({}, t);\n        delete r.delay, delete r.level, await this.signal.request(FV.SET_CLIENT_ROLE, dB(dB({\n          role: e,\n          level: n,\n          delay: i\n        }, r), {}, {\n          client_ts: Date.now()\n        })), this.role = e;\n      }\n      async setDualStreamMode(e, t, i) {\n        await this.signal.request(FV.SET_DUAL_STREAM_MODE, {\n          mode: e\n        }, i, t);\n      }\n      async setRemoteVideoStreamType(e, t) {\n        await this.signal.request(FV.SWITCH_VIDEO_STREAM, {\n          stream_id: e,\n          stream_type: t\n        });\n      }\n      async setDefaultRemoteVideoStreamType(e) {\n        await this.signal.request(FV.DEFAULT_VIDEO_STREAM, {\n          stream_type: e\n        });\n      }\n      async setStreamFallbackOption(e, t) {\n        await this.signal.request(FV.SET_FALLBACK_OPTION, {\n          stream_id: e,\n          fallback_type: t\n        });\n      }\n      async pickSVCLayer(e, t) {\n        await this.signal.request(FV.PICK_SVC_LAYER, {\n          stream_id: e,\n          spatial_layer: t.spatialLayer,\n          temporal_layer: t.temporalLayer\n        });\n      }\n      async setRTM2Flag(e) {\n        await this.signal.request(FV.SET_RTM2_FLAG, {\n          rtm2_flag: e\n        });\n      }\n      async sendExtensionMessage(e, t, i) {\n        if (this.store.useP2P) return this.signal.sendExtensionMessage(e, t, i);\n      }\n      getInChannelInfo() {\n        return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), dB({}, this.inChannelInfo);\n      }\n      async setConfigure(e) {\n        if (e && Array.isArray(e) && 0 !== e.length) return this.signal.request(FV.CONFIGURE, e);\n      }\n      async getGatewayVersion() {\n        return (await this.signal.request(FV.GATEWAY_INFO)).version;\n      }\n      reset() {\n        if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {\n          const e = lB.get(this.joinInfo.cname);\n          e && e.delete(this.joinInfo.uid);\n        }\n        this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0), this.usingProxy = !1;\n      }\n      updateTurnConfigFromSignal() {\n        if (!this.joinInfo) return;\n        const e = function (e) {\n          let t;\n          return t = e.startsWith(\"dc\") ? e.match(/(dc\\:\\/\\/)?([^:]+):(\\d+)/) : e.match(/(wss\\:\\/\\/)?([^:]+):(\\d+)/), t ? {\n            username: ED.username,\n            password: ED.password,\n            turnServerURL: t[2],\n            tcpport: parseInt(t[3]) + 30,\n            udpport: parseInt(t[3]) + 30,\n            forceturn: !1\n          } : null;\n        }((\"disabled\" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || \"\");\n        this.joinInfo.turnServer.serversFromGateway = [], e && \"off\" !== this.joinInfo.turnServer.mode && \"disabled\" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(dB(dB({}, ED), {}, {\n          turnServerURL: e.turnServerURL,\n          tcpport: e.tcpport,\n          udpport: e.udpport,\n          username: this.joinInfo.uid.toString(),\n          password: this.joinInfo.token\n        }));\n      }\n      async updateTrafficStats() {\n        if (\"CONNECTED\" !== this.state) return;\n        const e = await this.signal.request(FV.TRAFFIC_STATS, void 0, !0);\n        e.timestamp = Date.now(), null != e.ntp_offset && (this.ntpOffset = e.ntp_offset), e.peer_delay.forEach(e => {\n          const t = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find(t => t.peer_uid === e.peer_uid);\n          t && t.B_st !== e.B_st && oN(() => {\n            this.emit(sx.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st);\n          });\n        }), this._statsCollector.updateTrafficStats(e);\n      }\n      getJoinMessage(e) {\n        var t, i, n, r;\n        if (!this.joinInfo || !this.key) throw new uP(hO.UNEXPECTED_ERROR, \"can not generate join message, no join info\");\n        const o = Object.assign({}, this.joinInfo.apResponse);\n        let s = CD(\"REPORT_APP_SCENARIO\");\n        if (\"string\" != typeof s) try {\n          s = JSON.stringify(s);\n        } catch (e) {\n          s = void 0;\n        }\n        var a;\n        s && s.length > 128 && (s = void 0), this.store.hasStartJoinChannel = !0, this.store.isABTestSuccess || this.emit(sx.UPDATE_GATEWAY_CONFIG), a = this.store.clientId, Ln(YU).call(YU, a) || YU.push(a);\n        const c = mP(this.store),\n          d = !(null === (t = this.isPreallocation) || void 0 === t || !t.call(this)),\n          l = fP(this.store),\n          u = iB(),\n          h = Gw(87) || xw() || Yw(117),\n          p = (function () {\n            const e = Dw();\n            if (e.name !== bw.SAFARI || !e.browserVersion) return !1;\n            const t = e.browserVersion.split(\".\");\n            return Number(t[0]) > 18 || 18 === Number(t[0]) && Number(t[1]) >= 4;\n          }() || qw(18, 4, !1)) && Jw(18, 6, !0) && \"h264\" === this.spec.codec && CD(\"ENABLE_ABSSENDTIME_AS_SENTTS\"),\n          _ = !(\"CN\" !== (null === (i = o.detail) || void 0 === i ? void 0 : i[3]) || !CD(\"ENABLE_QUALITY_FALLBACK\")) && CD(\"ENABLE_QUALITY_FALLBACK\"),\n          E = !!CD(\"ENABLE_AP_MULTI_IP\") && \"multi-ip\" === (null === (n = o.detail) || void 0 === n ? void 0 : n[5]),\n          m = dB({\n            license: this.joinInfo.license,\n            p2p_id: this.store.p2pId,\n            session_id: this.joinInfo.sid,\n            app_id: this.joinInfo.appId,\n            channel_key: this.key,\n            channel_name: this.joinInfo.cname,\n            sdk_version: hD,\n            browser: navigator.userAgent,\n            process_id: CD(\"PROCESS_ID\"),\n            mode: this.store.useP2P ? \"p2p\" : this.spec.mode,\n            codec: this.spec.codec,\n            role: this.role,\n            has_changed_gateway: E || this.hasChangeBGPAddress,\n            ap_response: o,\n            extend: CD(\"JOIN_EXTEND\"),\n            details: {\n              6: this.joinInfo.stringUid,\n              cservice_map: \"proxy3\" === this.joinInfo.cloudProxyServer ? \"1\" : \"proxy5\" === this.joinInfo.cloudProxyServer ? \"2\" : void 0\n            },\n            features: {\n              rejoin: !0\n            },\n            optionalInfo: this.joinInfo.optionalInfo,\n            appScenario: s,\n            attributes: {\n              userAttributes: dB(dB({\n                enableEncodedTransform: (!!CD(\"ENABLE_AUDIO_METADATA\") || !!CD(\"ENABLE_AUDIO_PTS\")) && h || !!CD(\"ENABLE_AUDIO_TOPN\") && Hw(bw.CHROME, 87, 116) || void 0,\n                enableAudioMetadata: !!CD(\"ENABLE_AUDIO_METADATA\") && h,\n                enableAudioPts: !!CD(\"ENABLE_AUDIO_PTS\") && h,\n                topnSmoothLevel: CD(\"TOPN_SMOOTH_LEVEL\"),\n                topnNewSpeakerDelay: CD(\"TOPN_NEW_SPEAKER_DELAY\"),\n                topnSwitchHoldMs: CD(\"TOPN_SWITCH_HOLD_MS\"),\n                topnAudioGain: CD(\"TOPN_AUDIO_GAIN\"),\n                enableNetworkQualityProbe: this.store.networkQualityProbe,\n                enablePublishedUserList: CD(\"ENABLE_PUBLISHED_USER_LIST\"),\n                maxSubscription: CD(\"MAX_SUBSCRIPTION\"),\n                subscribeAudioFilterTopN: tB(\"SUBSCRIBE_AUDIO_FILTER_TOPN\", \"number\"),\n                enablePublishAudioFilter: tB(\"ENABLE_PUBLISH_AUDIO_FILTER\", \"boolean\"),\n                enableUserLicenseCheck: tB(\"ENABLE_USER_LICENSE_CHECK\", \"boolean\"),\n                enableRTX: !0 === CD(\"USE_PUB_RTX\") || !0 === CD(\"USE_SUB_RTX\") || void 0,\n                disableFEC: CD(\"DISABLE_FEC\"),\n                enableNTPReport: !!CD(\"ENABLE_NTP_REPORT\") || void 0,\n                enableInstantVideo: l,\n                enableFulllinkAvSync: !!CD(\"ENABLE_FULL_LINK_AV_SYNC\") || void 0,\n                enableDataStream2: tB(\"ENABLE_DATASTREAM_2\", \"boolean\"),\n                enableAutFeedback: !!CD(\"FORCE_ENABLE_AUT_CC\") || !EP() && (!!CD(\"ENABLE_AUT_FEEDBACK\") || void 0),\n                rtm2Flag: \"number\" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0,\n                enableUserAutoRebalanceCheck: !!CD(\"ENABLE_USER_AUTO_REBALANCE_CHECK\"),\n                enableXR: tB(\"USE_XR\", \"boolean\"),\n                enableLossbasedBwe: tB(\"ENABLE_LOSSBASED_BWE\", \"boolean\"),\n                enableAutCC: !!CD(\"FORCE_ENABLE_AUT_CC\") || !EP() && (!!CD(\"ENABLE_AUT_CC\") || void 0),\n                enableCCFallback: tB(\"ENABLE_CC_FALLBACK\", \"boolean\"),\n                enablePreallocPC: d,\n                preSubNum: c ? tB(\"PRE_SUB_NUM\", \"number\") : void 0,\n                enablePubTWCC: tB(\"PUBLISH_TWCC\", \"boolean\"),\n                enableSubTWCC: tB(\"SUBSCRIBE_TWCC\", \"boolean\"),\n                enablePubRTX: tB(\"USE_PUB_RTX\", \"boolean\"),\n                enableSubRTX: tB(\"USE_SUB_RTX\", \"boolean\"),\n                enableSubSVC: CD(\"ENABLE_SVC\") ? CD(\"ENABLE_SVC_DEFAULT_CODECS\") : Array.isArray(CD(\"SVC\")) && 0 !== CD(\"SVC\").length ? CD(\"SVC\") : void 0,\n                enableSvcExtended: CD(\"ENABLE_SVC\") && Array.isArray(CD(\"SVC_EXTENDED\")) && 0 !== CD(\"SVC_EXTENDED\").length ? CD(\"SVC_EXTENDED\") : void 0,\n                enableVosFallback: CD(\"ENABLE_VOS_FALLBACK\"),\n                enableQualityFallback: _\n              }, u), {}, {\n                audioDuplicate: tB(\"ENABLE_AUDIO_RED\", \"boolean\") ? null !== (r = tB(\"AUDIO_DUPLICATE_NUM\", \"number\")) && void 0 !== r ? r : 2 : void 0,\n                senttsUsesAbsSendTime: !!p || void 0,\n                enableDualStreamFlag: tB(\"ENABLE_DUAL_STREAM_FLAG\", \"boolean\")\n              })\n            },\n            join_ts: this.joinGatewayStartTime\n          }, e);\n        return this.joinInfo.stringUid && (m.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (m.aes_mode = this.joinInfo.aesmode, CD(\"ENCRYPT_AES\") ? (m.aes_secret = this.joinInfo.aespassword, m.aes_encrypt = !0) : m.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (m.aes_salt = this.joinInfo.aessalt)), o.addresses[this.signal.websocket.currentURLIndex] && (m.ap_response.ticket = o.addresses[this.signal.websocket.currentURLIndex].ticket, delete o.addresses), void 0 !== this.joinInfo.defaultVideoStream && (m.default_video_stream = this.joinInfo.defaultVideoStream), m;\n      }\n      getRejoinMessage() {\n        if (!this.joinInfo) throw new uP(hO.UNEXPECTED_ERROR, \"can not generate rejoin message, no join info\");\n        return {\n          session_id: this.joinInfo.sid,\n          channel_name: this.joinInfo.cname,\n          cid: this.joinInfo.cid,\n          uid: this.joinInfo.uid,\n          vid: Number(this.joinInfo.vid)\n        };\n      }\n      handleSignalEvents() {\n        this.signal.on(xV.WS_RECONNECT_CREATE_CONNECTION, e => {\n          this.joinGatewayStartTime = Date.now();\n        }), this.signal.on(xV.WS_RECONNECTING, e => {\n          this.joinInfo && lP.WebSocketQuit(this.joinInfo.sid, {\n            lts: Date.now(),\n            succ: -1,\n            cname: this.joinInfo.cname,\n            uid: this.joinInfo.uid,\n            cid: this.joinInfo.cid,\n            errorCode: e || HO.NETWORK_ERROR\n          }), this.joinInfo && (this.state = \"RECONNECTING\", lP.sessionInit(this.joinInfo.sid, {\n            lts: new Date().getTime(),\n            extend: this.isSignalRecover ? {\n              recover: !0\n            } : {\n              rejoin: !0\n            },\n            cname: this.joinInfo.cname,\n            appid: this.joinInfo.appId,\n            mode: this.spec.mode,\n            stringUid: this.joinInfo.stringUid,\n            channelProfile: \"live\" === this.spec.mode ? 1 : 0,\n            channelMode: 0,\n            lsid: this.joinInfo.sid,\n            clientRole: \"audience\" === this.role ? 2 : 1,\n            buildFormat: 1\n          }), this.isSignalRecover = !1, this.joinGatewayStartTime = Date.now());\n        }), this.signal.on(xV.WS_CLOSED, e => {\n          let t;\n          switch (e) {\n            case VO.LEAVE:\n              t = HO.LEAVE;\n              break;\n            case VO.UID_BANNED:\n            case VO.IP_BANNED:\n            case VO.CHANNEL_BANNED:\n            case VO.SERVER_ERROR:\n              t = HO.SERVER_ERROR;\n              break;\n            case VO.FALLBACK:\n              t = HO.FALLBACK;\n              break;\n            case VO.LICENSE_MISSING:\n            case VO.LICENSE_EXPIRED:\n            case VO.LICENSE_MINUTES_EXCEEDED:\n            case VO.LICENSE_PERIOD_INVALID:\n            case VO.LICENSE_MULTIPLE_SDK_SERVICE:\n            case VO.LICENSE_ILLEGAL:\n            case VO.TOKEN_EXPIRE:\n              t = e;\n              break;\n            default:\n              t = HO.NETWORK_ERROR;\n          }\n          iP.debug(\"[\".concat(this.store.clientId, \"] [signal] websocket closed, reason: \").concat(t || \"undefined -> \" + HO.NETWORK_ERROR)), this.joinInfo && lP.WebSocketQuit(this.joinInfo.sid, {\n            lts: Date.now(),\n            succ: e === VO.LEAVE ? 1 : -1,\n            cname: this.joinInfo.cname,\n            uid: this.joinInfo.uid,\n            cid: this.joinInfo.cid,\n            errorCode: t\n          }), this._disconnectedReason = e, e !== VO.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n        }), this.signal.on(xV.WS_CONNECTED, () => {\n          if (this.updateTurnConfigFromSignal(), this.state = \"CONNECTED\", this.joinInfo) {\n            if (\"audience\" === this.role) {\n              const e = CD(\"CLIENT_ROLE_OPTIONS\") || this._clientRoleOptions;\n              e && (e.level || e.delay) && (iP.debug(\"[\".concat(this.store.clientId, \"] patch to send set client role, role: \").concat(this.role, \", mode: \").concat(this.spec.mode, \", level: \").concat(e.level, \", delay: \").concat(e.delay)), this.setClientRole(this.role, e));\n            }\n            if (lP.joinGateway(this.joinInfo.sid, {\n              lts: this.joinGatewayStartTime,\n              succ: !0,\n              ec: null,\n              vid: this.joinInfo.vid,\n              addr: this.signal.url,\n              uid: this.joinInfo.uid,\n              cid: this.joinInfo.cid,\n              firstSuccess: this._isProactiveJoin,\n              isProxy: !!this.joinInfo.proxyServer || this.usingProxy,\n              signalChannel: \"DataChannelSignal\" === this.signal.__name__ ? \"1\" : \"0\",\n              preload: this.joinInfo.preload,\n              isABTestSuccess: this.store.isABTestSuccess\n            }), this._isProactiveJoin = !1, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion) {\n              const e = this.signal.url && this.signal.url.match(/wss\\:\\/\\/([^:]+):(\\d+)/);\n              if (!e) return void iP.error(\"[\".concat(this.store.clientId, \"] set local access point after joined failed: \").concat(e));\n              RD(\"EVENT_REPORT_DOMAIN\", e[1]), RD(\"EVENT_REPORT_BACKUP_DOMAIN\", e[1]), RD(\"LOG_UPLOAD_SERVER\", \"\".concat(e[1], \":6444\"));\n            }\n          }\n        }), this.signal.on(jV.ON_UPLINK_STATS, e => {\n          this._statsCollector.updateUplinkStats(e);\n        }), this.signal.on(xV.REQUEST_RECOVER, (e, t, i) => {\n          if (!this.joinInfo) return i(new uP(hO.UNEXPECTED_ERROR, \"gateway: can not recover, no join info\"));\n          e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = !0), this.isSignalRecover = !0, zO(this, sx.REQUEST_NEW_GATEWAY_LIST).then(t).catch(i);\n        }), this.signal.on(xV.REQUEST_JOIN_INFO, async (e, t, i) => {\n          var n, r, o;\n          if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e(this.getJoinMessage({\n            ortc: {}\n          }));\n          const s = sN(null === (n = this.joinInfo) || void 0 === n ? void 0 : n.turnServer);\n          if (CD(\"NEW_TURN_MODE\") && s && \"disabled\" === (null === (r = this.joinInfo) || void 0 === r ? void 0 : r.cloudProxyServer)) {\n            var a;\n            let e = s.servers.map(e => \"turnServerURL\" in e && CD(\"USE_TURN_IP\") ? dB(dB({}, e), {}, {\n                turnServerURL: aF(e.turnServerURL)\n              }) : e),\n              t = null === (a = s.serversFromGateway) || void 0 === a ? void 0 : a.map(e => CD(\"USE_TURN_IP\") ? dB(dB({}, e), {}, {\n                turnServerURL: aF(e.turnServerURL)\n              }) : e);\n            const i = this.signal.currentURLIndex;\n            if (e.length > 0) {\n              e = [e[i % e.length]], s.servers = e;\n            }\n            Array.isArray(t) && t.length > 0 && (t = [t[0]], s.serversFromGateway = t), iP.debug(\"[\".concat(this.store.clientId, \"] use single turn, use turn server index: \").concat(i));\n          }\n          const {\n            iceParameters: c,\n            dtlsParameters: d,\n            rtpCapabilities: l\n          } = await zO(this, sx.REQUEST_P2P_CONNECTION_PARAMS, {\n            turnServer: s,\n            cloudProxyServer: null === (o = this.joinInfo) || void 0 === o ? void 0 : o.cloudProxyServer\n          });\n          try {\n            e(this.getJoinMessage({\n              ortc: {\n                iceParameters: c,\n                dtlsParameters: d,\n                rtpCapabilities: l,\n                version: \"2\"\n              }\n            }));\n          } catch (e) {\n            t(e);\n          }\n        }), this.signal.on(xV.REQUEST_REJOIN_INFO, e => {\n          e(this.getRejoinMessage());\n        }), this.signal.on(xV.REPORT_JOIN_GATEWAY, (e, t) => {\n          if (!this.joinInfo) return;\n          let i,\n            n = \"\";\n          var r;\n          e instanceof uP ? (i = (null === (r = e.data) || void 0 === r ? void 0 : r.desc) || e.code, n = e.message) : i = e;\n          lP.joinGateway(this.joinInfo.sid, {\n            lts: this.joinGatewayStartTime,\n            succ: !1,\n            ec: i,\n            errorMsg: n,\n            addr: t,\n            uid: this.joinInfo.uid,\n            cid: this.joinInfo.cid,\n            firstSuccess: this._isProactiveJoin,\n            isProxy: !!this.joinInfo.proxyServer || this.usingProxy,\n            signalChannel: \"DataChannelSignal\" === this.signal.__name__ ? \"1\" : \"0\",\n            preload: this.joinInfo.preload\n          });\n        }), this.signal.on(xV.IS_P2P_DISCONNECTED, e => {\n          e(JO(this, sx.IS_P2P_DISCONNECTED));\n        }), this.signal.on(xV.DISCONNECT_P2P, () => {\n          this.emit(sx.DISCONNECT_P2P);\n        }), this.signal.on(xV.REQUEST_SUCCESS, () => {\n          this._signalTimeout = !1;\n        }), this.signal.on(xV.REQUEST_TIMEOUT, () => {\n          this._signalTimeout = !0;\n        }), this.signal.on(xV.JOIN_RESPONSE, e => {\n          const t = this.getCurrentGatewayAddress();\n          this.emit(sx.JOIN_RESPONSE, e, t);\n        }), this.signal.on(xV.PRE_CONNECT_PC, async (e, t) => {\n          if (this.joinInfo) {\n            var i, n;\n            this.updateTurnConfigFromSignal();\n            const o = this.getCurrentGatewayAddress(),\n              s = sN(null === (i = this.joinInfo) || void 0 === i ? void 0 : i.turnServer);\n            if (CD(\"NEW_TURN_MODE\") && s && \"disabled\" === (null === (n = this.joinInfo) || void 0 === n ? void 0 : n.cloudProxyServer)) {\n              var r;\n              let e = s.servers.map(e => \"turnServerURL\" in e && CD(\"USE_TURN_IP\") ? dB(dB({}, e), {}, {\n                  turnServerURL: aF(e.turnServerURL)\n                }) : e),\n                t = null === (r = s.serversFromGateway) || void 0 === r ? void 0 : r.map(e => CD(\"USE_TURN_IP\") ? dB(dB({}, e), {}, {\n                  turnServerURL: aF(e.turnServerURL)\n                }) : e);\n              const i = this.signal.currentURLIndex;\n              if (e.length > 0) {\n                e = [e[i % e.length]], s.servers = e;\n              }\n              Array.isArray(t) && t.length > 0 && (t = [t[0]], s.serversFromGateway = t), iP.debug(\"[\".concat(this.store.clientId, \"] use single turn, use turn server index: \").concat(i, \",in pre pc\"));\n            }\n            const a = CD(\"FINGERPRINT\") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;\n            if (o && a) {\n              const i = PF(o);\n              zO(this, sx.PRE_CONNECT_PC, {\n                candidates: i,\n                fingerprint: a,\n                turnServer: s\n              }).then(t => {\n                null == e || e(t);\n              }).catch(t || (() => {}));\n            }\n          }\n        }), this.signal.on(xV.RECOVER_NOTIFICATION, e => {\n          this.joinInfo && \"string\" == typeof CD(\"AP_REQUEST_DETAIL\") && (this.joinInfo.apRequestDetail = \"\".concat(CD(\"AP_REQUEST_DETAIL\"), \";\").concat(e));\n        }), this.signal.on(xV.VOS_FALLBACK, e => {\n          this.emit(sx.VOS_FALLBACK, e);\n        }), this.signal.on(xV.DATACHANNEL_FAILBACK, e => {\n          iP.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\")), this.reset(), this.resetSignal(), this.emit(sx.DATACHANNEL_FAILBACK);\n        });\n      }\n      async tryUnsubBeforeResub(e, t) {\n        try {\n          await this.signal.request(FV.UNSUBSCRIBE, {\n            p2p_id: this.store.p2pId,\n            stream_id: e,\n            ortc: [t]\n          }, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] tryUnsubBeforeResub warning\"), e), e;\n        }\n      }\n      async tryUnsubDataChannelBeforeResub(e, t) {\n        try {\n          await this.signal.request(FV.UNSUBSCRIBE, {\n            stream_id: t.id\n          }, !0);\n        } catch (e) {\n          throw iP.warning(\"unsubscribe datachannel warning\", e), e;\n        }\n      }\n      async tryUnpubBeforeRepub(e, t) {\n        try {\n          await this.signal.request(FV.UNPUBLISH, {\n            stream_id: e,\n            ortc: t\n          }, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] tryUnpubBeforeRepub warning: \"), e), e;\n        }\n      }\n      async tryUnpubDataChannelBeforeRepub(e, t) {\n        try {\n          await this.signal.request(FV.UNPUBLISH_DATASTREAM, {\n            channnel_id: t.channelId\n          }, !0);\n        } catch (e) {\n          throw iP.warning(\"unpublish datastream warning: \", e), e;\n        }\n      }\n      async tryMassUnsubBeforeResub(e) {\n        const t = {\n          users: e.map(e => ({\n            stream_id: e.stream_id,\n            stream_type: e.stream_type\n          }))\n        };\n        try {\n          await this.signal.request(FV.UNSUBSCRIBE_STREAMS, t, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] tryMassUnsubBeforeResub warning\"), e), e;\n        }\n      }\n      async muteLocal(e, t) {\n        const i = {\n          action: e.find(e => e.stream_type === ox.Audio) ? \"mute_local_audio\" : \"mute_local_video\",\n          p2p_id: this.store.p2pId,\n          ortc: e,\n          stream_id: t\n        };\n        try {\n          await this.signal.request(FV.CONTROL, i, !0, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] gateway muteLocal warning: \"), e), e;\n        }\n      }\n      async unmuteLocal(e, t) {\n        const i = {\n          action: e.find(e => e.stream_type === ox.Audio) ? \"unmute_local_audio\" : \"unmute_local_video\",\n          p2p_id: this.store.p2pId,\n          ortc: e,\n          stream_id: t\n        };\n        try {\n          await this.signal.request(FV.CONTROL, i, !0, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] gateway unmuteLocal warning: \"), e), e;\n        }\n      }\n      async muteRemote(e, t) {\n        const i = {\n          action: e === fx.AUDIO ? \"mute_remote_audio\" : \"mute_remote_video\",\n          p2p_id: this.store.p2pId,\n          stream_id: t\n        };\n        try {\n          await this.signal.request(FV.CONTROL, i, !0, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] gateway muteRemote warning: \"), e), e;\n        }\n      }\n      async unmuteRemote(e, t) {\n        const i = {\n          action: e === fx.AUDIO ? \"unmute_remote_audio\" : \"unmute_remote_video\",\n          p2p_id: this.store.p2pId,\n          stream_id: t\n        };\n        try {\n          await this.signal.request(FV.CONTROL, i, !0, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] gateway unmuteRemote warning: \"), e), e;\n        }\n      }\n      uploadWRTCStats(e) {\n        this.signal.uploadWRTCStats(e);\n      }\n      upload(e, t) {\n        this.signal.upload(e, t);\n      }\n      getSignalRTT() {\n        return this.signal.rtt;\n      }\n      async restartICE(e) {\n        const t = {\n          p2p_id: this.store.p2pId,\n          stream_id: this.store.uid,\n          ortc: e\n        };\n        try {\n          return await this.signal.request(FV.RESTART_ICE, t, !0);\n        } catch (e) {\n          throw iP.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.restartICE warning: \"), e), e;\n        }\n      }\n      reconnect(e, t) {\n        \"CONNECTED\" === this.state && this.signal.reconnect(e || void 0, t || HO.P2P_FAILED);\n      }\n      getCurrentGatewayAddress() {\n        var e, t;\n        if (!CD(\"GATEWAY_WSS_ADDRESS\")) return CD(\"USE_CANDIDATE_FROM_AP_DETAIL\") && null !== (e = this.joinInfo) && void 0 !== e && e.apGatewayAddress ? (iP.debug(\"[\".concat(this.store.clientId, \"] use candidate from ap detail, \").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : null !== (t = this.joinInfo) && void 0 !== t && t.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;\n      }\n      async setPublishAudioFilterEnabled(e) {\n        await this.signal.request(FV.SET_PARAMETER, {\n          enablePublishAudioFilter: e\n        });\n      }\n      downgradeCodec(e) {\n        this.signal.downgradeCodec(e);\n      }\n      resetSignal() {\n        this.signal && (this.signal.removeAllListeners(), this.signal.close(VO.FALLBACK)), this.store.useDcSignal = !1, this.signal = new eF(dB(dB({}, this.spec), {}, {\n          retryConfig: this.spec.websocketRetryConfig\n        }), this.store), this.handleSignalEvents(), this.emit(sx.RESET_SIGNAL);\n      }\n    }\n    let hB = 0,\n      pB = 0;\n    function _B(e, t, i, n) {\n      return new rp((r, o) => {\n        t.timeout = t.timeout || CD(\"HTTP_CONNECT_TIMEOUT\"), t.responseType = t.responseType || \"json\", t.data && !i ? (t.data = JSON.stringify(t.data), hB += _N(t.data)) : i && (t.data.size ? hB += t.data.size : t.data instanceof FormData ? hB += EN(t.data) : hB += _N(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers[\"Content-Type\"] = t.headers[\"Content-Type\"] || \"application/json\", t.method = \"POST\", t.url = e, Tw.request(t).then(e => {\n          \"string\" == typeof e.data ? pB += _N(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? pB += e.data.byteLength : pB += _N(JSON.stringify(e.data)), n && r({\n            data: e.data,\n            headers: e.headers\n          }), r(e.data);\n        }).catch(e => {\n          Tw.isCancel(e) ? o(new uP(hO.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === e.code ? o(new uP(hO.NETWORK_TIMEOUT, e.message)) : e.response ? o(new uP(hO.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new uP(hO.NETWORK_ERROR, e.message));\n        });\n      });\n    }\n    /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */\n    !function () {\n      var e;\n      function i(e) {\n        var t = 0;\n        return function () {\n          return t < e.length ? {\n            done: !1,\n            value: e[t++]\n          } : {\n            done: !0\n          };\n        };\n      }\n      var n = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, i) {\n        return e == Array.prototype || e == Object.prototype || (e[t] = i.value), e;\n      };\n      var r,\n        o = function (e) {\n          e = [\"object\" == typeof globalThis && globalThis, e, false && window, \"object\" == typeof self && self, \"object\" == typeof t && t];\n          for (var i = 0; i < e.length; ++i) {\n            var n = e[i];\n            if (n && n.Math == Math) return n;\n          }\n          throw Error(\"Cannot find global object\");\n        }(this);\n      function s(e, t) {\n        if (t) e: {\n          var i = o;\n          e = e.split(\".\");\n          for (var r = 0; r < e.length - 1; r++) {\n            var s = e[r];\n            if (!(s in i)) break e;\n            i = i[s];\n          }\n          (t = t(r = i[e = e[e.length - 1]])) != r && null != t && n(i, e, {\n            configurable: !0,\n            writable: !0,\n            value: t\n          });\n        }\n      }\n      function a(e) {\n        return (e = {\n          next: e\n        })[Symbol.iterator] = function () {\n          return this;\n        }, e;\n      }\n      function c(e) {\n        var t = \"undefined\" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];\n        return t ? t.call(e) : {\n          next: i(e)\n        };\n      }\n      if (s(\"Symbol\", function (e) {\n        function t(e, t) {\n          this.A = e, n(this, \"description\", {\n            configurable: !0,\n            writable: !0,\n            value: t\n          });\n        }\n        if (e) return e;\n        t.prototype.toString = function () {\n          return this.A;\n        };\n        var i = \"jscomp_symbol_\" + (1e9 * Math.random() >>> 0) + \"_\",\n          r = 0;\n        return function e(n) {\n          if (this instanceof e) throw new TypeError(\"Symbol is not a constructor\");\n          return new t(i + (n || \"\") + \"_\" + r++, n);\n        };\n      }), s(\"Symbol.iterator\", function (e) {\n        if (e) return e;\n        e = Symbol(\"Symbol.iterator\");\n        for (var t = \"Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \"), r = 0; r < t.length; r++) {\n          var s = o[t[r]];\n          \"function\" == typeof s && \"function\" != typeof s.prototype[e] && n(s.prototype, e, {\n            configurable: !0,\n            writable: !0,\n            value: function () {\n              return a(i(this));\n            }\n          });\n        }\n        return e;\n      }), \"function\" == typeof Object.setPrototypeOf) r = Object.setPrototypeOf;else {\n        var d;\n        e: {\n          var l = {};\n          try {\n            l.__proto__ = {\n              a: !0\n            }, d = l.a;\n            break e;\n          } catch (e) {}\n          d = !1;\n        }\n        r = d ? function (e, t) {\n          if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + \" is not extensible\");\n          return e;\n        } : null;\n      }\n      var u = r;\n      function h() {\n        this.m = !1, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;\n      }\n      function p(e) {\n        if (e.m) throw new TypeError(\"Generator is already running\");\n        e.m = !0;\n      }\n      function _(e, t) {\n        return e.h = 3, {\n          value: t\n        };\n      }\n      function E(e) {\n        this.g = new h(), this.G = e;\n      }\n      function m(e, t, i, n) {\n        try {\n          var r = t.call(e.g.j, i);\n          if (!(r instanceof Object)) throw new TypeError(\"Iterator result \" + r + \" is not an object\");\n          if (!r.done) return e.g.m = !1, r;\n          var o = r.value;\n        } catch (t) {\n          return e.g.j = null, e.g.s(t), f(e);\n        }\n        return e.g.j = null, n.call(e.g, o), f(e);\n      }\n      function f(e) {\n        for (; e.g.h;) try {\n          var t = e.G(e.g);\n          if (t) return e.g.m = !1, {\n            value: t.value,\n            done: !1\n          };\n        } catch (t) {\n          e.g.v = void 0, e.g.s(t);\n        }\n        if (e.g.m = !1, e.g.l) {\n          if (t = e.g.l, e.g.l = null, t.F) throw t.D;\n          return {\n            value: t.return,\n            done: !0\n          };\n        }\n        return {\n          value: void 0,\n          done: !0\n        };\n      }\n      function S(e) {\n        this.next = function (t) {\n          return e.o(t);\n        }, this.throw = function (t) {\n          return e.s(t);\n        }, this.return = function (t) {\n          return function (e, t) {\n            p(e.g);\n            var i = e.g.j;\n            return i ? m(e, \"return\" in i ? i.return : function (e) {\n              return {\n                value: e,\n                done: !0\n              };\n            }, t, e.g.return) : (e.g.return(t), f(e));\n          }(e, t);\n        }, this[Symbol.iterator] = function () {\n          return this;\n        };\n      }\n      function g(e, t) {\n        return t = new S(new E(t)), u && e.prototype && u(t, e.prototype), t;\n      }\n      if (h.prototype.o = function (e) {\n        this.v = e;\n      }, h.prototype.s = function (e) {\n        this.l = {\n          D: e,\n          F: !0\n        }, this.h = this.C || this.u;\n      }, h.prototype.return = function (e) {\n        this.l = {\n          return: e\n        }, this.h = this.u;\n      }, E.prototype.o = function (e) {\n        return p(this.g), this.g.j ? m(this, this.g.j.next, e, this.g.o) : (this.g.o(e), f(this));\n      }, E.prototype.s = function (e) {\n        return p(this.g), this.g.j ? m(this, this.g.j.throw, e, this.g.o) : (this.g.s(e), f(this));\n      }, s(\"Array.prototype.entries\", function (e) {\n        return e || function () {\n          return function (e, t) {\n            e instanceof String && (e += \"\");\n            var i = 0,\n              n = !1,\n              r = {\n                next: function () {\n                  if (!n && i < e.length) {\n                    var r = i++;\n                    return {\n                      value: t(r, e[r]),\n                      done: !1\n                    };\n                  }\n                  return n = !0, {\n                    done: !0,\n                    value: void 0\n                  };\n                }\n              };\n            return r[Symbol.iterator] = function () {\n              return r;\n            }, r;\n          }(this, function (e, t) {\n            return [e, t];\n          });\n        };\n      }), \"undefined\" != typeof Blob && (\"undefined\" == typeof FormData || !FormData.prototype.keys)) {\n        var T = function (e, t) {\n            for (var i = 0; i < e.length; i++) t(e[i]);\n          },\n          R = function (e) {\n            return e.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n          },\n          C = function (e, t, i) {\n            return t instanceof Blob ? (i = void 0 !== i ? String(i + \"\") : \"string\" == typeof t.name ? t.name : \"blob\", t.name === i && \"[object Blob]\" !== Object.prototype.toString.call(t) || (t = new File([t], i)), [String(e), t]) : [String(e), String(t)];\n          },\n          v = function (e, t) {\n            if (e.length < t) throw new TypeError(t + \" argument required, but only \" + e.length + \" present.\");\n          },\n          y = \"object\" == typeof globalThis ? globalThis : false ? window : \"object\" == typeof self ? self : this,\n          I = y.FormData,\n          A = y.XMLHttpRequest && y.XMLHttpRequest.prototype.send,\n          b = y.Request && y.fetch,\n          w = y.navigator && y.navigator.sendBeacon,\n          O = y.Element && y.Element.prototype,\n          N = y.Symbol && Symbol.toStringTag;\n        N && (Blob.prototype[N] || (Blob.prototype[N] = \"Blob\"), \"File\" in y && !File.prototype[N] && (File.prototype[N] = \"File\"));\n        try {\n          new File([], \"\");\n        } catch (e) {\n          y.File = function (e, t, i) {\n            return e = new Blob(e, i || {}), Object.defineProperties(e, {\n              name: {\n                value: t\n              },\n              lastModified: {\n                value: +(i && void 0 !== i.lastModified ? new Date(i.lastModified) : new Date())\n              },\n              toString: {\n                value: function () {\n                  return \"[object File]\";\n                }\n              }\n            }), N && Object.defineProperty(e, N, {\n              value: \"File\"\n            }), e;\n          };\n        }\n        var D = function (e) {\n            return e.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n          },\n          P = function (e) {\n            this.i = [];\n            var t = this;\n            e && T(e.elements, function (e) {\n              if (e.name && !e.disabled && \"submit\" !== e.type && \"button\" !== e.type && !e.matches(\"form fieldset[disabled] *\")) if (\"file\" === e.type) {\n                var i = e.files && e.files.length ? e.files : [new File([], \"\", {\n                  type: \"application/octet-stream\"\n                })];\n                T(i, function (i) {\n                  t.append(e.name, i);\n                });\n              } else \"select-multiple\" === e.type || \"select-one\" === e.type ? T(e.options, function (i) {\n                !i.disabled && i.selected && t.append(e.name, i.value);\n              }) : \"checkbox\" === e.type || \"radio\" === e.type ? e.checked && t.append(e.name, e.value) : (i = \"textarea\" === e.type ? R(e.value) : e.value, t.append(e.name, i));\n            });\n          };\n        if ((e = P.prototype).append = function (e, t, i) {\n          v(arguments, 2), this.i.push(C(e, t, i));\n        }, e.delete = function (e) {\n          v(arguments, 1);\n          var t = [];\n          e = String(e), T(this.i, function (i) {\n            i[0] !== e && t.push(i);\n          }), this.i = t;\n        }, e.entries = function e() {\n          var t,\n            i = this;\n          return g(e, function (e) {\n            if (1 == e.h && (t = 0), 3 != e.h) return t < i.i.length ? e = _(e, i.i[t]) : (e.h = 0, e = void 0), e;\n            t++, e.h = 2;\n          });\n        }, e.forEach = function (e, t) {\n          v(arguments, 1);\n          for (var i = c(this), n = i.next(); !n.done; n = i.next()) {\n            var r = c(n.value);\n            n = r.next().value, r = r.next().value, e.call(t, r, n, this);\n          }\n        }, e.get = function (e) {\n          v(arguments, 1);\n          var t = this.i;\n          e = String(e);\n          for (var i = 0; i < t.length; i++) if (t[i][0] === e) return t[i][1];\n          return null;\n        }, e.getAll = function (e) {\n          v(arguments, 1);\n          var t = [];\n          return e = String(e), T(this.i, function (i) {\n            i[0] === e && t.push(i[1]);\n          }), t;\n        }, e.has = function (e) {\n          v(arguments, 1), e = String(e);\n          for (var t = 0; t < this.i.length; t++) if (this.i[t][0] === e) return !0;\n          return !1;\n        }, e.keys = function e() {\n          var t,\n            i,\n            n,\n            r,\n            o = this;\n          return g(e, function (e) {\n            if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (n = i.value, r = c(n), _(e, r.next().value));\n            i = t.next(), e.h = 2;\n          });\n        }, e.set = function (e, t, i) {\n          v(arguments, 2), e = String(e);\n          var n = [],\n            r = C(e, t, i),\n            o = !0;\n          T(this.i, function (t) {\n            t[0] === e ? o && (o = !n.push(r)) : n.push(t);\n          }), o && n.push(r), this.i = n;\n        }, e.values = function e() {\n          var t,\n            i,\n            n,\n            r,\n            o = this;\n          return g(e, function (e) {\n            if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (n = i.value, (r = c(n)).next(), _(e, r.next().value));\n            i = t.next(), e.h = 2;\n          });\n        }, P.prototype._asNative = function () {\n          for (var e = new I(), t = c(this), i = t.next(); !i.done; i = t.next()) {\n            var n = c(i.value);\n            i = n.next().value, n = n.next().value, e.append(i, n);\n          }\n          return e;\n        }, P.prototype._blob = function () {\n          var e = \"----formdata-polyfill-\" + Math.random(),\n            t = [],\n            i = \"--\" + e + '\\r\\nContent-Disposition: form-data; name=\"';\n          return this.forEach(function (e, n) {\n            return \"string\" == typeof e ? t.push(i + D(R(n)) + '\"\\r\\n\\r\\n' + R(e) + \"\\r\\n\") : t.push(i + D(R(n)) + '\"; filename=\"' + D(e.name) + '\"\\r\\nContent-Type: ' + (e.type || \"application/octet-stream\") + \"\\r\\n\\r\\n\", e, \"\\r\\n\");\n          }), t.push(\"--\" + e + \"--\"), new Blob(t, {\n            type: \"multipart/form-data; boundary=\" + e\n          });\n        }, P.prototype[Symbol.iterator] = function () {\n          return this.entries();\n        }, P.prototype.toString = function () {\n          return \"[object FormData]\";\n        }, O && !O.matches && (O.matches = O.matchesSelector || O.mozMatchesSelector || O.msMatchesSelector || O.oMatchesSelector || O.webkitMatchesSelector || function (e) {\n          for (var t = (e = (this.document || this.ownerDocument).querySelectorAll(e)).length; 0 <= --t && e.item(t) !== this;);\n          return -1 < t;\n        }), N && (P.prototype[N] = \"FormData\"), A) {\n          var L = y.XMLHttpRequest.prototype.setRequestHeader;\n          y.XMLHttpRequest.prototype.setRequestHeader = function (e, t) {\n            L.call(this, e, t), \"content-type\" === e.toLowerCase() && (this.B = !0);\n          }, y.XMLHttpRequest.prototype.send = function (e) {\n            e instanceof P ? (e = e._blob(), this.B || this.setRequestHeader(\"Content-Type\", e.type), A.call(this, e)) : A.call(this, e);\n          };\n        }\n        b && (y.fetch = function (e, t) {\n          return t && t.body && t.body instanceof P && (t.body = t.body._blob()), b.call(this, e, t);\n        }), w && (y.navigator.sendBeacon = function (e, t) {\n          return t instanceof P && (t = t._asNative()), w.call(this, e, t);\n        }), y.FormData = P;\n      }\n    }();\n    const EB = () => {\n        const e = CD(\"AREAS\");\n        0 === e.length && e.push(dx.GLOBAL);\n        return nr(e).call(e, (e, t, i) => {\n          const n = mB(t);\n          return n ? 0 === i ? n : \"\".concat(e, \",\").concat(n) : e;\n        }, \"\");\n      },\n      mB = e => e === dx.OVERSEA ? \"\".concat(ux.ASIA, \",\").concat(ux.EUROPE, \",\").concat(ux.AFRICA, \",\").concat(ux.NORTH_AMERICA, \",\").concat(ux.SOUTH_AMERICA, \",\").concat(ux.OCEANIA) : ux[e],\n      fB = e => {\n        const t = {\n          CODE: \"\",\n          WEBCS_DOMAIN: [],\n          WEBCS_DOMAIN_BACKUP_LIST: [],\n          PROXY_CS: [],\n          CDS_AP: [],\n          ACCOUNT_REGISTER: [],\n          UAP_AP: [],\n          EVENT_REPORT_DOMAIN: [],\n          EVENT_REPORT_BACKUP_DOMAIN: [],\n          LOG_UPLOAD_SERVER: [],\n          PROXY_SERVER_TYPE3: []\n        };\n        return e.map(e => {\n          const i = hx[e],\n            n = Object.keys(i);\n          n && n.map(e => {\n            \"CODE\" !== e && (t[e] = t[e].concat(i[e]));\n          });\n        }), t;\n      },\n      SB = {\n        GLOBAL: {\n          ASIA: [dx.CHINA, dx.JAPAN, dx.INDIA, dx.KOREA, dx.HKMC],\n          EUROPE: [],\n          NORTH_AMERICA: [dx.US],\n          SOUTH_AMERICA: [],\n          OCEANIA: [],\n          AFRICA: []\n        }\n      },\n      gB = Object.keys(SB[dx.GLOBAL]),\n      TB = [dx.CHINA, dx.NORTH_AMERICA, dx.EUROPE, dx.ASIA, dx.JAPAN, dx.INDIA, dx.OCEANIA, dx.SOUTH_AMERICA, dx.AFRICA, dx.KOREA, dx.HKMC, dx.US],\n      RB = function (e, t) {\n        let i = [];\n        if (Ln(e).call(e, dx.GLOBAL)) {\n          const o = [dx.GLOBAL, dx.OVERSEA],\n            s = Object.keys(hx);\n          if (t === dx.GLOBAL) throw new uP(hO.INVALID_PARAMS, \"GLOBAL is an invalid excludedArea value\");\n          if (t === dx.CHINA) i = [dx.OVERSEA];else if (r = t, Ln(gB).call(gB, r)) {\n            const e = (n = t, SB[dx.GLOBAL][n] || []),\n              r = [...o, t, ...e];\n            i = s.filter(e => !Ln(r).call(r, e));\n          } else if (function (e) {\n            let t = !1;\n            return gB.forEach(i => {\n              var n;\n              Ln(n = SB[dx.GLOBAL][i]).call(n, e) && (t = !0);\n            }), t;\n          }(t)) {\n            const e = function (e) {\n                let t;\n                return gB.forEach(i => {\n                  var n;\n                  Ln(n = SB[dx.GLOBAL][i]).call(n, e) && (t = i);\n                }), t;\n              }(t),\n              n = [...o, e, t];\n            i = s.filter(e => !Ln(n).call(n, e));\n          } else i = e;\n          i = function (e) {\n            const t = [];\n            return TB.forEach(i => {\n              Ln(e).call(e, i) && t.push(i);\n            }), t.concat(e.filter(e => !Ln(TB).call(TB, e)));\n          }(i);\n        } else i = e;\n        var n, r;\n        return i;\n      };\n    function CB(e) {\n      var t, i;\n      if (!e && Ln(t = CD(\"AREAS\")).call(t, dx.EXTENSIONS)) return iP.debug(\"update area from ap : reset\"), void vB(WU, !0);\n      if (!Ln(i = CD(\"AREAS\")).call(i, dx.GLOBAL) || !e) return;\n      let n = hx.EXTENSIONS;\n      n && (n = {\n        CODE: mB(dx.EXTENSIONS),\n        WEBCS_DOMAIN: [\"ap-web-1-\".concat(e, \".agora.io\")],\n        WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n        PROXY_CS: [\"proxy-ap-web-\".concat(e, \".agora.io\")],\n        CDS_AP: [\"cds-ap-web-1-\".concat(e, \".agora.io\"), \"cds-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n        ACCOUNT_REGISTER: [\"sua-ap-web-1-\".concat(e, \".agora.io\"), \"sua-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n        UAP_AP: [\"uap-ap-web-1-\".concat(e, \".agora.io\"), \"uap-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n        EVENT_REPORT_DOMAIN: [\"statscollector-1-\".concat(e, \".agora.io\")],\n        EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-\".concat(e, \".agora.io\")],\n        LOG_UPLOAD_SERVER: [\"logservice-\".concat(e, \".agora.io\")],\n        PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy-\".concat(e, \".agora.io\")]\n      }, iP.debug(\"update area from ap success: \".concat(e, \",config is \"), n), RD(\"AREAS\", [dx.EXTENSIONS], !0), Object.keys(n).map(e => {\n        if (\"LOG_UPLOAD_SERVER\" === e || \"EVENT_REPORT_DOMAIN\" === e || \"EVENT_REPORT_BACKUP_DOMAIN\" === e || \"PROXY_SERVER_TYPE3\" === e) {\n          RD(e, n[e][0]);\n        } else RD(e, n[e]);\n      }));\n    }\n    function vB(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = lP.reportApiInvoke(null, {\n        name: LO.SET_AREA,\n        options: e,\n        tag: kO.TRACER\n      });\n      try {\n        let n = [];\n        if (\"string\" == typeof e && (n = [e]), Array.isArray(e) && (e.forEach(e => {\n          if (!Ln(lx).call(lx, e)) throw new uP(hO.INVALID_PARAMS, \"invalid area code\");\n        }), n = e), \"[object Object]\" === Object.prototype.toString.call(e)) {\n          const {\n            areaCode: t,\n            excludedArea: i\n          } = e;\n          if (!t) throw new uP(hO.INVALID_PARAMS, \"area code is needed\");\n          let r = t;\n          \"string\" == typeof t && (r = [t]), n = i ? RB(r, i) : r;\n        }\n        if (!t) {\n          if (yD.AREAS) {\n            const e = new uP(hO.PROHIBITED_OPERATION, \"setArea is prohibited because of config-distribute\");\n            return i.onError(e), void iP.warning(\"setArea is prohibited because of config-distribute\");\n          }\n          if (Ln(n).call(n, dx.GLOBAL) && CD(\"AREAS\") === dx.EXTENSIONS) {\n            const e = new uP(hO.PROHIBITED_OPERATION, \"setArea is prohibited because of ap extensions\");\n            return i.onError(e), void iP.warning(\"setArea is prohibited because of ap extensions\");\n          }\n        }\n        RD(\"AREAS\", n, t);\n        const r = fB(n);\n        Object.keys(r).map(e => {\n          if (\"LOG_UPLOAD_SERVER\" === e || \"EVENT_REPORT_DOMAIN\" === e || \"EVENT_REPORT_BACKUP_DOMAIN\" === e || \"PROXY_SERVER_TYPE3\" === e) {\n            RD(e, r[e][0]);\n          } else RD(e, r[e]);\n        }), iP.debug(\"set area success:\", n.join(\",\"));\n      } catch (e) {\n        throw i.onError(e), e;\n      }\n      i.onSuccess();\n    }\n    function yB(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function IB(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? yB(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : yB(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    let AB = 1;\n    function bB(e, t, i, n, r) {\n      AB += 1;\n      const o = {\n          sid: i.sid,\n          command: \"convergeAllocateEdge\",\n          uid: \"666\",\n          appId: i.appId,\n          ts: Math.floor(Date.now() / 1e3),\n          seq: AB,\n          requestId: AB,\n          version: hD,\n          cname: i.cname\n        },\n        s = {\n          service_name: t,\n          json_body: JSON.stringify(o)\n        };\n      let a,\n        c,\n        d = e[0];\n      return UN(async () => {\n        a = Date.now();\n        const e = await _B(d, {\n          data: s,\n          cancelToken: n,\n          headers: {\n            \"X-Packet-Service-Type\": \"0\",\n            \"X-Packet-URI\": \"61\"\n          }\n        });\n        if (c = Date.now() - a, 0 !== e.code) {\n          const t = new uP(hO.UNEXPECTED_RESPONSE, \"live streaming ap error, code\" + e.code, {\n            retry: !0,\n            responseTime: c\n          });\n          throw iP.error(t.toString()), t;\n        }\n        const i = JSON.parse(e.json_body);\n        if (200 !== i.code) {\n          const e = new uP(hO.UNEXPECTED_RESPONSE, \"live streaming app center error, code: \".concat(i.code, \", reason: \").concat(i.reason), {\n            code: i.code,\n            responseTime: c\n          });\n          throw iP.error(e.toString()), e;\n        }\n        if (!i.servers || 0 === i.servers.length) {\n          const e = new uP(hO.UNEXPECTED_RESPONSE, \"live streaming app center empty server\", {\n            code: i.code,\n            responseTime: c\n          });\n          throw iP.error(e.toString()), e;\n        }\n        const r = function (e, t) {\n          return {\n            addressList: e.servers.map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(CD(\"WORKER_DOMAIN\"), \":\").concat(e.wss, \"?serviceName=\").concat(encodeURIComponent(t))),\n            workerToken: e.workerToken,\n            vid: e.vid\n          };\n        }(i, t);\n        return CD(\"LIVE_STREAMING_ADDRESS\") && (r.addressList = CD(\"LIVE_STREAMING_ADDRESS\") instanceof Array ? CD(\"LIVE_STREAMING_ADDRESS\") : [CD(\"LIVE_STREAMING_ADDRESS\")]), IB(IB({}, r), {}, {\n          responseTime: c\n        });\n      }, (n, r) => (lP.apworkerEvent(i.sid, {\n        success: !0,\n        sc: 200,\n        serviceName: t,\n        responseDetail: JSON.stringify(n.addressList),\n        firstSuccess: 0 === r,\n        responseTime: c,\n        serverIp: e[r % e.length]\n      }), !1), (n, r) => (lP.apworkerEvent(i.sid, {\n        success: !1,\n        sc: n.data && n.data.code || 200,\n        serviceName: t,\n        responseTime: c,\n        serverIp: e[r % e.length]\n      }), !!(n.code !== hO.OPERATION_ABORTED && n.code !== hO.UNEXPECTED_RESPONSE || n.data && n.data.retry) && (d = e[(r + 1) % e.length], !0)), r);\n    }\n    let wB = 1;\n    function OB(e, t, i, n) {\n      let {\n        url: r,\n        areaCode: o\n      } = e;\n      const {\n          clientId: s,\n          sid: a\n        } = t,\n        c = Date.now();\n      let d;\n      const l = t.role,\n        [u, h] = kB(t, o, [iF.CHOOSE_SERVER]);\n      let p = QO.networkState;\n      return UN(async () => {\n        p && QO.networkState === KO.OFFLINE && QO.onlineWaiter && (await rp.race([QO.onlineWaiter, fN(n && n.maxRetryTimeout || kN.maxRetryTimeout)])), p = QO.networkState;\n        const {\n          data: e,\n          headers: o\n        } = await _B(r, {\n          data: u,\n          cancelToken: i,\n          headers: {\n            \"Content-Type\": \"multipart/form-data;\"\n          }\n        }, !0, !0);\n        d = \"1\" === o.http3 ? 1 : -1, lP.reportResourceTiming(r, a), DB(e, r, t, c, [iF.CHOOSE_SERVER], d);\n        const s = hF(e, iF.CHOOSE_SERVER);\n        return PB(s), cF(s, r);\n      }, e => (e && lP.joinChooseServer(a, {\n        role: l,\n        lts: c,\n        succ: !0,\n        csAddr: r,\n        opid: h,\n        serverList: e.gatewayAddrs.map(e => e.address),\n        ec: null,\n        cid: e.cid.toString(),\n        uid: e.uid.toString(),\n        csIp: e.csIp,\n        unilbsServerIds: [iF.CHOOSE_SERVER].toString(),\n        isHttp3: d,\n        corssRegionTagReq: t.apRequestDetail,\n        corssRegionTagRes: e.res.detail && e.res.detail[38],\n        vid: e.vid\n      }), !1), e => e.code !== hO.OPERATION_ABORTED && (e.code === hO.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (lP.joinChooseServer(a, {\n        role: l,\n        lts: c,\n        succ: !1,\n        csAddr: r,\n        serverList: null,\n        opid: h,\n        ec: e.code,\n        csIp: e.data && e.data.csIp,\n        unilbsServerIds: [iF.CHOOSE_SERVER].toString(),\n        extend: JSON.stringify({\n          networkState: p\n        }),\n        isHttp3: d,\n        corssRegionTagReq: t.apRequestDetail\n      }), iP.warning(\"[\".concat(s || \"sid-\".concat(a.slice(0, 6)), \"] Choose server network error, retry\"), e), !0)), n);\n    }\n    function NB(e, t, i, n) {\n      let r,\n        {\n          url: o,\n          areaCode: s,\n          serviceIds: a\n        } = e;\n      const c = Date.now(),\n        d = t.role,\n        [l, u] = kB(t, s, a);\n      let h;\n      return UN(async () => {\n        h && QO.networkState === KO.OFFLINE && QO.onlineWaiter && (await rp.race([QO.onlineWaiter, fN(n && n.maxRetryTimeout || kN.maxRetryTimeout)])), h = QO.networkState;\n        const {\n          data: e,\n          headers: s\n        } = await _B(o, {\n          data: l,\n          cancelToken: i,\n          headers: {\n            \"Content-Type\": \"multipart/form-data;\"\n          }\n        }, !0, !0);\n        r = \"1\" === s.http3 ? 1 : -1, lP.reportResourceTiming(o, t.sid), DB(e, o, t, c, a, r);\n        const d = hF(e, iF.CHOOSE_SERVER),\n          u = hF(e, \"proxy5\" === t.cloudProxyServer ? iF.CLOUD_PROXY_5 : \"proxy3\" === t.cloudProxyServer || \"proxy4\" === t.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK),\n          p = performance.getEntriesByName(o),\n          _ = p[p.length - 1];\n        let E;\n        return _ && (E = {\n          name: _.name,\n          protocol: \"nextHopProtocol\" in _ ? _.nextHopProtocol : \"\",\n          dnscost: \"domainLookupEnd\" in _ && \"domainLookupStart\" in _ && \"number\" == typeof _.domainLookupEnd && \"number\" == typeof _.domainLookupStart ? _.domainLookupEnd - _.domainLookupStart : -1,\n          tcpTlsCost: \"connectEnd\" in _ && \"connectStart\" in _ && \"number\" == typeof _.connectEnd && \"number\" == typeof _.connectStart ? _.connectEnd - _.connectStart : -1,\n          reqCost: \"requestStart\" in _ && \"number\" == typeof _.requestStart && \"responseEnd\" in _ && \"number\" == typeof _.responseEnd ? _.responseEnd - _.requestStart : -1,\n          handleCost: \"leave_ts\" in e && \"enter_ts\" in e && \"number\" == typeof e.leave_ts && \"number\" == typeof e.enter_ts ? e.leave_ts - e.enter_ts : -1\n        }), PB(d), {\n          gatewayInfo: cF(d, o),\n          proxyInfo: u,\n          url: o,\n          resourceTimingInfo: E\n        };\n      }, e => {\n        var i;\n        return e.gatewayInfo && lP.joinChooseServer(t.sid, {\n          role: d,\n          lts: c,\n          succ: !0,\n          csAddr: o,\n          serverList: e.gatewayInfo.gatewayAddrs.map(e => e.address),\n          ec: null,\n          opid: u,\n          cid: e.gatewayInfo.cid.toString(),\n          uid: e.gatewayInfo.uid.toString(),\n          csIp: e.gatewayInfo.csIp,\n          unilbsServerIds: a.toString(),\n          isHttp3: r,\n          corssRegionTagReq: t.apRequestDetail,\n          corssRegionTagRes: e.gatewayInfo.res.detail && e.gatewayInfo.res.detail[38],\n          vid: null === (i = e.gatewayInfo) || void 0 === i ? void 0 : i.vid,\n          resourceTimingInfo: e.resourceTimingInfo ? JSON.stringify(e.resourceTimingInfo) : void 0\n        }), e.proxyInfo && lP.joinWebProxyAP(t.sid, {\n          lts: c,\n          sucess: 1,\n          apServerAddr: o,\n          turnServerAddrList: e.proxyInfo.addresses.map(e => e.ip).join(\",\"),\n          errorCode: null,\n          eventType: t.cloudProxyServer,\n          unilbsServerIds: a.toString()\n        }), !1;\n      }, e => e.code !== hO.OPERATION_ABORTED && (e.code === hO.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (lP.joinWebProxyAP(t.sid, {\n        lts: c,\n        sucess: 0,\n        apServerAddr: o,\n        turnServerAddrList: null,\n        errorCode: e.code,\n        eventType: t.cloudProxyServer,\n        unilbsServerIds: a.toString(),\n        extend: JSON.stringify({\n          networkState: h\n        })\n      }), iP.warning(\"[\".concat(t.clientId, \"] multi unilbs network error, retry\"), e), !0)), n);\n    }\n    const DB = (e, t, i, n, r, o) => {\n        const {\n            sid: s,\n            clientId: a,\n            cloudProxyServer: c\n          } = i,\n          d = [],\n          l = a => {\n            4096 === a.flag ? lP.joinChooseServer(s, {\n              role: i.role,\n              lts: n,\n              succ: !1,\n              csAddr: t,\n              opid: e.opid,\n              serverList: null,\n              ec: a.error.message,\n              csIp: a.error.data && a.error.data.csIp,\n              unilbsServerIds: r.toString(),\n              isHttp3: o,\n              corssRegionTagReq: i.apRequestDetail\n            }) : 1048576 !== a.flag && 4194304 !== a.flag && 4194310 !== a.flag || lP.joinWebProxyAP(s, {\n              lts: n,\n              sucess: 0,\n              apServerAddr: t,\n              turnServerAddrList: null,\n              errorCode: a.error.code,\n              eventType: c,\n              unilbsServerIds: r.toString()\n            });\n          };\n        if (e.response_body.forEach(t => {\n          const i = t.buffer.code;\n          if (23 === t.uri && 0 === i && !t.buffer.edges_services) if (4194310 === t.buffer.flag) iP.warning(\"no edge services in ap response of proxy fallback, will not set proxy in iceServers\"), t.buffer.edges_services = [];else {\n            const i = {\n              error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, \"no edge services in ap response\", {\n                retry: CD(\"NO_EDGES_RETRY\"),\n                csIp: e.detail[502]\n              }),\n              flag: t.buffer.flag\n            };\n            d.push(i), l(i);\n          }\n          if (0 !== i) {\n            const n = xx(i),\n              r = {\n                error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, n.desc, {\n                  desc: n.desc,\n                  retry: n.retry,\n                  csIp: e.detail[502]\n                }),\n                flag: t.buffer.flag\n              };\n            4194310 === t.buffer.flag ? iP.warning(r.error.toString()) : d.push(r), l(r);\n          }\n        }), d.length) throw iP.warning(\"[\".concat(a || \"sid-\".concat(s.slice(0, 6)), \"] multi unilbs \").concat(t, \" failed, \").concat(d.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message, \", retry: \").concat(e.error.data.retry)).join(\" | \"))), new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, d.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message)).join(\" | \"), {\n          retry: !!d.find(e => e.error.data.retry),\n          csIp: e.detail[502],\n          desc: [...new Set(d.map(e => {\n            var t;\n            return null == e || null === (t = e.error) || void 0 === t || null === (t = t.data) || void 0 === t ? void 0 : t.desc;\n          }).filter(e => !!e))]\n        });\n      },\n      PB = e => {\n        var t, i, n, r;\n        if (e.addresses && 0 === e.addresses.length && 0 === e.code) throw new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, \"void gateway address\", {\n          retry: !0,\n          csIp: e.detail && e.detail[502]\n        });\n        CD(\"AP_AREA\") && (null !== (n = e.detail) && void 0 !== n && n[23] && \"string\" == typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[23]) ? CB(e.detail[23].toLowerCase()) : CB());\n        if (null !== (t = e.detail) && void 0 !== t && t[19] && \"string\" == typeof (null === (i = e.detail) || void 0 === i ? void 0 : i[19])) {\n          const t = e.detail[19],\n            i = null == t ? void 0 : t.split(\";\");\n          for (let t = 0; t < i.length; t++) {\n            var o;\n            const n = kg(o = i[t]).call(o);\n            e.addresses[t] && i && (e.addresses[t].fingerprint = n);\n          }\n        }\n        if (CD(\"GATEWAY_ADDRESS\") && CD(\"GATEWAY_ADDRESS\").length > 0) {\n          iP.debug(\"assign gateway address to\", CD(\"GATEWAY_ADDRESS\"));\n          const t = CD(\"GATEWAY_ADDRESS\").map(t => {\n            var i, n;\n            const r = null !== (i = null === (n = e.addresses.find(e => e.ip === t.ip && e.port === t.port)) || void 0 === n ? void 0 : n.fingerprint) && void 0 !== i ? i : \"\";\n            return {\n              ip: t.ip,\n              port: t.port,\n              ticket: e.addresses[0] && e.addresses[0].ticket,\n              fingerprint: t.fingerprint || r\n            };\n          });\n          e.addresses = t;\n        }\n      },\n      LB = (e, t) => {\n        if (e.response_body && e.response_body.length) {\n          const t = e.response_body[0];\n          if (0 !== t.buffer.code) {\n            const e = xx(t.buffer.code);\n            throw new uP(hO.UPDATE_TICKET_FAILED, \"[\".concat(t.buffer.code, \"]: \").concat(e.desc), {\n              retry: e.retry\n            });\n          }\n          return t.buffer.ticket;\n        }\n        throw iP.debug(\"update ticket request received ap response without response body:\", t), new uP(hO.UPDATE_TICKET_FAILED, \"cannot find response body from ap response\", {\n          retry: !1\n        });\n      },\n      kB = (e, t, i) => {\n        const n = Math.floor(Math.random() * 10 ** 12),\n          r = \"host\" === e.role ? \"1\" : \"audience\" === e.role ? \"2\" : void 0,\n          o = {\n            appid: e.appId,\n            client_ts: Date.now(),\n            opid: n,\n            sid: e.sid,\n            request_bodies: [{\n              uri: 22,\n              buffer: {\n                cname: e.cname,\n                detail: IB(IB(IB({\n                  6: e.stringUid,\n                  11: t,\n                  12: CD(\"USE_NEW_TOKEN\") ? \"1\" : void 0\n                }, r ? {\n                  17: r\n                } : {}), {}, {\n                  22: t\n                }, e.apRequestDetail ? {\n                  33: e.apRequestDetail\n                } : {}), e.apRTM ? {\n                  26: \"RTM2\"\n                } : {}),\n                key: e.token,\n                service_ids: i,\n                uid: e.uid || 0\n              }\n            }]\n          };\n        o.request_bodies.forEach(t => {\n          e.multiIP && e.multiIP.gateway_ip && (t.buffer.detail[5] = JSON.stringify({\n            vocs_ip: [e.multiIP.uni_lbs_ip],\n            vos_ip: [e.multiIP.gateway_ip]\n          }));\n        });\n        const s = new FormData();\n        return s.append(\"request\", JSON.stringify(o)), [s, n];\n      },\n      MB = (e, t) => {\n        const i = Math.floor(Math.random() * 10 ** 12),\n          n = {\n            appid: e.appId,\n            client_ts: Date.now(),\n            opid: i,\n            sid: e.sid,\n            request_bodies: [{\n              uri: 28,\n              buffer: {\n                cname: e.cname,\n                detail: {\n                  1: \"\",\n                  6: e.stringUid,\n                  12: \"1\"\n                },\n                token: e.token,\n                service_ids: t,\n                uid: e.uid || 0,\n                edges_services: e.apResponse.addresses.map(e => ({\n                  ip: e.ip,\n                  port: e.port\n                }))\n              }\n            }]\n          },\n          r = new FormData();\n        return r.append(\"request\", JSON.stringify(n)), [r, i];\n      };\n    let UB = 0;\n    function VB(e) {\n      return rp.all(e.map(e => e.then(e => {\n        throw e;\n      }, e => e))).then(e => {\n        throw e;\n      }, e => e);\n    }\n    const xB = async e => {\n        let {\n            fragementLength: t,\n            referenceList: i,\n            asyncMapHandler: n,\n            allFailedhandler: r,\n            promisesCollector: o\n          } = e,\n          s = 0;\n        const a = t;\n        let c,\n          d = 0;\n        const l = async () => {\n          const e = (() => {\n            const e = s * a,\n              t = e + a;\n            return i.slice(e, t).map(n);\n          })();\n          o && o.push(...e);\n          try {\n            c = await VB(e);\n          } catch (e) {\n            if (d += a, s++, !(d >= i.length)) return void (await l());\n            r(e);\n          }\n          e.forEach(e => e.cancel());\n        };\n        return await l(), c;\n      },\n      FB = async e => {\n        let {\n          referenceList: t,\n          asyncMapHandler: i,\n          closeFn: n\n        } = e;\n        const r = t.length;\n        let o = 0;\n        const s = async () => {\n          const e = i(t.shift());\n          try {\n            return await e;\n          } catch (e) {\n            if (o++, o >= r || null != n && n(e)) throw e;\n            return s();\n          }\n        };\n        return s();\n      };\n    async function BB() {\n      if (\"undefined\" == typeof VideoDecoder) return !0;\n      let e;\n      const t = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 85, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 149, 160, 133, 4, 144, 43, 122, 168, 159, 120, 159, 205, 39, 82, 131, 57, 52, 87, 187, 68, 23, 248, 134, 204, 226, 97, 17, 49, 183, 55, 236, 219, 249, 221, 98, 208, 215, 190, 59, 179, 167, 213, 47, 1, 246, 150, 14, 194, 245, 159, 83, 35, 64, 103, 218, 38, 21, 82, 3, 135, 21, 185, 84, 248, 134],\n        i = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 148, 62, 134, 140, 92, 172, 141, 77, 35, 94, 181, 164, 65, 169, 65, 156, 154, 43, 221, 162, 11, 252, 67, 102, 113, 48, 136, 137, 219, 62, 43, 113, 239, 23, 126, 250, 186, 252, 10, 138, 218, 25, 193, 244, 74, 68, 194, 209, 107, 23, 52, 206, 199, 78, 72, 98, 103, 151, 71, 96, 62, 51, 210, 158, 72, 231, 158],\n        n = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 143, 233, 163, 51, 196, 98, 95, 151, 224, 22, 134, 33, 240, 150, 248, 67, 18, 34, 196, 142, 81, 238, 173, 140, 80, 205, 232, 132, 144, 67, 12, 131, 157, 4, 171, 243, 86, 122, 35, 6, 166, 184, 243, 85, 126, 13, 206, 103, 152, 62, 168, 160, 187, 2, 241, 138, 52, 211, 72, 121, 128, 151, 63, 147, 128, 19, 42],\n        r = [18, 0, 50, 138, 1, 48, 192, 64, 253, 248, 65, 17, 67, 192, 32, 0, 16, 0, 0, 0, 0, 0, 0, 0, 195, 12, 48, 144, 64, 32, 0, 209, 75, 61, 9, 204, 25, 115, 79, 226, 115, 63, 63, 208, 70, 210, 220, 153, 126, 241, 237, 37, 107, 195, 153, 1, 99, 112, 230, 189, 209, 169, 130, 10, 11, 22, 167, 215, 159, 205, 197, 7, 183, 162, 26, 48, 254, 141, 134, 103, 32, 16, 235, 45, 1, 15, 18, 119, 169, 110, 206, 251, 51, 115, 202, 60, 148, 1, 46, 39, 109, 25, 28, 86, 168, 15, 77, 211, 239, 2, 58, 43, 146, 26, 230, 184, 81, 48, 140, 226, 226, 250, 222, 146, 171, 133, 164, 13, 188, 180, 64, 122, 142, 146, 32, 208, 238, 170, 193, 35, 53, 44, 225],\n        o = [18, 0, 50, 107, 48, 0, 133, 125, 248, 65, 26, 195, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 204, 24, 122, 65, 56, 165, 18, 52, 206, 218, 4, 187, 51, 97, 9, 29, 191, 90, 253, 106, 185, 31, 197, 155, 52, 205, 245, 185, 203, 131, 20, 226, 25, 124, 95, 113, 220, 113, 141, 15, 15, 104, 211, 144, 152, 237, 150, 157, 127, 51, 143, 24, 231, 218, 171, 255, 176, 241, 128, 229, 149, 150, 148, 66, 245, 228, 91, 27, 182, 228, 136, 61, 182, 237, 133, 45, 220, 24, 103, 214, 152],\n        s = [18, 0, 50, 122, 48, 1, 9, 253, 248, 65, 26, 67, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 198, 182, 231, 242, 220, 235, 163, 140, 12, 36, 36, 166, 46, 132, 210, 4, 71, 23, 218, 132, 27, 30, 17, 45, 244, 79, 31, 243, 195, 136, 100, 169, 76, 88, 142, 85, 204, 217, 121, 168, 29, 163, 198, 17, 251, 223, 73, 12, 212, 244, 139, 123, 151, 179, 75, 216, 96, 208, 136, 40, 229, 42, 59, 149, 10, 116, 228, 85, 99, 93, 221, 108, 255, 140, 248, 20, 30, 167, 122, 109, 206, 164, 108, 197, 110, 251, 23, 243, 133, 160, 63, 13, 207, 177, 12, 128],\n        a = await new rp((a, c) => {\n          let d;\n          !async function () {\n            e && \"closed\" !== e.state || (await async function () {\n              e = new VideoDecoder({\n                output: e => {\n                  e.close(), clearTimeout(d), a(!0);\n                },\n                error: e => {\n                  clearTimeout(d), a(!1);\n                }\n              }), await e.configure({\n                codec: \"av01.0.05M.08\",\n                width: 160,\n                height: 90\n              });\n            }());\n            const c = [t, i, n, r, o, s];\n            for (let t = 0; t < c.length; t++) {\n              const i = new EncodedVideoChunk({\n                type: 0 == t ? \"key\" : \"delta\",\n                timestamp: 33333 * t,\n                duration: 33333,\n                data: new Uint8Array(c[t])\n              });\n              try {\n                await e.decode(i);\n              } catch (e) {\n                return void a(!1);\n              }\n            }\n          }(), d = setTimeout(() => {\n            a(!1);\n          }, 5e3);\n        });\n      return a;\n    }\n    async function jB(e, t, i, n) {\n      const r = async function (e, t, i, n) {\n        let r = null;\n        const o = [],\n          s = async () => {\n            const r = CD(\"WEBCS_DOMAIN\").slice(0, CD(\"AJAX_REQUEST_CONCURRENT\")).map(t => ({\n                url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n                areaCode: EB()\n              })),\n              s = n.recordJoinChannelService({\n                startTs: Date.now(),\n                status: \"pending\",\n                service: \"chooseServer\",\n                urls: r.map(e => e.url)\n              }),\n              a = await xB({\n                fragementLength: CD(\"FRAGEMENT_LENGTH\"),\n                referenceList: r,\n                asyncMapHandler: n => (iP.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), n.url), OB(n, e, t, i)),\n                allFailedhandler: e => {\n                  throw n.recordJoinChannelService({\n                    endTs: Date.now(),\n                    status: \"error\",\n                    errors: e\n                  }, s), e[0];\n                },\n                promisesCollector: o\n              });\n            return n.recordJoinChannelService({\n              endTs: Date.now(),\n              status: \"success\"\n            }, s), a;\n          },\n          a = async () => {\n            if (await fN(1e3), null !== r) return r;\n            const s = CD(\"WEBCS_DOMAIN_BACKUP_LIST\").map(t => ({\n                url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n                areaCode: EB()\n              })),\n              a = n.recordJoinChannelService({\n                endTs: void 0,\n                startTs: Date.now(),\n                status: \"pending\",\n                service: \"chooseServer\",\n                urls: s.map(e => e.url)\n              }),\n              c = await xB({\n                fragementLength: CD(\"FRAGEMENT_LENGTH\"),\n                referenceList: s,\n                asyncMapHandler: n => (iP.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), n.url), OB(n, e, t, i)),\n                allFailedhandler: e => {\n                  throw n.recordJoinChannelService({\n                    endTs: Date.now(),\n                    status: \"error\",\n                    errors: e\n                  }, a), e[0];\n                },\n                promisesCollector: o\n              });\n            return n.recordJoinChannelService({\n              endTs: Date.now(),\n              status: \"success\"\n            }, a), c;\n          };\n        try {\n          return r = await VB([s(), a()]), o.length && o.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), r;\n        } catch (e) {\n          throw e[0];\n        }\n      }(e, t, i, n);\n      return {\n        gatewayInfo: await r\n      };\n    }\n    async function GB(e, t, i, n, r) {\n      const o = e.cloudProxyServer;\n      if (\"disabled\" === o) {\n        if (!n) return;\n        if (e.useLocalAccessPoint) return await jB(e, t, i, r);\n        if (CD(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\")) {\n          const {\n            gatewayInfo: n,\n            proxyInfo: o\n          } = await zB(e, t, i, r);\n          if (e.turnServer && \"auto\" !== e.turnServer.mode) return {\n            gatewayInfo: n\n          };\n          const a = o.map(e => ({\n            turnServerURL: e.address,\n            tcpport: e.tcpport || ED.tcpport,\n            udpport: e.udpport || ED.udpport,\n            username: e.username || ED.username,\n            password: e.password || ED.password,\n            forceturn: !1,\n            security: !0\n          }));\n          if (r.useP2P) {\n            var s;\n            const t = null !== (s = e.uid) && void 0 !== s ? s : n.uid,\n              i = \"glb:\".concat(t.toString()),\n              r = await OO(i),\n              c = o.map(e => ({\n                turnServerURL: e.address,\n                tcpport: e.tcpport || ED.tcpport,\n                udpport: e.udpport || ED.udpport,\n                username: i,\n                password: r,\n                forceturn: !1,\n                security: !0\n              }));\n            a.push(...c);\n          }\n          return e.turnServer = {\n            mode: \"manual\",\n            servers: a\n          }, {\n            gatewayInfo: n\n          };\n        }\n        return await jB(e, t, i, r);\n      }\n      const {\n          proxyInfo: a,\n          gatewayInfo: c\n        } = await zB(e, t, i, r),\n        d = {\n          gatewayInfo: c\n        },\n        l = a.map(e => ({\n          turnServerURL: e.address,\n          tcpport: \"proxy3\" === o ? void 0 : e.tcpport ? e.tcpport : ED.tcpport,\n          udpport: \"proxy4\" === o ? void 0 : e.udpport ? e.udpport : ED.udpport,\n          username: e.username || ED.username,\n          password: e.password || ED.password,\n          forceturn: \"proxy4\" !== o,\n          security: \"proxy5\" === o\n        }));\n      if (r.useP2P) {\n        var u;\n        const t = null !== (u = e.uid) && void 0 !== u ? u : c.uid,\n          i = \"glb:\".concat(t.toString()),\n          n = await OO(i),\n          r = a.map(e => ({\n            turnServerURL: e.address,\n            tcpport: \"proxy3\" === o ? void 0 : e.tcpport || ED.tcpport,\n            udpport: \"proxy4\" === o ? void 0 : e.udpport || ED.udpport,\n            username: i,\n            password: n,\n            forceturn: \"proxy4\" !== o,\n            security: \"proxy5\" === o\n          }));\n        l.push(...r);\n      }\n      return e.turnServer = {\n        mode: \"manual\",\n        servers: l\n      }, iP.debug(\"[\".concat(e.clientId, \"] set proxy server: \").concat(e.proxyServer, \", mode: \").concat(o)), d;\n    }\n    async function WB(e, t, i, n, r) {\n      const o = CD(\"ACCOUNT_REGISTER\").slice(0, CD(\"AJAX_REQUEST_CONCURRENT\"));\n      let s = [];\n      s = t.proxyServer ? o.map(e => \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1\")) : o.map(e => \"https://\".concat(e, \"/api/v1\"));\n      const a = null == r ? void 0 : r.recordJoinChannelService({\n        startTs: Date.now(),\n        status: \"pending\",\n        service: \"stringUID\",\n        urls: s\n      });\n      try {\n        const o = await async function (e, t, i, n, r) {\n          const o = Date.now(),\n            s = {\n              sid: i.sid,\n              opid: 10,\n              appid: i.appId,\n              string_uid: t\n            };\n          let a = e[0];\n          const c = await UN(() => _B(a + \"\".concat(-1 === a.indexOf(\"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n            data: s,\n            cancelToken: n,\n            headers: {\n              \"X-Packet-Service-Type\": 0,\n              \"X-Packet-URI\": 72\n            }\n          }), (i, n) => {\n            if (0 === i.code) {\n              if (i.uid <= 0 || i.uid >= Math.pow(2, 32)) throw iP.error(\"Invalid Uint Uid \".concat(t, \" => \").concat(i.uid), i), lP.reqUserAccount(s.sid, {\n                lts: o,\n                success: !1,\n                serverAddr: a,\n                stringUid: s.string_uid,\n                uid: i.uid,\n                errorCode: hO.INVALID_UINT_UID_FROM_STRING_UID,\n                extend: s\n              }), new uP(hO.INVALID_UINT_UID_FROM_STRING_UID);\n              return lP.reqUserAccount(s.sid, {\n                lts: o,\n                success: !0,\n                serverAddr: a,\n                stringUid: s.string_uid,\n                uid: i.uid,\n                errorCode: null,\n                extend: s\n              }), !1;\n            }\n            const r = xx(i.code);\n            return r.retry && (a = e[(n + 1) % e.length]), lP.reqUserAccount(s.sid, {\n              lts: o,\n              success: !1,\n              serverAddr: a,\n              stringUid: s.string_uid,\n              uid: i.uid,\n              errorCode: r.desc,\n              extend: s\n            }), r.retry;\n          }, (t, i) => t.code !== hO.OPERATION_ABORTED && (lP.reqUserAccount(s.sid, {\n            lts: o,\n            success: !1,\n            serverAddr: a,\n            stringUid: s.string_uid,\n            uid: null,\n            errorCode: t.code,\n            extend: s\n          }), a = e[(i + 1) % e.length], !0), r);\n          if (0 !== c.code) {\n            const e = xx(c.code);\n            throw new uP(hO.UNEXPECTED_RESPONSE, e.desc);\n          }\n          return c;\n        }(s, e, t, i, n);\n        return null == r || r.recordJoinChannelService({\n          status: \"success\",\n          endTs: Date.now()\n        }, a), o.uid;\n      } catch (e) {\n        throw null == r || r.recordJoinChannelService({\n          status: \"error\",\n          endTs: Date.now(),\n          errors: [e]\n        }, a), e;\n      }\n    }\n    async function HB(e, t, i) {\n      const n = CD(\"ACCOUNT_REGISTER\");\n      let r = [];\n      r = t.proxyServer ? n.map(e => \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1\")) : n.map(e => \"https://\".concat(e, \"/api/v1\"));\n      try {\n        const n = await FB({\n          referenceList: r,\n          asyncMapHandler: n => async function (e, t, i, n) {\n            const r = Date.now(),\n              o = {\n                sid: i.sid,\n                opid: 10,\n                appid: i.appId,\n                string_uid: t\n              };\n            try {\n              const t = await _B(e + \"\".concat(-1 === e.indexOf(\"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n                data: o,\n                cancelToken: n,\n                headers: {\n                  \"X-Packet-Service-Type\": 0,\n                  \"X-Packet-URI\": 72\n                }\n              });\n              if (0 !== t.code) {\n                const e = xx(t.code);\n                throw new uP(hO.UNEXPECTED_RESPONSE, \"preload sua error:\".concat(e.desc), e);\n              }\n              if (t.uid <= 0 || t.uid >= Math.pow(2, 32)) throw new uP(hO.INVALID_UINT_UID_FROM_STRING_UID);\n              return {\n                requestTime: r,\n                url: e,\n                req: o,\n                uid: t.uid,\n                elapse: Date.now() - r\n              };\n            } catch (e) {\n              throw e;\n            }\n          }(n, e, t, i),\n          closeFn: e => e.code === hO.OPERATION_ABORTED || e.code === hO.UNEXPECTED_RESPONSE && !e.data.retry\n        });\n        return n;\n      } catch (e) {\n        throw e;\n      }\n    }\n    async function KB(e, t, i) {\n      const n = CD(\"CDS_AP\").slice(0, CD(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1\") : \"https://\".concat(t, \"/api/v1?action=config\")),\n        r = n.map(n => function (e, t, i, n) {\n          const r = Dw(),\n            o = {\n              flag: 64,\n              cipher_method: 0,\n              features: IB(IB(IB(IB(IB({\n                install_id: uD(),\n                device: r.name,\n                system: r.os,\n                system_general: navigator.userAgent,\n                vendor: t.appId,\n                version: hD,\n                cname: t.cname,\n                session_id: t.sid,\n                proxyServer: t.proxyServer,\n                sdk_type: tF.WEB_RTC,\n                browser_name: r.name,\n                browser_version: r.version,\n                user_agent: navigator.userAgent,\n                channel_name: t.cname\n              }, t.stringUid && {\n                string_uid: t.stringUid\n              }), t.uid && {\n                uid: t.uid + \"\"\n              }), r.os && {\n                os_name: r.os\n              }), r.osVersion && {\n                os_version: r.osVersion\n              }), {}, {\n                detail: \"\"\n              })\n            };\n          return UN(() => _B(e, {\n            data: o,\n            timeout: 1e3,\n            cancelToken: i,\n            headers: {\n              \"X-Packet-Service-Type\": 0,\n              \"X-Packet-URI\": 54\n            }\n          }), void 0, e => e.code !== hO.OPERATION_ABORTED, n);\n        }(n, e, t, i));\n      let o = null,\n        s = null,\n        a = {};\n      try {\n        o = await VB(r);\n      } catch (e) {\n        if (e.code === hO.OPERATION_ABORTED) throw e;\n        s = e;\n      }\n      r.forEach(e => e.cancel());\n      if (lP.reportApiInvoke(e.sid, {\n        name: LO.REQUEST_CONFIG_DISTRIBUTE,\n        options: {\n          error: s,\n          res: o\n        }\n      }).onSuccess(), o && o.test_tags) try {\n        a = function (e) {\n          if (!e.test_tags) return {};\n          const t = e.test_tags,\n            i = Object.keys(t),\n            n = {};\n          return i.forEach(e => {\n            var i;\n            const r = kg(i = e.slice(4)).call(i),\n              o = JSON.parse(t[e]),\n              s = o[1];\n            n[r] = {\n              tag: o[0] || \"\",\n              value: s\n            };\n          }), n;\n        }(o);\n      } catch (e) {}\n      return a;\n    }\n    async function YB(e, t) {\n      const i = CD(\"WEBCS_DOMAIN\").concat(CD(\"WEBCS_DOMAIN_BACKUP_LIST\")).map(e => ({\n        url: \"https://\".concat(e, \"/api/v2/transpond/webrtc?v=2\"),\n        areaCode: EB(),\n        serviceIds: [iF.CHOOSE_SERVER, iF.CLOUD_PROXY_FALLBACK]\n      }));\n      try {\n        const n = await FB({\n          referenceList: i,\n          asyncMapHandler: i => async function (e, t, i) {\n            let n,\n              {\n                url: r,\n                areaCode: o,\n                serviceIds: s\n              } = e;\n            const a = Date.now(),\n              [c, d] = kB(t, o, s);\n            let l = QO.networkState;\n            try {\n              l && QO.networkState === KO.OFFLINE && QO.onlineWaiter && (await rp.race([QO.onlineWaiter, fN(kN.maxRetryTimeout)])), l = QO.networkState;\n              const {\n                data: e,\n                headers: t\n              } = await _B(r, {\n                data: c,\n                cancelToken: i,\n                headers: {\n                  \"Content-Type\": \"multipart/form-data;\"\n                }\n              }, !0, !0);\n              n = \"1\" === t.http3 ? 1 : -1;\n              const o = e => {\n                const t = [];\n                if (e.response_body.forEach(i => {\n                  const n = i.buffer.code;\n                  if (23 === i.uri && 0 === n && !i.buffer.edges_services) if (4194310 === i.buffer.flag) i.buffer.edges_services = [];else {\n                    const n = {\n                      error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, \"no edge services in ap response\", {\n                        retry: CD(\"NO_EDGES_RETRY\"),\n                        csIp: e.detail[502]\n                      }),\n                      flag: i.buffer.flag\n                    };\n                    t.push(n);\n                  }\n                  if (0 !== n) {\n                    const r = xx(n),\n                      o = {\n                        error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, r.desc, {\n                          desc: r.desc,\n                          retry: r.retry,\n                          csIp: e.detail[502]\n                        }),\n                        flag: i.buffer.flag\n                      };\n                    4194310 === i.buffer.flag ? iP.warning(o.error.toString()) : t.push(o);\n                  }\n                }), t.length) throw new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, t.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message)).join(\" | \"), {\n                  retry: !!t.find(e => e.error.data.retry),\n                  csIp: e.detail[502],\n                  desc: [...new Set(t.map(e => {\n                    var t;\n                    return null == e || null === (t = e.error) || void 0 === t || null === (t = t.data) || void 0 === t ? void 0 : t.desc;\n                  }).filter(e => !!e))]\n                });\n              };\n              o(e);\n              const s = hF(e, iF.CHOOSE_SERVER),\n                u = hF(e, iF.CLOUD_PROXY_FALLBACK);\n              return PB(s), {\n                gatewayInfo: cF(s, r),\n                proxyInfo: u,\n                opid: d,\n                requestTime: a,\n                url: r,\n                isHttp3: n,\n                elapse: Date.now() - a\n              };\n            } catch (e) {\n              throw e;\n            }\n          }(i, e, t),\n          closeFn: e => e.code === hO.OPERATION_ABORTED || e.code === hO.CAN_NOT_GET_GATEWAY_SERVER && !e.data.retry\n        });\n        return n;\n      } catch (e) {\n        throw e;\n      }\n    }\n    async function zB(e, t, i, n) {\n      const r = CD(\"PROXY_SERVER_TYPE3\"),\n        o = (e, t, i) => {\n          let n = i || r;\n          return Array.isArray(n) && (n = t % 2 == 0 && r[1] || r[0]), \"https://\".concat(n, \"/ap/?url=\").concat(e);\n        };\n      let s = null;\n      const a = [],\n        c = async () => {\n          const r = CD(\"WEBCS_DOMAIN\").slice(0, CD(\"AJAX_REQUEST_CONCURRENT\")).map((t, i) => {\n              let n;\n              return n = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n                url: n,\n                areaCode: EB(),\n                serviceIds: [iF.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? iF.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK]\n              };\n            }),\n            s = n.recordJoinChannelService({\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: r.map(e => e.url)\n            }),\n            c = await xB({\n              fragementLength: CD(\"FRAGEMENT_LENGTH\"),\n              referenceList: r,\n              asyncMapHandler: n => (iP.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), n.url), NB(n, e, t, i)),\n              allFailedhandler: e => {\n                throw n.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, s), e[0];\n              },\n              promisesCollector: a\n            });\n          return n.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, s), c;\n        },\n        d = async () => {\n          if (await fN(1e3), null !== s) return s;\n          const r = CD(\"WEBCS_DOMAIN_BACKUP_LIST\").map((t, i) => {\n              let n;\n              return n = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n                url: n,\n                areaCode: EB(),\n                serviceIds: [iF.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? iF.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK]\n              };\n            }),\n            c = n.recordJoinChannelService({\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: r.map(e => e.url)\n            }),\n            d = await xB({\n              fragementLength: CD(\"FRAGEMENT_LENGTH\"),\n              referenceList: r,\n              asyncMapHandler: n => (iP.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), n.url), NB(n, e, t, i)),\n              allFailedhandler: e => {\n                throw n.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, c), e[0];\n              },\n              promisesCollector: a\n            });\n          return n.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, c), d;\n        };\n      let l, u, h;\n      try {\n        ({\n          gatewayInfo: l,\n          proxyInfo: u,\n          url: h\n        } = await VB([c(), d()]));\n      } catch (e) {\n        throw e[0];\n      }\n      if (a.length && a.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), !l || !u) throw new uP(hO.UNEXPECTED_ERROR, \"missing gateway or proxy response\").print();\n      if (e.apUrl = h, \"disabled\" !== e.cloudProxyServer && Array.isArray(r) && h) {\n        const t = /^https?:\\/\\/(.+?)(\\/.*)?$/.exec(h)[1];\n        Ln(r).call(r, t) && (e.proxyServer = t, iP.setProxyServer(t), lP.setProxyServer(t));\n      }\n      return s = {\n        gatewayInfo: l,\n        proxyInfo: await pF(u, l.uid)\n      }, s;\n    }\n    async function qB(e, t, i) {\n      const n = CD(\"UAP_AP\").slice(0, CD(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1?action=uap\") : \"https://\".concat(t, \"/api/v1?action=uap\")),\n        r = n.map(n => function (e, t, i, n) {\n          const r = {\n            command: \"convergeAllocateEdge\",\n            sid: t.sid,\n            appId: t.appId,\n            token: t.token,\n            ts: Date.now(),\n            version: hD,\n            cname: t.cname,\n            uid: t.uid.toString(),\n            requestId: wB,\n            seq: wB\n          };\n          wB += 1;\n          const o = {\n            service_name: \"tele_channel\",\n            json_body: JSON.stringify(r)\n          };\n          return UN(async () => {\n            const t = await _B(e, {\n              data: o,\n              cancelToken: i,\n              headers: {\n                \"X-Packet-Service-Type\": 0,\n                \"X-Packet-URI\": 61\n              }\n            });\n            if (0 !== t.code) {\n              const e = new uP(hO.UNEXPECTED_RESPONSE, \"cross channel ap error, code\" + t.code, {\n                retry: !0\n              });\n              throw iP.error(e.toString()), e;\n            }\n            const n = JSON.parse(t.json_body);\n            if (200 !== n.code) {\n              const e = new uP(hO.UNEXPECTED_RESPONSE, \"cross channel app center error, code: \".concat(n.code, \", reason: \").concat(n.reason));\n              throw iP.error(e.toString()), e;\n            }\n            if (!n.servers || 0 === n.servers.length) {\n              const e = new uP(hO.UNEXPECTED_RESPONSE, \"cross channel app center empty server\");\n              throw iP.error(e.toString()), e;\n            }\n            return {\n              vid: n.vid,\n              workerToken: n.workerToken,\n              addressList: (CD(\"CHANNEL_MEDIA_RELAY_SERVERS\") || n.servers).map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(CD(\"WORKER_DOMAIN\"), \":\").concat(e.wss))\n            };\n          }, void 0, e => !!(e.code !== hO.OPERATION_ABORTED && e.code !== hO.UNEXPECTED_RESPONSE || e.data && e.data.retry), n);\n        }(n, e, t, i));\n      try {\n        const e = await VB(r);\n        return r.forEach(e => e.cancel()), e;\n      } catch (e) {\n        throw e[0];\n      }\n    }\n    async function XB(e, t, i) {\n      let n = null;\n      const r = [],\n        o = async o => {\n          const s = CD(o ? \"WEBCS_DOMAIN_BACKUP_LIST\" : \"WEBCS_DOMAIN\").map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"));\n          return o && (await fN(1e3), null !== n) ? n : await xB({\n            fragementLength: CD(\"FRAGEMENT_LENGTH\"),\n            referenceList: s,\n            asyncMapHandler: n => (iP.debug(\"[\".concat(e.clientId, \"] update ticket, Connect to \").concat(o ? \"backup\" : \"\", \" choose_server:\"), n), function (e, t, i, n) {\n              const [r] = MB(t, [iF.CHOOSE_SERVER]);\n              let o = QO.networkState;\n              return UN(async () => {\n                o && QO.networkState === KO.OFFLINE && QO.onlineWaiter && (await rp.race([QO.onlineWaiter, fN(n && n.maxRetryTimeout || kN.maxRetryTimeout)])), o = QO.networkState;\n                const t = await _B(e, {\n                  data: r,\n                  cancelToken: i,\n                  headers: {\n                    \"Content-Type\": \"multipart/form-data;\"\n                  }\n                }, !0);\n                return LB(t, e);\n              }, () => !1, e => e.code !== hO.OPERATION_ABORTED && (e.code === hO.UPDATE_TICKET_FAILED ? e.data.retry : (iP.warning(\"[\".concat(t.clientId, \"] update ticket network error, retry\"), e), !0)), n);\n            }(n, e, t, i)),\n            allFailedhandler: e => {\n              throw e[0];\n            },\n            promisesCollector: r\n          });\n        };\n      try {\n        return n = await VB([o(!1), o(!0)]), r.length && r.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), n;\n      } catch (e) {\n        throw e[0];\n      }\n    }\n    function JB(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function QB(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? JB(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : JB(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    class ZB extends NO {\n      get isSuccess() {\n        return !!this.configs;\n      }\n      constructor(e, t) {\n        super(), iA(this, \"configs\", void 0), iA(this, \"store\", void 0), iA(this, \"joinInfo\", void 0), iA(this, \"cancelToken\", void 0), iA(this, \"retryConfig\", {\n          timeout: 3e3,\n          timeoutFactor: 1.5,\n          maxRetryCount: 1,\n          maxRetryTimeout: 1e4\n        }), iA(this, \"interval\", void 0), iA(this, \"mutex\", void 0), iA(this, \"mutableParamsRead\", !1), iA(this, \"configCache\", {}), iA(this, \"limit_bitrate\", void 0), this.mutex = new PN(\"config-distribute\", e), this.store = t;\n      }\n      startGetConfigDistribute(e, t) {\n        this.joinInfo = e, this.cancelToken = t, this.interval && this.stopGetConfigDistribute(), CD(\"ENABLE_CONFIG_DISTRIBUTE\") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {\n          this.updateConfigDistribute();\n        }, CD(\"CONFIG_DISTRIBUTE_INTERVAL\")));\n      }\n      stopGetConfigDistribute() {\n        this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0, this.configs = void 0, this.limit_bitrate = void 0;\n      }\n      async awaitConfigDistributeComplete() {\n        if (!this.mutex.isLocked) return;\n        (await this.mutex.lock())();\n      }\n      async updateConfigDistribute() {\n        if (!this.mutableParamsRead) {\n          this.mutableParamsRead = !0;\n          lP.reportApiInvoke(null, {\n            options: void 0,\n            name: LO.LOAD_CONFIG_FROM_LOCALSTORAGE,\n            tag: kO.TRACER\n          }).onSuccess(JSON.stringify(yD));\n        }\n        if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void iP.debug(\"[config-distribute] get config distribute interrupted have no joininfo\");\n        let e;\n        const t = await this.mutex.lock();\n        try {\n          e = await KB(this.joinInfo, this.cancelToken, this.retryConfig), iP.debug(\"[config-distribute] get config distribute\", JSON.stringify(e));\n          const i = function (e) {\n            var t;\n            const i = Qp(t = Object.keys(e).filter(e => /^webrtc_ng_global_parameter/.test(e))).call(t);\n            for (let t = 0; t < i.length; t++) for (let n = i.length - 1; n > t; n--) {\n              const t = i[n],\n                r = e[t].value;\n              if (\"number\" == typeof r.__priority) {\n                const o = r.__priority,\n                  s = i[n - 1],\n                  a = e[s].value;\n                if (\"number\" == typeof a.__priority) {\n                  if (!(o > a.__priority)) continue;\n                  {\n                    const e = t;\n                    i[n] = i[n - 1], i[n - 1] = e;\n                  }\n                } else {\n                  const e = t;\n                  i[n] = i[n - 1], i[n - 1] = e;\n                }\n              }\n            }\n            const n = Date.now(),\n              r = {};\n            return i.forEach(t => {\n              const i = e[t].value.__expires;\n              i && i <= n || (r[t] = e[t]);\n            }), r;\n          }(e);\n          this.cacheGlobalParameterConfig(i), this.store.hasStartJoinChannel || (this.store.isABTestSuccess = !0), this.configs = i;\n        } catch (e) {\n          const t = new uP(hO.NETWORK_RESPONSE_ERROR, e);\n          iP.warning(\"[config-distribute] \".concat(t.toString()));\n        } finally {\n          t();\n        }\n      }\n      getBitrateLimit() {\n        return this.limit_bitrate || void 0;\n      }\n      handleBitrateLimit(e) {\n        _x(e) && (this.limit_bitrate ? this.limit_bitrate && this.limit_bitrate.id !== e.id && this.emit(px.UPDATE_BITRATE_LIMIT, e) : this.emit(px.UPDATE_BITRATE_LIMIT, e));\n      }\n      getLowStreamConfigDistribute() {\n        return this.limit_bitrate && QB({}, this.limit_bitrate.low_stream_uplink);\n      }\n      handleABTestConfigDistribute(e) {\n        try {\n          const t = {},\n            i = Object.keys(e),\n            n = [];\n          i.forEach(i => {\n            const r = e[i].value;\n            t[i] = r;\n            const o = r.__id;\n            if (o && this.configCache[i] && this.configCache[i].__id === o) return;\n            const s = r.__type,\n              a = e[i].value,\n              c = e[i].tag;\n            let d = 0;\n            s ? s === vD.REALTIME && (d = 1) : Object.keys(a).some(e => Object.prototype.hasOwnProperty.call(gD, e) || !qU() && Object.prototype.hasOwnProperty.call(mD, e) ? (d = 1, !0) : void 0), n.push({\n              tag: c,\n              isApplied: d,\n              feature: i,\n              params: JSON.stringify(r)\n            });\n          }), n.forEach(e => {\n            let {\n              tag: t,\n              feature: i,\n              params: n,\n              isApplied: r\n            } = e;\n            this.store.sessionId && lP.abTest(this.store.sessionId, {\n              intSucc: 1,\n              isApplied: r,\n              tag: t,\n              feature: i,\n              params: n,\n              cid: this.store.cid,\n              uid: this.store.intUid\n            });\n          }), this.configCache = t;\n        } catch (e) {\n          iP.debug(\"handleABTestConfigDistribute error\", e);\n        }\n      }\n      cacheGlobalParameterConfig(e) {\n        const t = function (e) {\n          const t = {};\n          return Object.keys(e).forEach(i => {\n            const n = e[i].value,\n              r = n.__expires,\n              o = n.__type;\n            Object.keys(n).forEach(e => {\n              \"__id\" === e || \"__type\" === e || \"__priority\" === e || \"__expires\" === e || Object.prototype.hasOwnProperty.call(t, e) || (t[e] = QB(QB({\n                value: n[e]\n              }, r && {\n                expires: r\n              }), o && {\n                type: o\n              }));\n            });\n          }), t;\n        }(e);\n        try {\n          var i;\n          const n = null === (i = t.LIMIT_BITRATE) || void 0 === i ? void 0 : i.value;\n          delete t.LIMIT_BITRATE, n && _x(n) && this.handleBitrateLimit(n), this.limit_bitrate = n, this.handleGlobalParameterConfig(t), this.handleABTestConfigDistribute(e), function (e) {\n            try {\n              const t = Date.now();\n              Object.keys(e).forEach(i => {\n                const {\n                  value: n,\n                  type: r,\n                  expires: o\n                } = e[i];\n                o && o <= t || ((r === vD.REALTIME || Object.prototype.hasOwnProperty.call(gD, i)) && (yD[i] = n, TD[i] = n, iP.debug(\"Update realtime parameters from config distribute\", i, n)), r || qU() || !Object.prototype.hasOwnProperty.call(mD, i) || (yD[i] = n, TD[i] = n, iP.debug(\"Update gateway parameters from config distribute\", i, n)));\n              });\n            } catch (t) {\n              iP.error(\"Error update config immediately: \".concat(e), t.message);\n            }\n          }(t);\n          const r = JSON.stringify(t),\n            o = window.btoa(r);\n          window.localStorage.setItem(\"websdk_ng_global_parameter\", o), iP.debug(\"Caching global parameters \".concat(r));\n        } catch (e) {\n          iP.error(\"Error caching global parameters:\", e.message);\n        }\n      }\n      handleGlobalParameterConfig(e) {\n        try {\n          const t = Date.now();\n          Object.keys(e).forEach(i => {\n            switch (i) {\n              case \"CLIENT_ROLE_OPTIONS\":\n                if (Object.prototype.hasOwnProperty.call(TD, i)) {\n                  const {\n                    value: n,\n                    expires: r\n                  } = e[i];\n                  if (r && r <= t) return;\n                  bN(TD[i], n) || (yD[i] = n, TD[i] = n, this.emit(px.UPDATE_CLIENT_ROLE_OPTIONS, n), iP.debug(\"Updating client role options: \".concat(JSON.stringify(n))));\n                }\n                break;\n              case \"REMOTE_VIDEO_STREAM_TYPE\":\n                if (Object.prototype.hasOwnProperty.call(TD, i)) {\n                  var n;\n                  const {\n                    value: r,\n                    expires: o\n                  } = e[i];\n                  if (o && o <= t) return;\n                  \"number\" == typeof r && Ln(n = [0, 1, 4, 5, 6, 7, 8, 9]).call(n, r) && (yD[i] = {\n                    value: r\n                  }, TD[i] = r, this.emit(px.UPDATE_REMOTE_VIDEO_STREAM_TYPE, r), iP.debug(\"Updating client remote stream type: \".concat(JSON.stringify(r))));\n                }\n                break;\n              case \"ENABLE_FORCE_HLS\":\n                if (Object.prototype.hasOwnProperty.call(TD, i)) {\n                  const {\n                    value: n,\n                    expires: r\n                  } = e[i];\n                  if (r && r <= t) return;\n                  bN(TD[i], n) || (yD[i] = n, TD[i] = n, this.emit(px.FALLBACK_TO_HLS, n), iP.debug(\"Updating enable force hls: \".concat(JSON.stringify(n))));\n                }\n                break;\n              case \"VOS_CONFIGURE\":\n                if (Object.prototype.hasOwnProperty.call(TD, i)) {\n                  const {\n                    value: n,\n                    expires: r\n                  } = e[i];\n                  if (r && r <= t) return;\n                  bN(TD[i], n) || (yD[i] = n, TD[i] = n, this.emit(px.UPDATE_VOS_CONFIGURE, n), iP.debug(\"Updating vos configure: \".concat(JSON.stringify(n))));\n                }\n            }\n          });\n        } catch (e) {\n          iP.error(\"Error handling global parameter config:\", e.message);\n        }\n      }\n    }\n    class $B extends NO {\n      constructor() {\n        super(...arguments), iA(this, \"resultStorage\", new Map());\n      }\n      setLocalAudioStats(e, t, i) {\n        this.record(\"AUDIO_INPUT_LEVEL_TOO_LOW\", e, this.checkAudioInputLevel(i, t)), this.record(\"SEND_AUDIO_BITRATE_TOO_LOW\", e, this.checkSendAudioBitrate(i, t));\n      }\n      setLocalVideoStats(e, t, i) {\n        this.record(\"SEND_VIDEO_BITRATE_TOO_LOW\", e, this.checkSendVideoBitrate(i, t)), this.record(\"FRAMERATE_INPUT_TOO_LOW\", e, this.checkFramerateInput(i, t)), this.record(\"FRAMERATE_SENT_TOO_LOW\", e, this.checkFramerateSent(i)), !t.muted && this.record(\"VIDEO_ENCODE_FAILED\", e, this.checResolutionSent(i));\n      }\n      setRemoteAudioStats(e, t) {\n        const i = e.getUserId();\n        this.record(\"AUDIO_OUTPUT_LEVEL_TOO_LOW\", i, this.checkAudioOutputLevel(t));\n      }\n      setRemoteVideoStats(e, t) {\n        const i = e.getUserId();\n        this.record(\"RECV_VIDEO_DECODE_FAILED\", i, this.checkVideoDecode(t));\n      }\n      record(e, t, i) {\n        if (CD(\"STATS_UPDATE_INTERVAL\") > 500) return;\n        this.resultStorage.has(e) || this.resultStorage.set(e, {\n          result: [],\n          isPrevNormal: !0\n        });\n        const n = this.resultStorage.get(e);\n        if (!n) return;\n        n.result.push(i);\n        const r = \"VIDEO_ENCODE_FAILED\" === e ? CD(\"ENCODE_EXCEPTION_TIMES\") : 5;\n        if (n.result.length >= r) {\n          var o;\n          const i = Ln(o = n.result).call(o, !0);\n          n.isPrevNormal && !i && this.emit(\"exception\", ej[e], e, t), !n.isPrevNormal && i && this.emit(\"exception\", ej[e] + 2e3, e + \"_RECOVER\", t), n.isPrevNormal = i, n.result = [];\n        }\n      }\n      checkAudioOutputLevel(e) {\n        return !(e.receiveBitrate > 0 && 0 === e.receiveLevel);\n      }\n      checkAudioInputLevel(e, t) {\n        return t instanceof Wk && !t.isActive || !!t.muted || 0 !== e.sendVolumeLevel;\n      }\n      checkFramerateInput(e, t) {\n        let i = null;\n        t._encoderConfig && t._encoderConfig.frameRate && (i = dF(t._encoderConfig.frameRate));\n        const n = e.captureFrameRate;\n        return !i || !n || !(i > 10 && n < 5 || i < 10 && i >= 5 && n <= 1);\n      }\n      checkFramerateSent(e) {\n        return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1);\n      }\n      checResolutionSent(e) {\n        var t;\n        return !(!e.codecType || Ln(t = CD(\"ENCODE_EXCEPTION_VALIDATE_CODEC\")).call(t, e.codecType.toLocaleLowerCase())) || !e.captureFrameRate || 0 !== e.sendFrameRate || 0 !== e.sendResolutionWidth || 0 !== e.sendResolutionHeight;\n      }\n      checkSendVideoBitrate(e, t) {\n        return !!t.muted || 0 !== e.sendBitrate;\n      }\n      checkSendAudioBitrate(e, t) {\n        return t instanceof Wk && !t.isActive || !!t.muted || 0 !== e.sendBitrate;\n      }\n      checkVideoDecode(e) {\n        return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate;\n      }\n    }\n    const ej = {\n      FRAMERATE_INPUT_TOO_LOW: 1001,\n      FRAMERATE_SENT_TOO_LOW: 1002,\n      SEND_VIDEO_BITRATE_TOO_LOW: 1003,\n      RECV_VIDEO_DECODE_FAILED: 1005,\n      AUDIO_INPUT_LEVEL_TOO_LOW: 2001,\n      AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,\n      SEND_AUDIO_BITRATE_TOO_LOW: 2003,\n      VIDEO_ENCODE_FAILED: 2004\n    };\n    const tj = new class {\n      markSubscribeStart(e, t) {\n        performance.mark(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n      }\n      markPublishStart(e, t) {\n        performance.mark(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n      }\n      measureFromSubscribeStart(e, t) {\n        const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n        if (i.length > 0) {\n          const e = i[i.length - 1];\n          return Math.round(performance.now() - e.startTime);\n        }\n        return 0;\n      }\n      measureFromPublishStart(e, t) {\n        const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n        if (i.length > 0) {\n          const e = i[i.length - 1];\n          return Math.round(performance.now() - e.startTime);\n        }\n        return 0;\n      }\n    }();\n    function ij(e, t) {\n      var i = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        t && (n = n.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), i.push.apply(i, n);\n      }\n      return i;\n    }\n    function nj(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? ij(Object(i), !0).forEach(function (t) {\n          iA(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ij(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    class rj {\n      constructor(e) {\n        iA(this, \"store\", void 0), iA(this, \"onStatsException\", void 0), iA(this, \"onUploadPublishDuration\", void 0), iA(this, \"onStatsChanged\", void 0), iA(this, \"onVideoCodecChanged\", void 0), iA(this, \"localStats\", new Map()), iA(this, \"remoteStats\", new Map()), iA(this, \"updateStatsInterval\", void 0), iA(this, \"trafficStats\", void 0), iA(this, \"trafficStatsPeerList\", []), iA(this, \"uplinkStats\", void 0), iA(this, \"exceptionMonitor\", void 0), iA(this, \"p2pChannel\", void 0), iA(this, \"scalabilityMode\", iD.L1T1), iA(this, \"updateStats\", () => {\n          this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));\n        }), this.store = e, this.exceptionMonitor = new $B(), this.exceptionMonitor.on(\"exception\", (e, t, i) => {\n          this.onStatsException && this.onStatsException(e, t, i);\n        });\n      }\n      startUpdateStats() {\n        this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));\n      }\n      stopUpdateStats() {\n        this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);\n      }\n      reset() {\n        this.localStats = new Map(), this.remoteStats = new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;\n      }\n      getLocalAudioTrackStats() {\n        return this.localStats.get(Rx.LocalAudioTrack) || nj({}, YP);\n      }\n      getLocalVideoTrackStats() {\n        return this.localStats.get(Rx.LocalVideoTrack) || nj({}, zP);\n      }\n      getRemoteAudioTrackStats(e) {\n